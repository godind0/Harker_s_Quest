// Procedural characters module

#define HAIR_DEF 25388  //rgb(96, 100, 96)
#define MUSTACHE_DEF 27501 //rgb(104, 108, 104)
#define BEARD_DEF 25452 //rgb(100, 110, 100)
#define SKIN_DEF 58607 //rgb(224, 156, 120)
#define SKIN_DARK_DEF 58444 //rgb(224, 136, 96)
#define COAT_DEF 512 //rgb(0, 64, 0)
#define COAT_LIGHT_DEF 736 //rgb(0, 92, 0)
#define COAT_DARK_DEF 256 //rgb(0, 32, 0)
#define NECKTIE_DEF 0 //rgb(0, 0, 0)
#define UNDERSHIRT_DEF 65535 //rgb(248, 252, 248)
#define PANTS_DEF 4290 //rgb(16, 24, 16)
#define PANTS_DARK_DEF 32 //rgb(0, 4, 0)
#define SHOES_DEF 20800 //rgb(80, 40, 0)
#define SHOES_DARK_DEF 14528 //rgb(56, 24, 0)
#define EYE_DEF 2048 //rgb(10, 0, 0)
#define BODY_PARTS_NB 8
#define CLOTHES_PIECES_NB 100

Dictionary* sprites[];
Dictionary* indexedColors;
Dictionary* templatePropertyType;
Dictionary* secCharStartProperties[];

DynamicSprite* recoloredDynamicSprites[];

Set* characterIndextoManage;

GUI* clothesChangeGUI;
Button* clothesChangeCharVisual;
Label* clothesChangeBodyPart;
Label* clothesChangeColor;
Button* clothesChangeSetArrow_back;
Button* clothesChangeSetArrow_next;
Button* clothesChangeColorArrow_back;
Button* clothesChangeColorArrow_next;

int dressUpRoomCallIndex = -1; //when dressing up, the CallRoomScript function is called with this index

Dictionary* clothesChangeVisualColorDictionary;
int clothesChangeVisualOriginalGraphicIndex = -1;
DynamicSprite* clothesChangeCharVisualSprite;
Clothes playerClothes[CLOTHES_PIECES_NB];
Dictionary* playerClothesDictionary;
bool clothesChangeAvailableBodyParts[BODY_PARTS_NB];
int clothesPartsIndexes[BODY_PARTS_NB];
int clothesWornByPlayer[BODY_PARTS_NB];

//#################################################### UTILITIES #####################################################
String viewTypeToString(viewTypes thisViewType)
{
  switch(thisViewType)
  {
    case walkView:
      return "view_walk";
      break;
    case sitView:
      return "view_sit";
      break;
    case climbView:
      return "view_climb";
      break;
    default:
      break;
  }
}

String bodyPartsToString(bodyParts thisPart)
{
  switch(thisPart)
  {
    case BP_hair:
      return "hair";
      break;
    case BP_skin:
      return "skin";
      break;
    case BP_coat:
      return "coat";
      break;
    case BP_necktie:
      return "necktie";
      break;
    case BP_undershirt:
      return "undershirt";
      break;
    case BP_pants:
      return "pants";
      break;
    case BP_shoes:
      return "shoes";
      break;
    default:
      return "null";
      break;
  }
}

bodyParts stringToBodyParts(String thisPart)
{
  switch(thisPart)
  {
    case "hair":
      return BP_hair;
      break;
    case "skin":
      return BP_skin;
      break;
    case "coat":
      return BP_coat;
      break;
    case "necktie":
      return BP_necktie;
      break;
    case "undershirt":
      return BP_undershirt;
      break;
    case "pants":
      return BP_pants;
      break;
    case "shoes":
      return BP_shoes;
      break;
    default:
      return 0;
      break;
  }
}

//########################################################################### VIEW MANAGEMENT ###############################
int getViewIndex(this Character*, viewTypes thisViewType)
{
  String viewIndexS;
  int charID = this.ID;
  
  switch(thisViewType)
  {
    case walkView:
      viewIndexS = sprites[charID].Get(viewTypeToString(walkView));
      return viewIndexS.AsInt;
      break;
    case sitView:
      viewIndexS = sprites[charID].Get(viewTypeToString(sitView));
      return viewIndexS.AsInt;
      break;
    case climbView:
      viewIndexS = sprites[charID].Get(viewTypeToString(climbView));
      return viewIndexS.AsInt;
      break;
    default:
      break;
  }
}

function fillDefaultView(int charID, viewTypes thisViewType, int viewIndex)
{
  String viewName;
  String view_loop_frame;
  int nbLoops;
  int nbFrames;
  ViewFrame* thisFrame;
  
  Character* thisChar = character[charID];
  
  int y;
  int z;
  
  sprites[charID].Set(viewTypeToString(thisViewType), String.Format("%d", viewIndex));
  viewName = viewTypeToString(thisViewType);
  nbLoops = Game.GetLoopCountForView(thisViewType);
  for(y = 0 ; y < nbLoops ; y++)
  {
    nbFrames = Game.GetFrameCountForLoop(viewIndex, y);
    for(z = 0 ; z < nbFrames ; z++)
    {
      view_loop_frame = String.Format("%s_DEF_%d_%d", viewName, y, z);
      thisFrame = Game.GetViewFrame(viewIndex, y, z);
      sprites[charID].Set(view_loop_frame, String.Format("%d", thisFrame.Graphic));
      view_loop_frame = String.Format("%s_DEF_FLIPPED_%d_%d", viewName, y, z);
      sprites[charID].Set(view_loop_frame, String.Format("%d", thisFrame.Flipped));
    }
  }
}

function fillDefaultViews(int charID)
{
  Character* thisChar = character[charID];  
  fillDefaultView(charID, walkView, thisChar.NormalView);
  
  if(thisChar.GetProperty("sitView") != -1)
  {
    fillDefaultView(charID, sitView, thisChar.GetProperty("sitView"));
  }
  
  if(thisChar.GetProperty("climbView") != -1)
  {
    fillDefaultView(charID, climbView, thisChar.GetProperty("climbView"));
  }
}

// creates an array of dictionaries containing each sprite to use for each character
function createSpriteDictionaries()
{
  int nbChars = Game.CharacterCount;
  sprites = new Dictionary[nbChars];
  Character* thisChar;
  int i;
  
  for(i = 0 ; i < nbChars ; i++)
  {
    sprites[i] = Dictionary.Create(eNonSorted);
    thisChar = character[i];
    fillDefaultViews(i);
  }  
}

bool hasView (this Character*, viewTypes thisViewType)
{
  return sprites[this.ID].Contains(viewTypeToString(thisViewType));
}

//################################################################### COLOR MANAGEMENT #############################################
// gets a color index from the characterColors enum
int getCharacterHairColor(characterColors targetColor)
{
  if(targetColor == CC_random || targetColor == CC_skin_ivory || targetColor == CC_skin_porcelain || targetColor == CC_skin_roseBeige)
  {
    int i = Random(5);
    switch(i)
    {
      case 0:
        targetColor = CC_hair_blond;
        break;
      case 1:
        targetColor = CC_hair_brown;
        break;
      case 2:
        targetColor = CC_hair_dark;
        break;
      case 3:
        targetColor = CC_hair_grey;
        break;
      case 4:
        targetColor = CC_hair_red;
        break;
      case 5:
        targetColor = CC_hair_white;
        break;
    }
  }
  
  if(targetColor == CC_skin_band || targetColor == CC_skin_dark || targetColor == CC_skin_siena || targetColor == CC_skin_warmIvory)
  {
    int i = Random(2);
    switch(i)
    {
      case 0:
        targetColor = CC_hair_white;
        break;
      case 1:
        targetColor = CC_hair_grey;
        break;
      case 2:
        targetColor = CC_hair_dark;
        break;
    }
  }
  
  switch(targetColor)
  {
    case CC_hair_blond:
      return 65159;
      break;
    case CC_hair_brown:
      return 33410;
      break;
    case CC_hair_dark:
      return 6272;
      break;
    case CC_hair_grey:
      return 48599;
      break;
    case CC_hair_red:
      return 53953;
      break;
    case CC_hair_white:
      return 63357;
      break;
  }
}

// gets an array of color tones with different shading ([0] = light ; [1] = main ; [2] = dark)
int[] getCharacterColorTones(characterColors targetColor)
{
  int paleToneShade[] = new int[3];
  switch(targetColor)
  {
    case CC_black:
      paleToneShade[0] = 12710;
      paleToneShade[1] = 4258;
      paleToneShade[2] = 32;
      break;
    case CC_white:
      paleToneShade[0] = 65535;
      paleToneShade[1] = 61277;
      paleToneShade[2] = 52825;
      break;
    case CC_grey:
      paleToneShade[0] = 44373;
      paleToneShade[1] = 35953;
      paleToneShade[2] = 27469;
      break;
    case CC_brown:
      paleToneShade[0] = 46121;
      paleToneShade[1] = 27269;
      paleToneShade[2] = 18851;
      break;
    case CC_green:
      paleToneShade[0] = 3394;
      paleToneShade[1] = 3073;
      paleToneShade[2] = 544;
      break;
    case CC_blue:
      paleToneShade[0] = 16958;
      paleToneShade[1] = 6397;
      paleToneShade[2] = 2167;
      break;
    case CC_red:
      paleToneShade[0] = 53248;
      paleToneShade[1] = 43008;
      paleToneShade[2] = 26624;
      break;
    case CC_yellow:
      paleToneShade[0] = 59201;
      paleToneShade[1] = 48641;
      paleToneShade[2] = 33824;
      break;
    case CC_purple:
      paleToneShade[0] = 51321;
      paleToneShade[1] = 41076;
      paleToneShade[2] = 26701;
      break;
    case CC_beige:
      paleToneShade[0] = 61075;
      paleToneShade[1] = 60942;
      paleToneShade[2] = 58663;
      break;
    case CC_orange:
      paleToneShade[0] = 64516;
      paleToneShade[1] = 64320;
      paleToneShade[2] = 47712;
      break;
    case CC_cyan:
      paleToneShade[0] = 1884;
      paleToneShade[1] = 1527;
      paleToneShade[2] = 1007;
      break;
    case CC_skin_porcelain:
      paleToneShade[0] = 65303;
      paleToneShade[1] = 65303;
      paleToneShade[2] = 65072;
      break;
    case CC_skin_ivory:
      paleToneShade[0] = 65076;
      paleToneShade[1] = 65076;
      paleToneShade[2] = 64847;
      break;
    case CC_skin_warmIvory:
      paleToneShade[0] = 65400;
      paleToneShade[1] = 65400;
      paleToneShade[2] = 65267;
      break;
    case CC_skin_roseBeige:
      paleToneShade[0] = 65008;
      paleToneShade[1] = 65008;
      paleToneShade[2] = 64616;
      break;
    case CC_skin_siena:
      paleToneShade[0] = 43914;
      paleToneShade[1] = 43914;
      paleToneShade[2] = 27011;
      break;
    case CC_skin_band:
      paleToneShade[0] = 39914;
      paleToneShade[1] = 39914;
      paleToneShade[2] = 25059;
      break;
    case CC_skin_dark:
      paleToneShade[0] = 33512;
      paleToneShade[1] = 33512;
      paleToneShade[2] = 12579;
      break;
  }
  
  return paleToneShade;
}

// pick a random jacket color among available colors
characterColors getCharacterRandomJacketColor()
{
  int i = Random(11);
  switch(i)
  {
    case 0:
      return CC_beige;
      break;
    case 1:
      return CC_black;
      break;
    case 2:
      return CC_blue;
      break;
    case 3:
      return CC_brown;
      break;
    case 4:
      return CC_cyan;
      break;
    case 5:
      return CC_green;
      break;
    case 6:
      return CC_grey;
      break;
    case 7:
      return CC_orange;
      break;
    case 8:
      return CC_purple;
      break;
    case 9:
      return CC_red;
      break;
    case 10:
      return CC_white;
      break;
    case 11:
      return CC_yellow;
      break;
  }
}

// pick a random skin color among the predefined ones
characterColors getCharacterRandomSkinColor()
{
  int i = Random(6);
  switch(i)
  {
    case 0:
      return CC_skin_band;
      break;
    case 1:
      return CC_skin_dark;
      break;
    case 2:
      return CC_skin_ivory;
      break;
    case 3:
      return CC_skin_porcelain;
      break;
    case 4:
      return CC_skin_roseBeige;
      break;
    case 5:
      return CC_skin_siena;
      break;
    case 6:
      return CC_skin_warmIvory;
      break;
  } 
}

String getCharColorType(int colorCode)
{
  String colorCodeS = String.Format("%d", colorCode);
  String returnString;
  
  if(indexedColors.Contains(colorCodeS))
  {
    return indexedColors.Get(colorCodeS);
  } else
  {
    return "null";
  }
}

int getCharacterColorCode(String colorType,  Dictionary* newColors)
{
  colorType = newColors.Get(colorType);
  int colorCode = colorType.AsInt;
  return colorCode;
}

//###################################################################### COLOR DICTIONARIES ############################################
// build a color dictionary
Dictionary* makeAColorDictionary(int hair, int mustache, int skin, int skinShadow, int coat, int coatLight, int coatDark, int neckTie, int underShirt, int pants, int pantsDark, int shoe, int shoeDark,  int beard)
{
  Dictionary* colorDict = Dictionary.Create(eSorted);
  colorDict.Set("hair", String.Format("%d", hair));
  colorDict.Set("mustache", String.Format("%d", mustache));
  colorDict.Set("beard", String.Format("%d", beard));
  colorDict.Set("skin", String.Format("%d", skin));
  colorDict.Set("skinShadow", String.Format("%d", skinShadow));
  colorDict.Set("coat", String.Format("%d", coat));
  colorDict.Set("coatLight", String.Format("%d", coatLight));
  colorDict.Set("coatDark", String.Format("%d", coatDark));
  colorDict.Set("neckTie", String.Format("%d", neckTie));
  colorDict.Set("underShirt", String.Format("%d", underShirt));
  colorDict.Set("pants", String.Format("%d", pants));
  colorDict.Set("pantsDark", String.Format("%d", pantsDark));
  colorDict.Set("shoe", String.Format("%d", shoe));
  colorDict.Set("shoeDark", String.Format("%d", shoeDark));
  
  return colorDict;
}

Dictionary* changeColorDictionary_manual(Dictionary* initialColorDict, bodyParts partToChange, int mainColor, int lightColor, int darkColor)
{
  int thisColor;
  
  switch(partToChange)
  {
    case BP_coat:
      initialColorDict.Set("coatLight", String.Format("%d", lightColor));
      initialColorDict.Set("coat", String.Format("%d", mainColor));
      initialColorDict.Set("coatDark", String.Format("%d", darkColor));
      break;
    case BP_hair:
      initialColorDict.Set("hair", String.Format("%d", mainColor));
      if(initialColorDict.Get("hair") == initialColorDict.Get("mustache"))
      {
        initialColorDict.Set("mustache", String.Format("%d", mainColor));
      }
      if(initialColorDict.Get("hair") == initialColorDict.Get("beard"))
      {
        initialColorDict.Set("beard", String.Format("%d", mainColor));
      }
      break;
    case BP_necktie:
      initialColorDict.Set("neckTie", String.Format("%d", mainColor));
      break;
    case BP_pants:
      initialColorDict.Set("pants", String.Format("%d", mainColor));
      initialColorDict.Set("pantsDark", String.Format("%d", darkColor));
      break;
    case BP_shoes:
      initialColorDict.Set("shoe", String.Format("%d", mainColor));
      initialColorDict.Set("shoeDark", String.Format("%d", darkColor));
      break;      
  }
  return initialColorDict;
}

// change parts of a color dictionary
Dictionary* changeColorDictionary(Dictionary* initialColorDict, bodyParts partToChange, characterColors targetColor)
{
  int listColors[] = new int[3];
  listColors = getCharacterColorTones(targetColor);
  
  if(partToChange == BP_necktie)
  {
    listColors[1] = listColors[2];
  }
  
  initialColorDict = changeColorDictionary_manual(initialColorDict, partToChange, listColors[0], listColors[1], listColors[2]);
  return initialColorDict;
}

//makes a dictionary of the colors currently used for a character
Dictionary* getColorDictionary(this Character*)
{
  if(sprites[this.ID].Contains("proceduralCharacter"))
  {
    String hairS = sprites[this.ID].Get("hair");
    String mustacheS = sprites[this.ID].Get("mustache");
    String skinS = sprites[this.ID].Get("skin");
    String skinShadowS = sprites[this.ID].Get("skinShadow");
    String coatS = sprites[this.ID].Get("coat");
    String coatLightS = sprites[this.ID].Get("coatLight");
    String coatDarkS = sprites[this.ID].Get("coatDark");
    String neckTieS = sprites[this.ID].Get("neckTie");
    String undershirtS = sprites[this.ID].Get("underShirt");
    String pantsS = sprites[this.ID].Get("pants");
    String pantsDarkS = sprites[this.ID].Get("pantsDark");
    String shoeS = sprites[this.ID].Get("shoe");
    String shoeDarkS = sprites[this.ID].Get("shoeDark");
    String beardS = sprites[this.ID].Get("beard");
    
    return makeAColorDictionary(hairS.AsInt, mustacheS.AsInt, skinS.AsInt, skinShadowS.AsInt, coatS.AsInt, coatLightS.AsInt, coatDarkS.AsInt, neckTieS.AsInt, undershirtS.AsInt, pantsS.AsInt, pantsDarkS.AsInt, shoeS.AsInt, shoeDarkS.AsInt, beardS.AsInt);
  } else
  {
    Dictionary* falseDict = Dictionary.Create(eNonSorted);
    falseDict.Set("error", "error");
    return falseDict;
  }
}

// makes the 'default' color dictionary,  based on the default sprites' color
Dictionary* makeDefaultColorDictionary()
{
  return makeAColorDictionary(HAIR_DEF, MUSTACHE_DEF, SKIN_DEF, SKIN_DARK_DEF, COAT_DEF, COAT_LIGHT_DEF, COAT_DARK_DEF, NECKTIE_DEF, UNDERSHIRT_DEF, PANTS_DEF, PANTS_DARK_DEF, SHOES_DEF, SHOES_DARK_DEF, BEARD_DEF);
}

// creates a dictionary for a character recolor,  use CC_random to chose random color EXCEPT for the mustache (then use -1)
Dictionary* createASecondaryNPCDictionary(characterColors thisSkin, characterColors thisHair, int hasMustache, int hasBeard, characterColors thisJacket, characterColors thisNecktie, characterColors thisUndershirt, characterColors thisPant, characterColors thisShoe)
{
  int finalHair;
  int finalSkin[];
  int finalMustache;
  int finalBeard;
  int finalJacket[];
  int finalNecktie[];
  int finalUndershirt[];
  int finalPants[];
  int finalShoes[];
  
  // SKIN
  if(thisSkin == CC_random)
  {
    thisSkin = getCharacterRandomSkinColor();
  }
  finalSkin = getCharacterColorTones(thisSkin);
  
  // HAIR
  if(thisHair == CC_random)
  {
    thisHair = thisSkin;
  }
  finalHair = getCharacterHairColor(thisHair);
  
  // MUSTACHE
  if(hasMustache == -1)
  {
    hasMustache = Random(1);
  }
  if(hasMustache == 0)
  {
    finalMustache = finalSkin[1];
  } else
  {
    finalMustache = finalHair;
  }
  
  // BEARD
  if(hasBeard == -1)
  {
    hasBeard = Random(1);
  }
  if(hasBeard == 0)
  {
    finalBeard = finalSkin[1];
  } else
  {
    finalBeard = finalHair;
  }
  
  // JACKET
  if(thisJacket == CC_random)
  {
    thisJacket = getCharacterRandomJacketColor();
  }
  finalJacket = getCharacterColorTones(thisJacket);
  
  // NECKTIE
  if(thisNecktie == CC_random)
  {
    int i = Random(1);
    if(i == 0)
    {
      thisNecktie = thisJacket;
    } else
    {
      thisNecktie = CC_black;
    }
  }
  finalNecktie = getCharacterColorTones(thisNecktie);
  
  // UNDERSHIRT
  if(thisUndershirt == CC_random)
  {
    thisUndershirt = CC_white;
  }
  finalUndershirt = getCharacterColorTones(thisUndershirt);
  
  // PANTS
  if(thisPant == CC_random)
  {
    int i = Random(5);
    switch(i)
    {
      case 0:
        thisPant = thisJacket;
        break;
      case 1:
        thisPant = CC_beige;
        break;
      case 2:
        thisPant = CC_black;
        break;
      case 3:
        thisPant = CC_brown;
        break;
      case 4:
        thisPant = CC_grey;
        break;
      case 5:
        thisPant = CC_white;
        break; 
    }
  }
  finalPants = getCharacterColorTones(thisPant);
  
  // SHOES
  if(thisShoe == CC_random)
  {
    int i = Random(6);
    switch(i)
    {
      case 0:
        thisShoe = thisJacket;
        break;
      case 1:
        thisShoe = CC_beige;
        break;
      case 2:
        thisShoe = CC_black;
        break;
      case 3:
        thisShoe = CC_brown;
        break;
      case 4:
        thisShoe = CC_grey;
        break;
      case 5:
        thisShoe = CC_white;
        break;
      case 6:
        thisShoe = thisPant;
        break; 
    }
  }
  finalShoes = getCharacterColorTones(thisShoe);
  
  return makeAColorDictionary(finalHair, finalMustache, finalSkin[1], finalSkin[2], finalJacket[1], finalJacket[0], finalJacket[2], finalNecktie[2], finalUndershirt[0], finalPants[1], finalPants[2], finalShoes[1], finalShoes[2], finalBeard);
}

// uses the createASecondaryNPC function with only the randomized parameters
Dictionary* createARandomSecondaryNPCDictionary()
{
  return createASecondaryNPCDictionary(CC_random, CC_random, -1, -1, CC_random, CC_random, CC_random, CC_random, CC_random);
}

//############################################################################## DYNAMIC SPRITE MANAGEMENT ##################################
//adds a dynamic sprite
int addRecoloredDynamicSprite(int charID, DynamicSprite* thisDynamicSprite)
{
  int arrayIndex;
  
  if(!sprites[charID].Contains("recoloredDynamicSpritesLastIndex"))
  {
    arrayIndex = (1000 + (charID * 100));
  } else
  {
    String arrayIndexS = sprites[charID].Get("recoloredDynamicSpritesLastIndex");
    arrayIndex = arrayIndexS.AsInt;
    arrayIndex++;
  }
  
  recoloredDynamicSprites[arrayIndex] = thisDynamicSprite;
  
  sprites[charID].Set("recoloredDynamicSpritesLastIndex", String.Format("%d", arrayIndex));
  
  return arrayIndex;
}

//deletes a dynamic sprite after it has been abandonned
function deleteCharactersRecoloredDynamicSprites(int charID)
{
  int firstIndex;
  String lastIndexS;
  int lastIndex;
  if(sprites[charID].Contains("recoloredDynamicSpritesLastIndex"))
  {
    lastIndexS = sprites[charID].Get("recoloredDynamicSpritesLastIndex");
    lastIndex =  1 + lastIndexS.AsInt;
    for(firstIndex = (1000 + (charID * 100)) ; firstIndex < lastIndex ; firstIndex++)
    {
      if(recoloredDynamicSprites[firstIndex] != null)
      {
        recoloredDynamicSprites[firstIndex].Delete();
      }
    }
    sprites[charID].Remove("recoloredDynamicSpritesLastIndex");
  }
}

//########################################################################## RECOLOR FUNCTIONS ############################################
DynamicSprite* recolorSprite(int thisFrameGraphic,  Dictionary* colors)
{
  DynamicSprite* thisDynamicSprite;
  DrawingSurface* thisSurface;
  int surfaceWidth;
  int surfaceHeight;
  int surfaceX;
  int surfaceY;
  int surfaceXY_colorCode;
  String surfaceXY_colorType;
  
  thisDynamicSprite = DynamicSprite.CreateFromExistingSprite(thisFrameGraphic, true);   //create the new sprite
      
  thisSurface = thisDynamicSprite.GetDrawingSurface();
  surfaceHeight = thisSurface.Height;
  surfaceWidth = thisSurface.Width;
  
  for(surfaceX = 0 ; surfaceX < surfaceWidth ; surfaceX++)                              //look at each pixel
  {
    for(surfaceY = 0 ; surfaceY < surfaceHeight ; surfaceY++)
    {
      surfaceXY_colorCode = thisSurface.GetPixel(surfaceX, surfaceY);
      if(surfaceXY_colorCode > -1)                                                      //if it's not transparent, figure out what body part it is based on our default color codes                          
      {
        surfaceXY_colorType = getCharColorType(surfaceXY_colorCode);
        if(surfaceXY_colorType != "" && surfaceXY_colorType != "eyes" && surfaceXY_colorType != "null")                  //if it is a body part
        {
          thisSurface.DrawingColor = getCharacterColorCode(surfaceXY_colorType, colors);//paint it the right color
          thisSurface.DrawPixel(surfaceX, surfaceY);
        }
      }
    }
  }
  
  return thisDynamicSprite;
}

function setupRecoloredView(Character* thisChar, viewTypes thisViewType,  Dictionary* colors)
{
  String viewName;
  int thisView;
  int nbLoops;
  int nbFrames;
  String thisFrameGraphicS;
  int thisFrameGraphic;
  ViewFrame* thisFrame;
  
  int charID = thisChar.ID;
  String view_loop_frame;
  
  int graphicSlot;
  DynamicSprite* thisDynamicSprite;
  int thisDynamicSpriteGraphic;
  
  thisView = thisChar.getViewIndex(thisViewType);
  viewName = viewTypeToString(thisViewType);
  nbLoops = Game.GetLoopCountForView(thisView);                                             //Get total loops in the current character view
  
  int y;
  int z;
  
  for(y = 0 ; y < nbLoops ; y++)                                                            //For each loop...
  {
    nbFrames = Game.GetFrameCountForLoop(thisView, y);                                      //Get the number of frames in the current loop
    for(z = 0 ; z < nbFrames ; z++)                                                         //For each frame in the current loop
    {
      thisFrameGraphicS = sprites[charID].Get(String.Format("%s_DEF_%d_%d", viewName, y, z)); //Get the frame...
      thisFrameGraphic = thisFrameGraphicS.AsInt;
      thisDynamicSprite = recolorSprite(thisFrameGraphic, colors);
      
      view_loop_frame = String.Format("%s_RECOLORED_%d_%d", viewName, y, z);                //define a new dictionary name for it
      sprites[charID].Set(view_loop_frame, String.Format("%d", thisDynamicSpriteGraphic));  //insert the proper number
      thisFrame = Game.GetViewFrame(thisView, y, z);
      thisDynamicSpriteGraphic = addRecoloredDynamicSprite(charID, thisDynamicSprite);
      thisFrame.Graphic = recoloredDynamicSprites[thisDynamicSpriteGraphic].Graphic;
    }
  }
}

function recolor(this Character*, Dictionary* colors)
{
  deleteCharactersRecoloredDynamicSprites(this.ID);
  
  sprites[this.ID].Set("proceduralCharacter", "true");
  sprites[this.ID].Set("hair", colors.Get("hair"));
  sprites[this.ID].Set("mustache", colors.Get("mustache"));
  sprites[this.ID].Set("beard", colors.Get("beard"));
  sprites[this.ID].Set("skin", colors.Get("skin"));
  sprites[this.ID].Set("skinShadow", colors.Get("skinShadow"));
  sprites[this.ID].Set("coat", colors.Get("coat"));
  sprites[this.ID].Set("coatLight", colors.Get("coatLight"));
  sprites[this.ID].Set("coatDark", colors.Get("coatDark"));
  sprites[this.ID].Set("neckTie", colors.Get("neckTie"));
  sprites[this.ID].Set("underShirt", colors.Get("underShirt"));
  sprites[this.ID].Set("pants", colors.Get("pants"));
  sprites[this.ID].Set("pantsDark", colors.Get("pantsDark"));
  sprites[this.ID].Set("shoe", colors.Get("shoe"));
  sprites[this.ID].Set("shoeDark", colors.Get("shoeDark"));
  
  setupRecoloredView(this, walkView, colors);
  if(this.hasView(sitView))
  {
    setupRecoloredView(this, sitView, colors);
  }
  if(this.hasView(climbView))
  {
    setupRecoloredView(this, climbView, colors);
  }  
}

function recolorPart(this Character*, bodyParts partToChange, characterColors targetColor)
{
  Dictionary* charColorDict = this.getColorDictionary();
  Dictionary* sentDict;
  if(!charColorDict.Contains("error"))
  {
    sentDict = changeColorDictionary(charColorDict, partToChange, targetColor);
    this.recolor(sentDict);
  }
}

function recolorPartManualEntry(this Character*, bodyParts partToChange, int manuallyEnteredColor, int manuallyEnteredColorLight, int manuallyEnteredColorDark)
{
  Dictionary* charColorDict = this.getColorDictionary();
  
  if(manuallyEnteredColorDark == -1)
  {
    manuallyEnteredColorDark = manuallyEnteredColor;
  }
  
  if(manuallyEnteredColorLight == -1)
  {
    manuallyEnteredColorLight = manuallyEnteredColor;
  }
  
  if(!charColorDict.Contains("error"))
  {
    switch(partToChange)
    {
      case BP_hair:
        charColorDict.Set("hair", String.Format("%d", manuallyEnteredColor));
        if(charColorDict.Get("hair") == charColorDict.Get("mustache"))
        {
          charColorDict.Set("mustache", String.Format("%d", manuallyEnteredColor));
        }
        if(charColorDict.Get("hair") == charColorDict.Get("beard"))
        {
          charColorDict.Set("beard", String.Format("%d", manuallyEnteredColor));
        }
        break;
      case BP_skin:
        charColorDict.Set("skin", String.Format("%d", manuallyEnteredColor));
        charColorDict.Set("skinShadow", String.Format("%d", manuallyEnteredColorDark));
        break;
      case BP_coat:
        charColorDict.Set("coat", String.Format("%d", manuallyEnteredColor));
        charColorDict.Set("coatLight", String.Format("%d", manuallyEnteredColorLight));
        charColorDict.Set("coatDark", String.Format("%d", manuallyEnteredColorDark));
        break;
      case BP_necktie:
        charColorDict.Set("neckTie", String.Format("%d", manuallyEnteredColor));
        break;
      case BP_undershirt:
        charColorDict.Set("underShirt", String.Format("%d", manuallyEnteredColor));
        break;
      case BP_pants:
        charColorDict.Set("pants", String.Format("%d", manuallyEnteredColor));
        charColorDict.Set("pantsDark", String.Format("%d", manuallyEnteredColorDark));
        break;
      case BP_shoes:
        charColorDict.Set("shoe", String.Format("%d", manuallyEnteredColor));
        charColorDict.Set("shoeDark", String.Format("%d", manuallyEnteredColorDark));
        break;
    }
    this.recolor(charColorDict);
  }
}

function recolorRandomly(this Character*)
{
  this.recolor(createARandomSecondaryNPCDictionary());
}

//################################################################################# FACIAL HAIR ###########################################
function removeFacialHair(this Character*, bool removeMustache, bool removeBeard)
{
  Dictionary* charColorDict = this.getColorDictionary();
  
  if(!charColorDict.Contains("error"))
  {
    if(removeMustache)
    {
      charColorDict.Set("mustache", charColorDict.Get("skin"));
    }
    if(removeBeard)
    {
      charColorDict.Set("beard", charColorDict.Get("skin"));
    }
  
    this.recolor(charColorDict);
  }
}

function addFacialHair(this Character*, bool addMustache, bool addBeard, int manuallyEnteredColor)
{
  Dictionary* charColorDict = this.getColorDictionary();
  
  if(!charColorDict.Contains("error"))
  {
    if(addMustache)
    {
      charColorDict.Set("mustache", String.Format("%d", manuallyEnteredColor));
    }
    if(addBeard)
    {
      charColorDict.Set("beard", String.Format("%d", manuallyEnteredColor));
    }
  
    this.recolor(charColorDict);
  }
}

//################################################################## SECONDARY CHARACTER MANAGEMENT ####################################################
function setCharacterPropertyTypes(Dictionary* propertyTypes)
{
  String dictKeys[];
  String dictValues[];
  dictKeys = propertyTypes.GetKeysAsArray();
  dictValues = propertyTypes.GetValuesAsArray();
  int nbChars = Game.CharacterCount;
  secCharStartProperties = new Dictionary[nbChars];
  int i;
  templatePropertyType = Dictionary.Create(eNonSorted);
  
  for(i = 0 ; i < propertyTypes.ItemCount ; i++)
  {
    templatePropertyType.Set(dictKeys[i], dictValues[i]);
  }
  
  for(i = 0 ; i < nbChars ; i++)
  {
    secCharStartProperties[i] = Dictionary.Create(eNonSorted);
    secCharStartProperties[i].Set("recorded", "false");
  }
}

void recordBaseProperties(this Character*)
{
  String dictKeys[];
  dictKeys = templatePropertyType.GetKeysAsArray();
  String tempString;
  int tempInt;
  int i;
  
  for(i = 0 ; i < templatePropertyType.ItemCount ; i++)
  {
    if(templatePropertyType.Get(dictKeys[i]) == "String")
    {
      tempString = this.GetTextProperty(dictKeys[i]);
      secCharStartProperties[this.ID].Set(dictKeys[i], tempString);
    } else
    {
      tempInt = this.GetProperty(dictKeys[i]);
      secCharStartProperties[this.ID].Set(dictKeys[i], String.Format("%d", tempInt));
    }
  }
  secCharStartProperties[this.ID].Set("recorded", "true");
  secCharStartProperties[this.ID].Set("characterName", this.Name);
}

void resetProperties(this Character*)
{
  String dictKeys[];
  String dictValues[];
  int i;
  if(secCharStartProperties[this.ID].Get("recorded") == "true")
  {
    dictKeys = secCharStartProperties[this.ID].GetKeysAsArray();
    dictValues = secCharStartProperties[this.ID].GetValuesAsArray();
    for(i = 0 ; i < secCharStartProperties[this.ID].ItemCount ; i++)
    {
      if(templatePropertyType.Contains(dictKeys[i]))
      {
        if(templatePropertyType.Get(dictKeys[i]) == "String")
        {
          this.SetTextProperty(dictKeys[i], dictValues[i]);
        } else
        {
          this.SetProperty(dictKeys[i], dictValues[i].AsInt);
        }
      }
    }
    this.Name = secCharStartProperties[this.ID].Get("characterName");
  }
}

void makeSecCharAppearance(this Character*, int spawnHotspotIndex, int targetHotspotIndex, CharacterDirection secNPCFacing, bool randomizeAppearance)
{
  if(secCharStartProperties[this.ID].Get("recorded") == "false")
  {
    this.recordBaseProperties();
  }
  if(randomizeAppearance)
  {
    this.recolorRandomly();
    this.resetProperties();
  }
  this.ChangeRoom(player.Room, hotspot[spawnHotspotIndex].WalkToX, hotspot[spawnHotspotIndex].WalkToY, secNPCFacing);
  this.PlaceOnWalkableArea();
  this.Transparency = 0;
  if(targetHotspotIndex != -1)
  {
    this.Walk(hotspot[targetHotspotIndex].WalkToX, hotspot[targetHotspotIndex].WalkToY, eNoBlock, eWalkableAreas);
    characterIndextoManage.Add(String.Format("%d", this.ID));
  }
}

function removeRandomChars(bool allOfThemRightNow)
{
  int characterIndextoManageLength = characterIndextoManage.ItemCount;
  if(characterIndextoManageLength > 0)
  {
    String charactersToManage[] = characterIndextoManage.GetItemsAsArray();
  
    String thisCharacterIndexAsString;
    Character* thisCharacter;
    
    for(int i = 0 ; i < characterIndextoManageLength ; i++)
    {
      thisCharacterIndexAsString = charactersToManage[i];
      thisCharacter = character[thisCharacterIndexAsString.AsInt];
      if(!thisCharacter.Moving || allOfThemRightNow)
      {
        thisCharacter.Transparency = 100;
        characterIndextoManage.Remove(thisCharacterIndexAsString);
      }
    }
  }  
}

//################################################################### CHANGE CLOTHES GUI ################################################################
bool isClothesChangeGUISet()
{
  bool isTheGUISet = (!(clothesChangeGUI == null));
  bool isTheBtnSet = (!(clothesChangeCharVisual == null));
  return (isTheGUISet && isTheBtnSet);
}

int howManyColorsForThisClothingSet(bodyParts set)
{
  int i = 0;
  int counter = 0;
  for(i = 0 ; i < CLOTHES_PIECES_NB ; i++)
  {
    if(playerClothes[i].bodyPart == set && playerClothes[i].available)
    {
      counter++;
    }
  }
  return counter;
}

bool isThereAtLeastOneClothingInThisSet(bodyParts set)
{
  return (howManyColorsForThisClothingSet(set) > 0);
}

int howManyClothingSets()
{
  int counter = 0;
  if(clothesChangeAvailableBodyParts[BP_coat] && isThereAtLeastOneClothingInThisSet(BP_coat))
  {
    counter++;
  }
  if(clothesChangeAvailableBodyParts[BP_hair] && isThereAtLeastOneClothingInThisSet(BP_hair))
  {
    counter++;
  }
  if(clothesChangeAvailableBodyParts[BP_necktie] && isThereAtLeastOneClothingInThisSet(BP_necktie))
  {
    counter++;
  }
  if(clothesChangeAvailableBodyParts[BP_pants] && isThereAtLeastOneClothingInThisSet(BP_pants))
  {
    counter++;
  }
  if(clothesChangeAvailableBodyParts[BP_shoes] && isThereAtLeastOneClothingInThisSet(BP_shoes))
  {
    counter++;
  }
  if(clothesChangeAvailableBodyParts[BP_undershirt] && isThereAtLeastOneClothingInThisSet(BP_undershirt))
  {
    counter++;
  }
  return counter;
}

bool isThereMoreThanOneClothingSet()
{
  return (howManyClothingSets() > 0);
}

String makePlayerClothesDictKey(bodyParts set, String colorDesc)
{
  String dictKey = String.Format("%s_%s", bodyPartsToString(set), colorDesc);
  return dictKey;
}

int getClothesIndex(bodyParts set, String colorDesc)
{
  String dictKey = String.Format("%s_%s", bodyPartsToString(set), colorDesc);
  String indexS;
  if(playerClothesDictionary.Contains(dictKey))
  {
    indexS = playerClothesDictionary.Get(dictKey);
    return indexS.AsInt;
  } else
  {
    return -1;
  }
}

bool isClothesColorAvailable(bodyParts set, String colorDesc)
{
  return playerClothesDictionary.Contains(makePlayerClothesDictKey(set, colorDesc)); //(getClothesIndex(set, colorDesc) != -1);
}

function createPlayerClothing(bodyParts set, String colorDescription, int mainColor, int lightColor, int darkColor, bool available)
{
  int index = 0;
  int compareIndex;
  String dictIndexes[]; 
  
  if(!isClothesColorAvailable(set, colorDescription))
  {
    //Find available index
    if(playerClothesDictionary.ItemCount > 0)
    {
      dictIndexes = playerClothesDictionary.GetValuesAsArray();
      for(int i = 0 ; i < playerClothesDictionary.ItemCount ; i++)
      {
        compareIndex = dictIndexes[i].AsInt;
        if(compareIndex > index)
        {
          index = compareIndex;
        }
      }
    }
    index++;
    playerClothesDictionary.Set(makePlayerClothesDictKey(set, colorDescription), String.Format("%09d", index));
    playerClothes[index].available = available;
    playerClothes[index].bodyPart = set;
    playerClothes[index].colorDescription = colorDescription;
    playerClothes[index].darkColor = darkColor;
    playerClothes[index].lightColor = lightColor;
    playerClothes[index].mainColor = mainColor;
  } else
  {
    index = getClothesIndex(set, colorDescription);
    debugDisplay(String.Format("%s %s is already in the list", playerClothes[index].colorDescription, bodyPartsToString(playerClothes[index].bodyPart)));
  }
}

function updateGUICharacterColors(bodyParts set, String colorDesc)
{
  Dictionary* newLookDict;
  int index = getClothesIndex(set, colorDesc);
  
  clothesPartsIndexes[set] = index;
  int mainColor = playerClothes[index].mainColor;
  int lightColor = playerClothes[index].lightColor;
  int darkColor = playerClothes[index].darkColor;
  
  newLookDict = changeColorDictionary_manual(clothesChangeVisualColorDictionary, set, mainColor, lightColor, darkColor);
  clothesChangeCharVisualSprite = recolorSprite(clothesChangeVisualOriginalGraphicIndex, newLookDict);
  clothesChangeCharVisual.NormalGraphic = clothesChangeCharVisualSprite.Graphic;
}

String clothesChangeSetFirstColor(bodyParts set)
{
  int i = 0;
  
  if(clothesPartsIndexes[set] == -1)
  {    
    while(i < CLOTHES_PIECES_NB && !(playerClothes[i].bodyPart == set && playerClothes[i].available))
    {
      i++;
    }
    
    if(i < CLOTHES_PIECES_NB)
    {
      clothesChangeColor.Text = playerClothes[i].colorDescription;
      updateGUICharacterColors(playerClothes[i].bodyPart, playerClothes[i].colorDescription);
      return playerClothes[i].colorDescription;
    } else
    {
      return null;
    }
  } else
  {
    i = clothesPartsIndexes[set];
    clothesChangeColor.Text = playerClothes[i].colorDescription;
    updateGUICharacterColors(playerClothes[i].bodyPart, playerClothes[i].colorDescription);
    return playerClothes[i].colorDescription;
  }
}

bodyParts GUIStringToBP(String shownString)
{
  switch(shownString)
  {
    case "Coat":
      return BP_coat;
      break;
    case "Necktie":
      return BP_necktie;
      break;
    case "Shirt":
      return BP_undershirt;
      break;
    case "Pants":
      return BP_pants;
      break;
    case "Shoes":
      return BP_shoes;
      break;
    case "Hair":
      return BP_hair;
      break;
  }
}

function changeClothes_changeColor(bool nextORBack)
{
  String currentBodyPart = clothesChangeBodyPart.Text;
  String currentColor = clothesChangeColor.Text;
  bodyParts set = GUIStringToBP(currentBodyPart);
  int i;
  int firstItemIndex = -1;
  int currentItemIndex = -1;
  int potentialPrevItem = -1;
  int targetItemIndex = -1;
  int lastItemIndex = -1;
  
  for(i = 0 ; i < CLOTHES_PIECES_NB ; i++)
  {
    if(playerClothes[i].bodyPart == set && playerClothes[i].available && targetItemIndex == -1)
    {
      lastItemIndex = i;                        //for rollaround : back & current = first
      if(firstItemIndex == -1)  
      {
        firstItemIndex = i;                     //for rollaround : next & current = last
      }
      if(playerClothes[i].colorDescription == currentColor)
      {
        currentItemIndex = i;
        if(potentialPrevItem != -1 && !nextORBack)
        {
          targetItemIndex = potentialPrevItem;  //when Back && the current item is found, use the previous item
        }
      } else if(currentItemIndex != -1 && nextORBack)
      {
        targetItemIndex = i;                    //when Next && the current item is found,  use the following
      } else if(!nextORBack)
      {
        potentialPrevItem = i;                  //for Back,  when the current item is found
      }
    }
  }
  if(targetItemIndex == -1)                   //rollarounds
  {
    if(nextORBack && currentItemIndex == lastItemIndex)
    {
      targetItemIndex = firstItemIndex;
    } else if(!nextORBack && currentItemIndex == firstItemIndex)
    {
      targetItemIndex = lastItemIndex;
    }
  }
  
  clothesChangeColor.Text = playerClothes[targetItemIndex].colorDescription;//INDEX -1 :(
  updateGUICharacterColors(playerClothes[targetItemIndex].bodyPart, playerClothes[targetItemIndex].colorDescription);
}

function changeClothes_changeBodyPart(bool nextORBack)
{
  String currentBodyPart = clothesChangeBodyPart.Text;
  int cycleIndex;
  int step;
  bodyParts usedBP;
  String foundIt = "";
  
  switch(currentBodyPart)
  {
    case "Coat":
      cycleIndex = 0;
      break;
    case "Necktie":
      cycleIndex = 1;
      break;
    case "Shirt":
      cycleIndex = 2;
      break;
    case "Pants":
      cycleIndex = 3;
      break;
    case "Shoes":
      cycleIndex = 4;
      break;
    case "Hair":
      cycleIndex = 5;
      break;
  }
  
  if(nextORBack)
  {
    step = 1;
  } else
  {
    step = -1;
  }
  
  while (foundIt == "")
  {
    cycleIndex = cycleIndex + step;
    switch(cycleIndex)
    {
      case 0:
        usedBP = BP_coat;
        if(isThereAtLeastOneClothingInThisSet(usedBP) && clothesChangeAvailableBodyParts[usedBP])
        {
          foundIt = "Coat";
        }
        break;
      case 1:
        usedBP = BP_necktie;
        if(isThereAtLeastOneClothingInThisSet(usedBP) && clothesChangeAvailableBodyParts[usedBP])
        {
          foundIt = "Necktie";
        }
        break;
      case 2:
        usedBP = BP_undershirt;
        if(isThereAtLeastOneClothingInThisSet(usedBP) && clothesChangeAvailableBodyParts[usedBP])
        {
          foundIt = "Shirt";
        }
        break;
      case 3:
        usedBP = BP_pants;
        if(isThereAtLeastOneClothingInThisSet(usedBP) && clothesChangeAvailableBodyParts[usedBP])
        {
          foundIt = "Pants";
        }
        break;
      case 4:
        usedBP = BP_shoes;
        if(isThereAtLeastOneClothingInThisSet(usedBP) && clothesChangeAvailableBodyParts[usedBP])
        {
          foundIt = "Shoes";
        }
        break;
      case 5:
        usedBP = BP_hair;
        if(isThereAtLeastOneClothingInThisSet(usedBP) && clothesChangeAvailableBodyParts[usedBP])
        {
          foundIt = "Hair";
        }
        break;
      default:
        if(cycleIndex < 0)
        {
          cycleIndex = 6;
        } else if(cycleIndex > 5)
        {
          cycleIndex = -1;
        }
        break;
    }
  }
  
  clothesChangeBodyPart.Text = foundIt;
  String displayText = clothesChangeSetFirstColor(usedBP);
  clothesChangeColorArrow_back.Visible = (howManyColorsForThisClothingSet(usedBP) > 1);
  clothesChangeColorArrow_next.Visible = clothesChangeColorArrow_back.Visible;
}

String clothesChangeSetFirstBodyPart()
{
  if(isThereAtLeastOneClothingInThisSet(BP_coat) && clothesChangeAvailableBodyParts[BP_coat])
  {
    clothesChangeBodyPart.Text = "Coat";
    return bodyPartsToString(BP_coat);
  } else if(isThereAtLeastOneClothingInThisSet(BP_necktie) && clothesChangeAvailableBodyParts[BP_necktie])
  {
    clothesChangeBodyPart.Text = "Necktie";
    return bodyPartsToString(BP_necktie);
  } else if(isThereAtLeastOneClothingInThisSet(BP_undershirt) && clothesChangeAvailableBodyParts[BP_undershirt])
  {
    clothesChangeBodyPart.Text = "Shirt";
    return bodyPartsToString(BP_undershirt);
  } else if(isThereAtLeastOneClothingInThisSet(BP_pants) && clothesChangeAvailableBodyParts[BP_pants])
  {
    clothesChangeBodyPart.Text = "Pants";
    return bodyPartsToString(BP_pants);
  } else if(isThereAtLeastOneClothingInThisSet(BP_shoes) && clothesChangeAvailableBodyParts[BP_shoes])
  {
    clothesChangeBodyPart.Text = "Shoes";
    return bodyPartsToString(BP_shoes);
  } else if(isThereAtLeastOneClothingInThisSet(BP_hair) && clothesChangeAvailableBodyParts[BP_hair])
  {
    clothesChangeBodyPart.Text = "Hair";
    return bodyPartsToString(BP_hair);
  } else
  {
    return "null";
  }
}

int getWornClothesIndex(this Character*, bodyParts set)
{
  return clothesWornByPlayer[set];
}

int getClothingIndexByDescription(bodyParts set, String colorDescription)
{
  String dictKey = makePlayerClothesDictKey(set, colorDescription);
  if(playerClothesDictionary.Contains(dictKey))
  {
    String keyS = playerClothesDictionary.Get(dictKey);
    return keyS.AsInt;
  } else
  {
    return -1;
  }
}

bool isPlayerWearing(this Character*, bodyParts set, String colorDescription)
{
  return (clothesWornByPlayer[set] == getClothingIndexByDescription(set, colorDescription));
}

void dressUp(this Character*)
{
  player.recolor(clothesChangeVisualColorDictionary);
  gChangeClothes.Visible = false;
    
  bodyParts usedBP = BP_coat;
  if(clothesPartsIndexes[usedBP] != -1)
  {
    clothesWornByPlayer[usedBP] = clothesPartsIndexes[usedBP];
  }
  
  usedBP = BP_hair;
  if(clothesPartsIndexes[usedBP] != -1)
  {
    clothesWornByPlayer[usedBP] = clothesPartsIndexes[usedBP];
  }
  
  usedBP = BP_necktie;
  if(clothesPartsIndexes[usedBP] != -1)
  {
    clothesWornByPlayer[usedBP] = clothesPartsIndexes[usedBP];
  }
  
  usedBP = BP_pants;
  if(clothesPartsIndexes[usedBP] != -1)
  {
    clothesWornByPlayer[usedBP] = clothesPartsIndexes[usedBP];
  }
  
  usedBP = BP_shoes;
  if(clothesPartsIndexes[usedBP] != -1)
  {
    clothesWornByPlayer[usedBP] = clothesPartsIndexes[usedBP];
  }
  
  usedBP = BP_undershirt;
  if(clothesPartsIndexes[usedBP] != -1)
  {
    clothesWornByPlayer[usedBP] = clothesPartsIndexes[usedBP];
  }
  
  if(dressUpRoomCallIndex != -1)
  {
    CallRoomScript(dressUpRoomCallIndex);
  }
}

function wearThisClothing(this Character*, bodyParts bp, String colorDesc)
{
  clothesPartsIndexes[bp] = getClothesIndex(bp, colorDesc);
  this.dressUp();
}

bool setupChangeClothesGUI(bool coat, bool necktie, bool shirt, bool pants, bool shoe, bool hair)
{
  Dictionary* defaultCharColorDict = makeDefaultColorDictionary();
  clothesChangeVisualColorDictionary = player.getColorDictionary();
  bool success = true;
  String firstShownPart;
  String firstShownColor;
  int GUISprite;
  
  clothesChangeAvailableBodyParts[BP_coat] = coat;
  clothesChangeAvailableBodyParts[BP_hair] = hair;
  clothesChangeAvailableBodyParts[BP_necktie] = necktie;
  clothesChangeAvailableBodyParts[BP_pants] = pants;
  clothesChangeAvailableBodyParts[BP_shoes] = shoe;
  clothesChangeAvailableBodyParts[BP_undershirt] = shirt;
      
  if(isClothesChangeGUISet())
  {
    if(clothesChangeVisualOriginalGraphicIndex == -1)
    {
      clothesChangeVisualOriginalGraphicIndex = clothesChangeCharVisual.Graphic;
    }
    clothesChangeCharVisualSprite = recolorSprite(clothesChangeVisualOriginalGraphicIndex, clothesChangeVisualColorDictionary);
    clothesChangeCharVisual.NormalGraphic = clothesChangeCharVisualSprite.Graphic;
    firstShownPart = clothesChangeSetFirstBodyPart();
    if(firstShownPart == "null")
    {
      success = false;
    } else
    {
      firstShownColor = clothesChangeSetFirstColor(stringToBodyParts(firstShownPart));
      if(firstShownColor == "null")
      {
        success = false;
      } else
      {
        clothesChangeSetArrow_back.Visible = (howManyClothingSets() > 1);
        clothesChangeSetArrow_next.Visible = clothesChangeSetArrow_back.Visible;
        clothesChangeColorArrow_back.Visible = (howManyColorsForThisClothingSet(stringToBodyParts(firstShownPart)) > 1);
        clothesChangeColorArrow_next.Visible = clothesChangeColorArrow_back.Visible;
      }
    }    
  } else
  {
    success = false;
  }
}

function setClothesChangeGUIElements(GUI* clothesGUI, Button* charVisual, Label* bodyPartName, Label* colorName,  Button* set_back, Button* set_next, Button* color_back, Button* color_next)
{
  clothesChangeGUI = clothesGUI;
  clothesChangeCharVisual = charVisual;
  clothesChangeBodyPart = bodyPartName;
  clothesChangeColor = colorName; 
  clothesChangeSetArrow_back = set_back;
  clothesChangeSetArrow_next = set_next;
  clothesChangeColorArrow_back = color_back;
  clothesChangeColorArrow_next = color_next;
}

function open_changeClothes_gui(bool coat, bool necktie, bool shirt, bool pants, bool shoe, bool hair, int roomCallIndex)
{
  setupChangeClothesGUI(coat, necktie, shirt, pants, shoe, hair);
  clothesChangeGUI.Visible = true;
  dressUpRoomCallIndex = roomCallIndex;
}

//######################################################## GAME FUNCTIONS #################################################################

function repeatedly_execute()
{
  removeRandomChars(false);
}

// called when the game starts, before the first room is loaded
function game_start()
{
  int neededSlots = 1000 + (100 * Game.CharacterCount);
  recoloredDynamicSprites = new DynamicSprite[neededSlots];
  characterIndextoManage = Set.Create(eNonSorted);
  
  createSpriteDictionaries();
  playerClothesDictionary = Dictionary.Create(eNonSorted);
  
  clothesChangeAvailableBodyParts[BP_coat] = false;
  clothesChangeAvailableBodyParts[BP_hair] = false;
  clothesChangeAvailableBodyParts[BP_necktie] = false;
  clothesChangeAvailableBodyParts[BP_pants] = false;
  clothesChangeAvailableBodyParts[BP_shoes] = false;
  clothesChangeAvailableBodyParts[BP_skin] = false;
  clothesChangeAvailableBodyParts[BP_undershirt] = false;
  
  indexedColors = Dictionary.Create(eSorted);
  indexedColors.Set("25388", "hair");
  indexedColors.Set("27501", "mustache");
  indexedColors.Set("25452", "beard");
  indexedColors.Set("58607", "skin");
  indexedColors.Set("58444", "skinShadow");
  indexedColors.Set("512", "coat");
  indexedColors.Set("736", "coatLight");
  indexedColors.Set("256", "coatDark");
  indexedColors.Set("0", "neckTie");
  indexedColors.Set("65535", "underShirt");
  indexedColors.Set("4290", "pants");
  indexedColors.Set("32", "pantsDark");
  indexedColors.Set("20800", "shoe");
  indexedColors.Set("14528", "shoeDark");
  indexedColors.Set("2048", "eyes");  
  
  clothesPartsIndexes[BP_coat] = -1;
  clothesPartsIndexes[BP_hair] = -1;
  clothesPartsIndexes[BP_necktie] = -1;
  clothesPartsIndexes[BP_pants] = -1;
  clothesPartsIndexes[BP_shoes] = -1;
  clothesPartsIndexes[BP_skin] = -1;
  clothesPartsIndexes[BP_undershirt] = -1;
  
  clothesWornByPlayer[BP_coat] = -1;
  clothesWornByPlayer[BP_hair] = -1;
  clothesWornByPlayer[BP_necktie] = -1;
  clothesWornByPlayer[BP_pants] = -1;
  clothesWornByPlayer[BP_shoes] = -1;
  clothesWornByPlayer[BP_undershirt] = -1;
}