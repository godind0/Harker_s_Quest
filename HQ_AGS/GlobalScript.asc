/*TO IMPLEMENT
Look at drawers
GUI Z-ORDER : 0 = gameplay (gDark) ; 1 = semi-gameplay (Status Line) ; 2 = main guis ; 3 = precise gui
*/

// main global script file
#define NUMBEROFROOMS 13
#define PROPERTIESPERSECTOR 3
#define STANDARDTIMEINCREMENT 3
#define MAXNEGATIVE 10

#define SKIPCUTSCENES false
#define ACTIVATEDEBUGTOOL true

AudioChannel* bgMusic;
int playingMusic = 0;

Dictionary* verbDictionary;
Dictionary* verbDescriptionDictionary;
Dictionary* notes;
Set* afterNotebookThoughts;

Dictionary* addressBook_alternateNames;
Dictionary* addressBook_recipientDescription;
Dictionary* addressBook_message;

Dictionary* commerce_openingTime;
Dictionary* commerce_closingTime;
Dictionary* zone_CommerceType;

Dictionary* hawkinsLedgerCity;
Dictionary* hawkinsLedgerSector;
Dictionary* hawkinsLedgerPropertyAge;
String ledgerReadText;
Dictionary* hawkinsRequestCity;
Dictionary* hawkinsRequestSector;
Dictionary* hawkinsRequestPropertyAgeMin;
Dictionary* hawkinsRequestPropertyAgeMax;
Dictionary* hawkinsRequestMessage;
Set* hawkinsRequesters;
String proposedSeller;
String carfaxSeller;
int nbNegatives;

Dictionary* trainTimeTableSorter;
Dictionary* trainTimetableOrigin;//key is departure time
Dictionary* trainTimetableDestination;//key is departure time
Dictionary* trainTimetableArrivalTimes;//key is departure time
bool trainScheduleCreated = false;
bool trainDepartureAnnounced = false;
Set* availableTrainDestination;
String trainDepartureTime;
String trainInStation;

Set* availableDestinations;
Dictionary* roomForEachTravelDestinations;
Dictionary* x_TravelDestinations;
Dictionary* y_TravelDestinations;
Dictionary* city_TravelDestinations;
Dictionary* cabSellMsg_TravelDestinations;
int arrival_x[];
int arrival_y[];
int exit_x[];
int exit_y[];
CharacterDirection faceDirection[];
int exeterTravelDistanceMultiplier;
int londonTravelDistanceMultiplier;
String cabbyPropositions[];
zone currentZone;
commerce currentCommerceType;
zone wantedDestination;
zone realDestination;
bool travelling = false;

Dictionary* food_description;
Dictionary* food_notes;
Dictionary* food_spoilTime;
Dictionary* food_alternateNames;

Dictionary* books_description;
Dictionary* books_notes;

Dictionary* film_description;
Dictionary* film_notes;
Dictionary* photo_description;
Dictionary* photo_notes;
Dictionary* saleDossier_description;
Dictionary* saleDossier_notes;
Set* saleDossier_solution;

Dictionary* telegram_description;
Dictionary* telegram_notes;
Dictionary* hotelPackages;

Dictionary* legalPapers_description;
Dictionary* legalPapers_notes;
Set* legalPapers_solution;

Set* possibleClientNames;
float reachDistance = 40.0;
String lastCMD;
int nbFrameInSittingAnim;
int loopPerSecond;
int currentTimeIncrementPerLoop = STANDARDTIMEINCREMENT;
float timeUITransparency;
float timeUIFadeSpeed = 0.1;

bool debugTools;
bool skipAllCutscene;

int useIndex;
elementType useET;

int lastMealTime;

// set default game options
function set_default_options()
{
  System.Volume = 100;
  sldAudio.Value = System.Volume;
  sldSpeed.Value = 40;
  SetGameSpeed(40);
}

// initialize gPanel
function initialize_control_panel()
{
  set_default_options();
}

// hide the icon bar and show a GUI
function open_gui(GUI* gui_to_open)
{
  if (gui_to_open != gInventory)
  {
    lblOverHotspot.Visible = false;
  }

  //gIconbar.Visible = false;
  mouse.UseModeGraphic(eModePointer);
  gui_to_open.Visible = true;
}

// hide the GUI and show the icon bar
function close_gui(GUI* gui_to_close)
{
  gui_to_close.Visible = false;
  mouse.UseDefaultGraphic();
  lblOverHotspot.Visible = true;
  //gIconbar.Visible = true;
}

// hide a GUI, based on a GUI control
function close_owning_gui(GUIControl* control)
{
  close_gui(control.OwningGUI);
}

// hide a GUI directly from an OnClick event
function close_gui_onclick(GUIControl *control, MouseButton button)
{
  close_owning_gui(control);
}

// called when the game starts, before the first room is loaded
function game_start()
{
  // initialize gPanel controls
  initialize_control_panel();

  // set KeyboardMovement movement mode
  KeyboardMovement.Mode = eKeyboardMovementModeTapping;
  
  lastCMD = "";
  nbFrameInSittingAnim = 2;
  loopPerSecond = 40;
  
  player.Transparency = 100;
  mouse.Mode = eModePointer;
  
  currentTime = ((8 * 3600) + (0 * 60) + (0)) * loopPerSecond;
  timeUITransparency = 200.0;
  lblCurrentThought.Transparency = 100;
  
  //debug variables
  debugTools = ACTIVATEDEBUGTOOL;
  skipAllCutscene = SKIPCUTSCENES;
  
  //Beard code
  cHarkersBeard.Transparency = 100;
  cHarkersBeard.ChangeRoom(cHarker.Room, cHarker.x, cHarker.y, eDirectionDown);
  cHarkersBeard.FollowCharacter(cHarker, FOLLOW_EXACTLY);
  
  availableDestinations = Set.Create(eSorted);
  roomForEachTravelDestinations = Dictionary.Create(eSorted);
  x_TravelDestinations = Dictionary.Create(eSorted);
  y_TravelDestinations = Dictionary.Create(eSorted);
  city_TravelDestinations = Dictionary.Create(eSorted);
  cabSellMsg_TravelDestinations = Dictionary.Create(eSorted);
  exeterTravelDistanceMultiplier = 8;
  londonTravelDistanceMultiplier = 16;
  arrival_x = new int[NUMBEROFROOMS+1];
  arrival_y = new int[NUMBEROFROOMS+1];
  exit_x = new int[NUMBEROFROOMS+1];
  exit_y = new int[NUMBEROFROOMS+1];
  faceDirection = new CharacterDirection[NUMBEROFROOMS+1];
  
  int roomIndex;
  
  roomIndex = 1; //Jonathan's apartment 
  arrival_x[roomIndex] = 185;
  arrival_y[roomIndex] = 147;
  faceDirection[roomIndex] = eDirectionDown;
  exit_x[roomIndex] = 0;
  exit_y[roomIndex] = 0;
  
  roomIndex = 2; //Hawkins Office
  arrival_x[roomIndex] = 154;
  arrival_y[roomIndex] = 163;
  faceDirection[roomIndex] = eDirectionUp;
  exit_x[roomIndex] = 154;
  exit_y[roomIndex] = 163;
  
  roomIndex = 3; // Train station and café - Exeter
  arrival_x[roomIndex] = 345;
  arrival_y[roomIndex] = 185;
  faceDirection[roomIndex] = eDirectionDown;
  exit_x[roomIndex] = 0;
  exit_y[roomIndex] = 0;
  
  roomIndex = 4; // NA
  arrival_x[roomIndex] = 0;
  arrival_y[roomIndex] = 0;
  faceDirection[roomIndex] = eDirectionDown;
  exit_x[roomIndex] = 0;
  exit_y[roomIndex] = 0;
  
  roomIndex = 5; // Train station and cabby - London
  arrival_x[roomIndex] = 117;
  arrival_y[roomIndex] = 187;
  faceDirection[roomIndex] = eDirectionRight;
  exit_x[roomIndex] = 0;
  exit_y[roomIndex] = 0;
  
  roomIndex = 6;//Purfleet road
  arrival_x[roomIndex] = 171;
  arrival_y[roomIndex] = 183;
  faceDirection[roomIndex] = eDirectionDown;
  exit_x[roomIndex] = 0;
  exit_y[roomIndex] = 0;
  
  roomIndex = 8; // telegram
  arrival_x[roomIndex] = 56;
  arrival_y[roomIndex] = 147;
  faceDirection[roomIndex] = eDirectionDown;
  exit_x[roomIndex] = 57;
  exit_y[roomIndex] = 141;
  
  roomIndex = 9;//British museum _ collection
  arrival_x[roomIndex] = 200;
  arrival_y[roomIndex] = 167;
  faceDirection[roomIndex] = eDirectionDown;
  exit_x[roomIndex] = 200;
  exit_y[roomIndex] = 167;
  
  roomIndex = 10; // Law Society
  arrival_x[roomIndex] = 265;
  arrival_y[roomIndex] = 151;
  faceDirection[roomIndex] = eDirectionDown;
  exit_x[roomIndex] = 265;
  exit_y[roomIndex] = 151;
  
  hawkinsLedgerCity = Dictionary.Create(eSorted);
  hawkinsLedgerSector = Dictionary.Create(eSorted);
  hawkinsLedgerPropertyAge = Dictionary.Create(eSorted);
  ledgerReadText = "";
  hawkinsRequestCity = Dictionary.Create(eSorted);
  hawkinsRequestSector = Dictionary.Create(eSorted);
  hawkinsRequestPropertyAgeMin = Dictionary.Create(eSorted);
  hawkinsRequestPropertyAgeMax = Dictionary.Create(eSorted);
  hawkinsRequestMessage = Dictionary.Create(eSorted);
  hawkinsRequesters = Set.Create(eSorted);
  nbNegatives = 10;
    
  notes = Dictionary.Create(eNonSorted);
  afterNotebookThoughts = Set.Create(eNonSorted);
  notes.Set("How to use", "When something notable is thought or said, you will see an asterisk (*) at the end of the sentence. Write the 'Note' command to add it to your notebook.");
  notes.Set("Mina - tea", "Meet Mina at Station café for tea at 11AM.");
  
  addressBook_alternateNames = Dictionary.Create(eNonSorted);
  addressBook_recipientDescription = Dictionary.Create(eNonSorted);
  addressBook_message = Dictionary.Create(eNonSorted);
  
  commerce_openingTime = Dictionary.Create(eNonSorted);
  commerce_closingTime = Dictionary.Create(eNonSorted);
  zone_CommerceType = Dictionary.Create(eNonSorted);
  
  telegram_description = Dictionary.Create(eNonSorted);
  telegram_notes = Dictionary.Create(eNonSorted);
  hotelPackages = Dictionary.Create(eNonSorted);
  
  food_description = Dictionary.Create(eSorted);
  food_notes = Dictionary.Create(eSorted);
  food_spoilTime = Dictionary.Create(eSorted);
  food_alternateNames = Dictionary.Create(eSorted);
  
  books_description = Dictionary.Create(eSorted);
  books_notes = Dictionary.Create(eSorted);
  
  legalPapers_description = Dictionary.Create(eNonSorted);
  legalPapers_notes = Dictionary.Create(eNonSorted);
  legalPapers_solution = Set.Create(eNonSorted);
  legalPapers_solution.Add("Title page");
  legalPapers_solution.Add("Articles");
  legalPapers_solution.Add("Signature");
  
  photo_description = Dictionary.Create(eNonSorted);
  photo_notes = Dictionary.Create(eNonSorted);
  film_description = Dictionary.Create(eNonSorted);
  film_notes = Dictionary.Create(eNonSorted);
  saleDossier_description = Dictionary.Create(eNonSorted);
  saleDossier_notes = Dictionary.Create(eNonSorted);
  saleDossier_solution = Set.Create(eNonSorted);
  saleDossier_solution.Add("Title page");
  saleDossier_solution.Add("Conditions");
  saleDossier_solution.Add("Property deed");
  saleDossier_solution.Add("Carfax's Bedroom");
  saleDossier_solution.Add("Carfax's Dining");
  saleDossier_solution.Add("Carfax's Living");
  saleDossier_solution.Add("Carfax's Kitchen");
  saleDossier_solution.Add("Property survey");
  saleDossier_solution.Add("Sales and advertisement");
  saleDossier_solution.Add("Tenants and Leases");
  saleDossier_solution.Add("Labour book");
  
  possibleClientNames = Set.Create(eSorted, eCaseInsensitive);
  possibleClientNames.Add("Acland");
  possibleClientNames.Add("Adams");
  possibleClientNames.Add("Adamson");
  possibleClientNames.Add("Aitken");
  possibleClientNames.Add("Alderdice");
  possibleClientNames.Add("Alexander");
  possibleClientNames.Add("Amery");
  possibleClientNames.Add("Armstrong");
  possibleClientNames.Add("Asghar");
  possibleClientNames.Add("Asquith");
  possibleClientNames.Add("Astor");
  possibleClientNames.Add("Atkins");
  possibleClientNames.Add("Attlee");
  possibleClientNames.Add("Bagshaw");
  possibleClientNames.Add("Baker");
  possibleClientNames.Add("Baldwin");
  possibleClientNames.Add("Ball");
  possibleClientNames.Add("Bankes");
  possibleClientNames.Add("Baring");
  possibleClientNames.Add("Basse");
  possibleClientNames.Add("Bathurst");
  possibleClientNames.Add("Beaumont");
  possibleClientNames.Add("Beggse");
  possibleClientNames.Add("Beith");
  possibleClientNames.Add("Benn");
  possibleClientNames.Add("Benyon");
  possibleClientNames.Add("Beresford");
  possibleClientNames.Add("Bergers");
  possibleClientNames.Add("Bernal");
  possibleClientNames.Add("Bevan");
  possibleClientNames.Add("Billingham");
  possibleClientNames.Add("Bilson");
  possibleClientNames.Add("Blackburne");
  possibleClientNames.Add("Blake");
  possibleClientNames.Add("Blennerhassett");
  possibleClientNames.Add("Blomfield");
  possibleClientNames.Add("Bole");
  possibleClientNames.Add("Borwick");
  possibleClientNames.Add("Boswell");
  possibleClientNames.Add("Bottomley");
  possibleClientNames.Add("Bowater");
  possibleClientNames.Add("Bradshaw");
  possibleClientNames.Add("BrightsCash");
  possibleClientNames.Add("Bromley");
  possibleClientNames.Add("Brookes");
  possibleClientNames.Add("Brown");
  possibleClientNames.Add("Brunner");
  possibleClientNames.Add("Bull");
  possibleClientNames.Add("Burgon");
  possibleClientNames.Add("Butler");
  possibleClientNames.Add("Byers");
  possibleClientNames.Add("Calcraft");
  possibleClientNames.Add("Callaghan");
  possibleClientNames.Add("Calvert");
  possibleClientNames.Add("Carters");
  possibleClientNames.Add("Cavendish");
  possibleClientNames.Add("Cawley");
  possibleClientNames.Add("Cecil");
  possibleClientNames.Add("Chamberlain");
  possibleClientNames.Add("Chaplin");
  possibleClientNames.Add("Chapman");
  possibleClientNames.Add("Chichester");
  possibleClientNames.Add("Churchill");
  possibleClientNames.Add("Clifton");
  possibleClientNames.Add("Cooper");
  possibleClientNames.Add("Cope");
  possibleClientNames.Add("Courts");
  possibleClientNames.Add("Cox");
  possibleClientNames.Add("Cromwell");
  possibleClientNames.Add("Cryer");
  possibleClientNames.Add("Dashwood");
  possibleClientNames.Add("Davidson");
  possibleClientNames.Add("Davies");
  possibleClientNames.Add("Davis");
  possibleClientNames.Add("Dawson");
  possibleClientNames.Add("Dickinson");
  possibleClientNames.Add("Dodds");
  possibleClientNames.Add("Doran");
  possibleClientNames.Add("Drake");
  possibleClientNames.Add("Dunnes");
  possibleClientNames.Add("Dunwoody");
  possibleClientNames.Add("Durkan");
  possibleClientNames.Add("Eccles");
  possibleClientNames.Add("Edward");
  possibleClientNames.Add("Egerton");
  possibleClientNames.Add("Ewing");
  possibleClientNames.Add("Ferguson");
  possibleClientNames.Add("Fielden");
  possibleClientNames.Add("Finnie");
  possibleClientNames.Add("Foley");
  possibleClientNames.Add("Ford");
  possibleClientNames.Add("Foster");
  possibleClientNames.Add("Galbraith");
  possibleClientNames.Add("Garnier");
  possibleClientNames.Add("Gibson");
  possibleClientNames.Add("Gilmorehill");
  possibleClientNames.Add("Gladstone");
  possibleClientNames.Add("Golding");
  possibleClientNames.Add("Goldsmith");
  possibleClientNames.Add("Goschen");
  possibleClientNames.Add("Grady");
  possibleClientNames.Add("Grant");
  possibleClientNames.Add("Grattan");
  possibleClientNames.Add("Greene");
  possibleClientNames.Add("Greenwood");
  possibleClientNames.Add("Grenville");
  possibleClientNames.Add("Grey");
  possibleClientNames.Add("Grieves");
  possibleClientNames.Add("Guest");
  possibleClientNames.Add("Guinness");
  possibleClientNames.Add("Harcourt");
  possibleClientNames.Add("Hardies");
  possibleClientNames.Add("Harding");
  possibleClientNames.Add("Healy");
  possibleClientNames.Add("Heathcote");
  possibleClientNames.Add("Henderson");
  possibleClientNames.Add("Hodges");
  possibleClientNames.Add("Hodgson");
  possibleClientNames.Add("Hoggs");
  possibleClientNames.Add("Holmes");
  possibleClientNames.Add("Hooson");
  possibleClientNames.Add("Hope");
  possibleClientNames.Add("Hopkinson");
  possibleClientNames.Add("Howarth");
  possibleClientNames.Add("Howes");
  possibleClientNames.Add("Hoyle");
  possibleClientNames.Add("Hubbard");
  possibleClientNames.Add("Hurd");
  possibleClientNames.Add("Hussey");
  possibleClientNames.Add("Jackson");
  possibleClientNames.Add("Janner");
  possibleClientNames.Add("Jay");
  possibleClientNames.Add("Jeger");
  possibleClientNames.Add("Jenkins");
  possibleClientNames.Add("Johnson");
  possibleClientNames.Add("Jones");
  possibleClientNames.Add("Keen");
  possibleClientNames.Add("Kennedy");
  possibleClientNames.Add("Kinnock");
  possibleClientNames.Add("Knollys");
  possibleClientNames.Add("Lamb");
  possibleClientNames.Add("Lancaster");
  possibleClientNames.Add("Laws");
  possibleClientNames.Add("Lechmere");
  possibleClientNames.Add("Lee");
  possibleClientNames.Add("Lefroy");
  possibleClientNames.Add("Lemon");
  possibleClientNames.Add("Lever");
  possibleClientNames.Add("Lewis");
  possibleClientNames.Add("Lindsay");
  possibleClientNames.Add("Lloyd");
  possibleClientNames.Add("Long");
  possibleClientNames.Add("Lowther");
  possibleClientNames.Add("Luce");
  possibleClientNames.Add("Luttrell");
  possibleClientNames.Add("Lyon");
  possibleClientNames.Add("Maberley");
  possibleClientNames.Add("MacDonald");
  possibleClientNames.Add("MacKay");
  possibleClientNames.Add("Macmillan");
  possibleClientNames.Add("Mahon");
  possibleClientNames.Add("Mallalieus");
  possibleClientNames.Add("Mancroft");
  possibleClientNames.Add("Mandelson");
  possibleClientNames.Add("Martin");
  possibleClientNames.Add("Maude");
  possibleClientNames.Add("Maxton");
  possibleClientNames.Add("McAteer");
  possibleClientNames.Add("McAvan");
  possibleClientNames.Add("McCarthy");
  possibleClientNames.Add("McCrea");
  possibleClientNames.Add("McGuinnesse");
  possibleClientNames.Add("McMahon");
  possibleClientNames.Add("McNair-Wilson");
  possibleClientNames.Add("Meacher");
  possibleClientNames.Add("Miles");
  possibleClientNames.Add("Miliband");
  possibleClientNames.Add("Millar");
  possibleClientNames.Add("Mitchell");
  possibleClientNames.Add("Montague");
  possibleClientNames.Add("Morgan");
  possibleClientNames.Add("Morley");
  possibleClientNames.Add("Morris");
  possibleClientNames.Add("Morrison");
  possibleClientNames.Add("Mosley");
  possibleClientNames.Add("Mundell");
  possibleClientNames.Add("Nairns");
  possibleClientNames.Add("Nandy");
  possibleClientNames.Add("Norman");
  possibleClientNames.Add("Nott");
  possibleClientNames.Add("Nuttall");
  possibleClientNames.Add("O'Connell");
  possibleClientNames.Add("Ormsby");
  possibleClientNames.Add("Overend");
  possibleClientNames.Add("Paget");
  possibleClientNames.Add("Paisley");
  possibleClientNames.Add("Paton");
  possibleClientNames.Add("Pawsey");
  possibleClientNames.Add("Pease");
  possibleClientNames.Add("Peel");
  possibleClientNames.Add("Pelham");
  possibleClientNames.Add("Percival");
  possibleClientNames.Add("Perkin");
  possibleClientNames.Add("Perry");
  possibleClientNames.Add("Philipse");
  possibleClientNames.Add("Pitt");
  possibleClientNames.Add("Plunkett");
  possibleClientNames.Add("Poots");
  possibleClientNames.Add("Prentice");
  possibleClientNames.Add("Price");
  possibleClientNames.Add("Redmond");
  possibleClientNames.Add("Rees");
  possibleClientNames.Add("Ridley");
  possibleClientNames.Add("Robinson");
  possibleClientNames.Add("Roe");
  possibleClientNames.Add("Rothschild");
  possibleClientNames.Add("Ruddock");
  possibleClientNames.Add("Runciman");
  possibleClientNames.Add("Russell");
  possibleClientNames.Add("Sainsbury");
  possibleClientNames.Add("Samuel");
  possibleClientNames.Add("Samuelson");
  possibleClientNames.Add("Sandy");
  possibleClientNames.Add("Seymour");
  possibleClientNames.Add("Sharples");
  possibleClientNames.Add("Shelley");
  possibleClientNames.Add("Shinwell");
  possibleClientNames.Add("Silkin");
  possibleClientNames.Add("Sillars");
  possibleClientNames.Add("Sinclair");
  possibleClientNames.Add("Skinner");
  possibleClientNames.Add("Smith");
  possibleClientNames.Add("Spencer");
  possibleClientNames.Add("Spring");
  possibleClientNames.Add("Stanley");
  possibleClientNames.Add("Sturgeon");
  possibleClientNames.Add("Swinson");
  possibleClientNames.Add("Tennyson");
  possibleClientNames.Add("Todd");
  possibleClientNames.Add("Tyrwhitt");
  possibleClientNames.Add("Villiers");
  possibleClientNames.Add("Vivian");
  possibleClientNames.Add("Wakefield");
  possibleClientNames.Add("Walker");
  possibleClientNames.Add("Ward");
  possibleClientNames.Add("Watkin");
  possibleClientNames.Add("Watts");
  possibleClientNames.Add("Wheatley");
  possibleClientNames.Add("Wiggins");
  possibleClientNames.Add("Wigrams");
  possibleClientNames.Add("Williams");
  possibleClientNames.Add("Winterton");
  possibleClientNames.Add("Wintringham");
  possibleClientNames.Add("Wolfson");
  possibleClientNames.Add("Wood");  
  
  verbDictionary = Dictionary.Create(eNonSorted, eCaseInsensitive);
  verbDictionary.Set("look", "look");
  verbDictionary.Set("use", "use");
  verbDictionary.Set("photograph", "photograph");
  verbDictionary.Set("take picture", "photograph");
  verbDictionary.Set("take a picture", "photograph");
  verbDictionary.Set("take photo", "photograph");
  verbDictionary.Set("take a photo", "photograph");
  verbDictionary.Set("examine", "look");
  verbDictionary.Set("open", "open");
  verbDictionary.Set("close", "close");
  verbDictionary.Set("go to", "approach");
  verbDictionary.Set("approach", "approach");
  verbDictionary.Set("note", "note");
  verbDictionary.Set("talk", "talk");
  verbDictionary.Set("speak", "talk");
  verbDictionary.Set("take", "take");
  verbDictionary.Set("get", "take");
  verbDictionary.Set("pick up", "take");
  verbDictionary.Set("read", "read");
  verbDictionary.Set("sit", "sit");
  verbDictionary.Set("stand", "stand");
  verbDictionary.Set("organize", "organize");
  verbDictionary.Set("classify", "organize");
  verbDictionary.Set("eat", "eat");
  verbDictionary.Set("consume", "eat");
  
  verbDictionary.Set("debugadditem", "debugadditem");
  
  verbDescriptionDictionary = Dictionary.Create(eSorted, eCaseInsensitive);
  verbDescriptionDictionary.Set("look", "Look at something or someone in the room (or at one of your inventory items.[[EXAMPLE: Look carpet");
  verbDescriptionDictionary.Set("use", "Use an item from your inventory or an object in the room near you. Sometimes, you must specify on what or on whom you use the object.[[EXAMPLE 1: Use sink[[EXAMPLE 2: Use razor on myself");
  verbDescriptionDictionary.Set("photograph", "Take the picture of something.[Only usable when you have a camera.[[EXAMPLE: Photograph kitchen");
  //verbDescriptionDictionary.Set("give", "Give an intem from your inventory to someone else. You must specify to whom you wish to give the item.[[EXAMPLE: Give ring to Mina");
  verbDescriptionDictionary.Set("open", "Open an object near you or an item from your inventory.[[EXAMPLE: Open front door");
  verbDescriptionDictionary.Set("close", "Close an object near you or an item from your inventory.[[EXAMPLE: Close bedroom door");
  verbDescriptionDictionary.Set("*approach", "Have Jonathan walk over to something or someone.[[Only works if 'Show hints' is chosen from the option panel.[[EXAMPLE: Approach dining table");
  verbDescriptionDictionary.Set("note", "Have Jonathan write down his notable information.[Only works when Jonathan has a notebook[[EXAMPLE: Note");
  verbDescriptionDictionary.Set("talk", "Talk to someone in the room.[Sometimes, you need to be near someone to talk to them.[[EXAMPLE: Talk to Count");
  verbDescriptionDictionary.Set("take", "Pick up an object and place it in your inventory.[[EXAMPLE: Take razor");
  verbDescriptionDictionary.Set("read", "Read an item from your inventory.[Not all items can be read.[[EXAMPLE: Read ledger");
  verbDescriptionDictionary.Set("sit", "Have Jonathan sit down in a nearby chair or appropriate surface.[Jonathan will not sit on any surface.[[EXAMPLE: Sit on bench");
  verbDescriptionDictionary.Set("spot", "Have Jonathan point out objects, people and inventory items that contain a certain word in its name.[[EXAMPLE: Spot door");
  verbDescriptionDictionary.Set("stand", "Have Jonathan stand up.[[EXAMPLE: Stand up");
  verbDescriptionDictionary.Set("organize", "Have Jonathan organize items.[Only classifiable items can be organized.[[EXAMPLE: Organize legal papers");
  verbDescriptionDictionary.Set("eat", "Have Jonathan eat something.[Only food items can be eaten.[Pay attention to the freshness of food.[[EXAMPLE: Eat tea sandwich");
    
  int i;
  String myVerbs[] = verbDescriptionDictionary.GetKeysAsArray();
  
  for(i = 0; i < verbDescriptionDictionary.ItemCount; i++)
  {
    lbVerbs.AddItem(myVerbs[i]);
  }
  lblHelpVerbDesc.Text = verbDescriptionDictionary.Get(lbVerbs.Items[lbVerbs.TopItem]);
  
}

// Called when a dialog script line "run-script" is processed
function dialog_request(int param)
{
  switch(param)
  {
    default:
      break;
  }
  
}

function show_save_game_dialog()
{
  // get the list of save games
  lstSaveGamesList.FillSaveGameList();

  if (lstSaveGamesList.ItemCount > 0)
  {
    // if there is at least one, set the default text
    // to be the first game's name
    txtNewSaveName.Text = lstSaveGamesList.Items[0];
  }
  else
  {
    // no save games yet, so default to empty text
    txtNewSaveName.Text = "";
  }

  open_gui(gSaveGame);
}

function show_restore_game_dialog()
{
  lstRestoreGamesList.FillSaveGameList();
  open_gui(gRestoreGame);
}

//################## DEBUG DISPLAY FUNCTION ####################################

function debugDisplay(String message) // Display used for debug so we can turn them off safely for the release candidate
{
  if(debugTools){
    Display(message);
  }
}

//################## STRING CUSTOM FUNCTIONS ####################################

String keycodeToString(char typeCharacter) // returns the symbol associated with the code (e.g.: 65 => A)
{
  return String.Format("%c",  typeCharacter);
}

String etToString(elementType eT) // changes the element type enum (roomObject,  AllInventoryItem,  roomHotspot and allCharacters) to a String
{
  switch(eT)
  {
    case roomObjects:
      return "roomObjects";
      break;
    case roomHotspots:
      return "roomHotspots";
      break;
    case allCharacters:
      return "allCharacters";
      break;
    case allInventoryItems:
      return "allInventoryItems";
      break;
    default:
      //debugDisplay(String.Format("Fxn etToString received element type #%d, out of bounds.", eT));
      break;
  }
}

elementType stringToET(String eT) // changes the String to the element type enum spelled out (roomObject,  AllInventoryItem,  roomHotspot and allCharacters)
{
  switch(eT)
  {
    case "roomObjects":
      return roomObjects;
      break;
    case "roomHotspots":
      return roomHotspots;
      break;
    case "allCharacters":
      return allCharacters;
      break;
    case "allInventoryItems":
      return allInventoryItems;
      break;
    default:
      //debugDisplay(String.Format("Fxn stringToET received string %s, unknown.", eT));
      break;
  }
}

bool alphaOrder_isThisBeforeThat(String thisString, String thatString)
{
  Set* alphabetise = Set.Create(eSorted, eCaseInsensitive);
  alphabetise.Add(thisString);
  alphabetise.Add(thatString);
  String alphaArray[] = alphabetise.GetItemsAsArray();
  return (thisString == alphaArray[0]);
}

bool startsWithVowel(String word) // returns true if a String starts with a vowel (useful for distinction between the use of 'a' or 'an' as articles
{
  bool doesStartWithAVowel = false;
  if(word.StartsWith("A", eCaseInsensitive)){
    doesStartWithAVowel = true;
  } else if(word.StartsWith("E", eCaseInsensitive)){
    doesStartWithAVowel = true;
  } else if(word.StartsWith("I", eCaseInsensitive)){
    doesStartWithAVowel = true;
  } else if(word.StartsWith("O", eCaseInsensitive)){
    doesStartWithAVowel = true;
  } else if(word.StartsWith("U", eCaseInsensitive)){
    doesStartWithAVowel = true;
  } else if(word.StartsWith("Y", eCaseInsensitive)){
    doesStartWithAVowel = true;
  }
  return doesStartWithAVowel;
}

String removeOneStringInstance(String fullText, String stringToRemoveOnce) // basically the String.Replace function,  but only for the first occurrence (not all)
{
  int i;
  int finishAt = fullText.IndexOf(stringToRemoveOnce) + stringToRemoveOnce.Length;
  String finalReplacement = "";
  for(i = fullText.IndexOf(stringToRemoveOnce); i < finishAt; i++)
  {
    fullText = fullText.ReplaceCharAt(i, 95);
    finalReplacement = finalReplacement.Append("_");
  }
  fullText = fullText.Replace(finalReplacement, "", eCaseInsensitive);
  return fullText;
}

String[] split(String textToSplit, String separator) // Returns an array of string split by separators !! CAREFUL array[0] is the array's length,  not an item !!
{
  int i;
  String testString = textToSplit.Replace(separator, "", eCaseInsensitive);
  int nbStringItems = textToSplit.Length;
  nbStringItems = nbStringItems - testString.Length;
  
  String returnArray[] = new String[nbStringItems];
  returnArray[0] = String.Format("%d", nbStringItems);
  
  for(i = 1; i < nbStringItems; i++)
  {
    
    if(textToSplit.IndexOf(separator) != -1)
    {
      returnArray[i] = textToSplit.Substring(0, textToSplit.IndexOf(separator));
      textToSplit = removeOneStringInstance(textToSplit, returnArray[i].Append(separator));
    } else
    {
      returnArray[i] = textToSplit;
    }
  }
  
  return returnArray;
}

String cmdStartsWithUSEsynonym(String cmd) // Return on the the 'use synonyms' we chose (if found) or "Null" if not found
{
  Set* USEsynonyms = Set.Create();
  USEsynonyms.Add("use");
  USEsynonyms.Add("put");
  USEsynonyms.Add("insert");
  
  String synonymList[] = USEsynonyms.GetItemsAsArray();
  int i = USEsynonyms.ItemCount -1;
  String foundMatch = "Null";
  
  while(i >= 0 && foundMatch == "Null")
  {
    if(cmd.StartsWith(synonymList[i], eCaseInsensitive))
    {
      foundMatch = synonymList[i];
    } else {
      i--;
    }
  }
  
  return foundMatch;
}

String whichArticle(String listOfElementsMentionned, String newElementName) // retunrs the appropriate article for a list of things to list ('A'/'An', 'A second',  etc.)
{ 
  int counter = 1;
  while(listOfElementsMentionned.IndexOf(newElementName) != -1)
  {
    counter++;
    listOfElementsMentionned = removeOneStringInstance(listOfElementsMentionned, newElementName);
  }
  switch(counter)
  {
    case 0:
      if(startsWithVowel(newElementName))
      {
        return "An";
      } else
      {
        return "A";
      }
      break;
    case 1:
      if(startsWithVowel(newElementName))
      {
        return "An";
      } else
      {
        return "A";
      }
      break;
    case 2:
      return "A second";
      break;
    case 3:
      return "A third";
      break;
    case 4:
      return "A fourth";
      break;
    case 5:
      return "A fifth";
      break;
    default:
      return "Another";
      break;
  }
}


//################# INTERACTION AUTOMATION FUNCTIONS ###############################

//##### AUDIO #####
function musicFirstSetup(AudioClip* newMusic)
{
  bgMusic = newMusic.Play();
  bgMusic.Volume = 20;
  playingMusic = bgMusic.ID;
}

function musicInRoom(AudioClip* newMusic)
{
  if(bgMusic.ID != newMusic.ID)
  {
    if(bgMusic.IsPlaying)
    {
      bgMusic.Stop();
    }
    bgMusic = newMusic.Play();
    bgMusic.Volume = 20;
    playingMusic = bgMusic.ID;
  }
}

function playConfirm()
{
  AudioChannel* uiSounds = aConfirm.Play(eAudioPriorityLow, eOnce);
  uiSounds.Volume = 100;
}

function playSelect()
{
  AudioChannel* uiSounds = aSelect.Play(eAudioPriorityLow, eOnce);
  uiSounds.Volume = 100;
}

function playCancel()
{
  AudioChannel* uiSounds = aCancel.Play(eAudioPriorityLow, eOnce);
  uiSounds.Volume = 100;
}

//##### UTILITIES #####

function gameIsOver(String message)
{
  lblGameOver_how.Text = message;
  open_gui(gGameOver);
}

int getIndexOfElementUsed()
{
  return useIndex;
}

elementType getETOfElementUsed()
{
  return useET;
}

int getObjectMidX(Object* Obj) {
  DynamicSprite* tempSprite = DynamicSprite.CreateFromExistingSprite(Obj.Graphic);
  int returnInt = tempSprite.Width / 2;
  tempSprite.Delete();
  
  returnInt = returnInt + Obj.X;
  
  return returnInt;
}

float calculateDistanceFromCharacter(int targetX, int targetY,  Character* who) // Return a float of the distance (in px) between a character and a target
{
  float deltaX = IntToFloat(targetX) - IntToFloat(who.x);
  float deltaY = IntToFloat(targetY) - IntToFloat(who.y);
  return Maths.Sqrt(Maths.RaiseToPower(deltaX, 2.0)+ Maths.RaiseToPower(deltaY, 2.0));  
}

bool isCharacterCloseEnough(int targetX, int targetY, float maxDistance,  Character* who) // Returns a bool describing if a character's distance from a target is lower than the indicated max
{
  float dist = calculateDistanceFromCharacter(targetX, targetY, who);
  return dist < maxDistance;
}

bool isCharacterNearHotspot(Hotspot* HS, float maxDistance,  Character* who) // Is the character close to the passed hotspot
{
  return isCharacterCloseEnough(HS.WalkToX, HS.WalkToY, maxDistance,  who);  
}

bool isCharacterNearObject(Object* Obj, float maxDistance,  Character* who) // Is the character close to the passed object
{
  return isCharacterCloseEnough(getObjectMidX(Obj), Obj.Y, maxDistance,  who);  
}

bool isCharacterNearCharacter(Character* target, float maxDistance,  Character* who)  // Is the character close to the passed character
{
  return isCharacterCloseEnough(target.x, target.y, maxDistance,  who);  
}

bool isThisOpened(Object* Obj)
{
  bool returnBool = false;
  
  switch(Obj.GetProperty("Open_SpriteNumber"))
  {
    case -2:
      returnBool = !Obj.Visible;
      break;
    case -1:
      break;
    default:
      returnBool = (Obj.Visible && Obj.Graphic == Obj.GetProperty("Open_SpriteNumber"));
      break;
  }
  
  return returnBool;
}

String whatIsThis(elementType eT, int index) // return an element's name
{
  switch(eT)
  {
    case roomObjects:
      return object[index].Name;
      break;
    case roomHotspots:
      return hotspot[index].Name;
      break;
    case allCharacters:
      return character[index].Name;
      break;
    case allInventoryItems:
      return inventory[index].Name;
      break;
    default: 
      return "Unknown";
      break;
  }
}

String[] findClosestElement(String elementType_index[], float dist[], int arraysLength) // Returns the closest element from indexed arrays
{
  String closestElementType_index = elementType_index[0];
  float closestDist = dist[0];
  String returnArray[] = new String[2];
  
  int i; 
  for(i = 1; i < arraysLength; i++)
  {
    if(dist[i] < closestDist) 
    {
      closestElementType_index = elementType_index[i];
      closestDist = dist[i];
    }
  }
  
  returnArray[0] = closestElementType_index.Truncate(closestElementType_index.IndexOf("_"));
  closestElementType_index = closestElementType_index.Replace(returnArray[0], "", eCaseInsensitive);
  closestElementType_index = closestElementType_index.Replace("_", "", eCaseInsensitive);
  returnArray[1] = closestElementType_index;
  
  return returnArray;
}

String isInteractionOnElement(String cmd) // returns true if the command has both a 'use synonym' and a 'on' synonym (e.g.: USE razor ON Jonathan // INSERT files IN folder)
{
  Set* OnSynonyms = Set.Create(eSorted);
  OnSynonyms.Add(" in ");
  OnSynonyms.Add(" into ");
  OnSynonyms.Add(" onto ");
  OnSynonyms.Add(" on ");
  OnSynonyms.Add(" over ");
  OnSynonyms.Add(" with ");
  OnSynonyms.Add(" under ");
  OnSynonyms.Add(" to ");
  
  String OnSynonymsArray[] = OnSynonyms.GetItemsAsArray();
  int i = OnSynonyms.ItemCount - 1;
  String foundMatch = "Null";
  
  while(i >= 0 && foundMatch == "Null")
  {
    if(cmd.IndexOf(OnSynonymsArray[i]) != -1)
    {
      foundMatch = OnSynonymsArray[i];
    } else {
      i--;
    }
  }
  
  return foundMatch;
}

//##### SCORING #################################################
function giveScoreOnce(String tag, int scoreToGive)
{
  if(Game.DoOnceOnly(tag)){
    GiveScore(scoreToGive);
  }
}

//##### MEMORY MECHANIC #######################################

function memorize(String thought) {
  lblCurrentThought.Text = thought;
  timeUITransparency = 0.0;
}

String getMemorisedThought()
{
  if(lblCurrentThought.Transparency < 100)
  {
    return lblCurrentThought.Text;
  } else {
    return "...I forget";
  }
}


//##### TIME FUNCTIONS #####

String translateTimeToHHMMAM(int hour, int minutes, String AMPM)
{
  return String.Format("%d:%02d%s", hour, minutes, AMPM);
}

String translateMinutesToHHMMAM(int minutes)
{
  int hours = minutes/60;
  minutes = minutes - (hours * 60);
  String AMPM = "AM";
  if(hours >= 12)
  {
    AMPM = "PM";
    if(hours > 12)
    {
      hours = hours - 12;
    }
  }
  return translateTimeToHHMMAM(hours, minutes, AMPM);
}

int translateTimeToMinutes(String HHMMAM)
{
  int returnMinutes;
  String hour = HHMMAM.Truncate(HHMMAM.IndexOf(":"));
  
  int hour_int = hour.AsInt;
  //debugDisplay(String.Format("Hour found : %d", hour_int));
  if(HHMMAM.EndsWith("PM"))
  {
    hour_int = hour_int + 12;
  }
  returnMinutes = 60*(hour_int);
  //debugDisplay(String.Format("Now in minutes : %d", returnMinutes));
  
  String minutes = HHMMAM.Substring(HHMMAM.IndexOf(":") + 1, 2);
  
  returnMinutes = returnMinutes + minutes.AsInt;
  //debugDisplay(String.Format("Final total : %d", returnMinutes));
  
  return returnMinutes;
}

String whatTimeIsIt(bool showTimeInStatusLine)
{
  int timeInLoops = currentTime;
  String AmPm = "AM";
  
  int loopsPerDay = loopPerSecond * 60 * 60 * 24;
  int day = timeInLoops / loopsPerDay;
  timeInLoops = timeInLoops - (day * 60 * 60 * 24 * loopPerSecond);
  currentDay = day;
  
  int hour = timeInLoops / (loopPerSecond * 3600);
  timeInLoops = timeInLoops - (hour * 3600 * loopPerSecond);
  
  if(hour >= 12)
  {
    AmPm = "PM";
  }
  if(hour > 12)
  {
    hour = hour - 12;
  }
  
  int minutes = timeInLoops / (loopPerSecond * 60);
  
  if(showTimeInStatusLine)
  {
    memorize(String.Format("%d:%02d%s", hour, minutes, AmPm));
  }
  
  return translateTimeToHHMMAM(hour, minutes, AmPm);
}

int getCurrentHour()
{
  String currentHourS = whatTimeIsIt(false);
  
  currentHourS = currentHourS.Truncate(currentHourS.IndexOf(":"));
  
  return currentHourS.AsInt;
}

int getCurrentMinutes()
{
  String currentMinutesS = whatTimeIsIt(false);
  
  if(currentMinutesS.EndsWith("AM")) {
    currentMinutesS = currentMinutesS.Truncate(currentMinutesS.IndexOf("AM"));
  } else {
    currentMinutesS = currentMinutesS.Truncate(currentMinutesS.IndexOf("PM"));
  }
  currentMinutesS = currentMinutesS.Substring(currentMinutesS.IndexOf(":")+1, 2);
   
  return currentMinutesS.AsInt;
}

String getAMPM()
{
  String currentAMPM = whatTimeIsIt(false);
  if(currentAMPM.EndsWith("AM")){
    return "AM";
  } else {
    return "PM";
  }
}

bool isThisTimeWithinXminOfThisTime(String HHMMAM_test, String HHMMAM_max, int withinThisManyMinutes)
{
  int minutes_test = translateTimeToMinutes(HHMMAM_test);
  int minutes_max = translateTimeToMinutes(HHMMAM_max);
  if(minutes_max - minutes_test <= withinThisManyMinutes && minutes_max - minutes_test > 0)
  {
    return true;
  } else
  {
    return false;
  }
}

bool isThisTimeBeforeThisTime(String HHMMAM_1, String HHMMAM_2)
{
  int minutes_1 = translateTimeToMinutes(HHMMAM_1);
  int minutes_2 = translateTimeToMinutes(HHMMAM_2);
  //debugDisplay(String.Format("First : %d[Second: %d[Before? %d", minutes_1, minutes_2, minutes_1 < minutes_2)); 
  return minutes_1 < minutes_2;
}

bool isItBeforeThisTime(int hour, int minutes, int seconds, bool PM, int day)
{
  if(PM && hour != 12)
  {
    hour = hour + 12;
  }
  int maxLoops = ((((((day * 24) + hour) * 60) + minutes) * 60) + seconds) * loopPerSecond;
  int currentAllTimeLoop = currentTime + ((currentDay * 86400) * loopPerSecond);
  return currentAllTimeLoop <= maxLoops;
}

String addTimeToDescription(String textDescription)
{
  String returnText = String.Format("%s[It is %s", textDescription, whatTimeIsIt(true));
  return returnText;
}

function setCurrentTime(int hour, int minutes, int seconds, bool PM,  int day)
{
  if(PM && (hour != 12))
  {
    hour = hour + 12;
  }
  currentTime = ((hour * 3600) + (minutes * 60) + seconds) * loopPerSecond;
  currentDay = day;
}

function addTime(int hour, int minutes, int seconds, int day)
{
  int loopsToAdd = ((hour * 3600) + (minutes * 60) + seconds) * loopPerSecond;
  currentTime = currentTime + loopsToAdd;
}

function setTimeIncrementPerLoop(int newIncrement)
{
  currentTimeIncrementPerLoop = newIncrement;
}

function resetTimeIncrementPerLoop()
{
  currentTimeIncrementPerLoop = STANDARDTIMEINCREMENT;
}

function show_wait_GUI(String passtimeVerb)
{
  if(player.HasInventory(iWatch)){
    lblWaitUI.Text = String.Format("It is %s[How long should I wait?", whatTimeIsIt(false));
  } else {
    lblWaitUI.Text = String.Format("How long should I wait?");
  }
  passtimeVerb = passtimeVerb.LowerCase();
  lblWaitUI.Text = lblWaitUI.Text.Replace("wait", passtimeVerb);
  btnConfirmWait.Text = btnConfirmWait.Text.Replace("wait", passtimeVerb);
  String firstLetter = passtimeVerb.Truncate(1);
  firstLetter = firstLetter.UpperCase();
  passtimeVerb = firstLetter.Append(passtimeVerb.Substring(1, passtimeVerb.Length-1));
  btnToggleForUntil.Text = btnToggleForUntil.Text.Replace("wait", passtimeVerb);
  tbWaitAmount.Text = "15";
  open_gui(gWait);
}

//##### TRAIN TRAVELS ##################################################################
String cityAsString(city cityName)
{
  switch (cityName)
  {
    case Exeter:
      return "Exeter";
      break;
    case London:
      return "London";
      break;
    case Paris:
      return "Paris";
      break;
    case Munich:
      return "Munich";
      break;
    case Vienna:
      return "Vienna";
      break;
    case Budapest:
      return "Budapest";
      break;
    case Klausenburg:
      return "Klausenburg";
      break;
    case Bistritz:
      return "Bistritz";
      break;
    default:
      return "Null";
      break;
  }
}

function addTrainDeparture(city origin, city destination, int hour_O, int minute_O, String AMPM_O, int hour_D, int minute_D, String AMPM_D)
{
  String timeKey = translateTimeToHHMMAM(hour_O, minute_O, AMPM_O);
  String arrivalTime = translateTimeToHHMMAM(hour_D, minute_D, AMPM_D);
  
  trainTimeTableSorter.Set(String.Format("%09d", translateTimeToMinutes(timeKey)), timeKey);
  
  trainTimetableOrigin.Set(timeKey, cityAsString(origin));
  trainTimetableDestination.Set(timeKey, cityAsString(destination));
  
  trainTimetableArrivalTimes.Set(timeKey, arrivalTime);
}

function adjustTicketDescription(String departureTimeKey)
{
  String ticketDescription;
  if(isThisTimeBeforeThisTime(whatTimeIsIt(false), departureTimeKey))
  {
    ticketDescription = "TODAY";
  } else {
    ticketDescription = "TOMORROW";
  }
  ticketDescription = ticketDescription.Append("[");
  ticketDescription = ticketDescription.Append(trainTimetableOrigin.Get(departureTimeKey));
  ticketDescription = ticketDescription.Append("[");
  ticketDescription = ticketDescription.Append(departureTimeKey);
  ticketDescription = ticketDescription.Append("[");
  ticketDescription = ticketDescription.Append("[");
  ticketDescription = ticketDescription.Append(trainTimetableDestination.Get(departureTimeKey));
  ticketDescription = ticketDescription.Append("[");
  ticketDescription = ticketDescription.Append(trainTimetableArrivalTimes.Get(departureTimeKey));
  
  lblTrainTicketSchedule.Text = ticketDescription;
  lblTrainTicketSchedule.Text = ticketDescription;
}

String getTrainDepartureTime()
{
  return trainDepartureTime;
}

String getTrainArrivalTime(String departureTime)
{
  return trainTimetableArrivalTimes.Get(departureTime);
}

bool canPlayerBoardTrain(String ticketTime)
{
  return ticketTime == trainInStation;
}

String getTrainInStation()
{
  return trainInStation;
}

function show_trainTicket_GUI(city origin, city destination)
{
  String departureTimeKeys[];
  String tomorrowsTimes[];
  departureTimeKeys = trainTimeTableSorter.GetValuesAsArray();
  Set* tomorrow;
  tomorrow = Set.Create(eSorted);
  int i;
  
  lbTrainDepartures.Clear();
  
  lblTrainTicket_title.Text = String.Format("Train Timetable:[%s to %s", cityAsString(origin), cityAsString(destination));
  
  //debugDisplay(whatTimeIsIt(false));
  
  for(i = 0 ; i < trainTimetableOrigin.ItemCount ; i++)
  {
    if(trainTimetableOrigin.Get(departureTimeKeys[i]) == cityAsString(origin) && trainTimetableDestination.Get(departureTimeKeys[i]) == cityAsString(destination))
    {
      if(isThisTimeBeforeThisTime(whatTimeIsIt(false), departureTimeKeys[i]))
      {
        lbTrainDepartures.AddItem(departureTimeKeys[i]);
      } else {
        tomorrow.Add(departureTimeKeys[i]);
      }
    }    
  }
  
  tomorrowsTimes = tomorrow.GetItemsAsArray();
  for(i = 0 ; i < tomorrow.ItemCount ; i++)
  {
    lbTrainDepartures.AddItem(tomorrowsTimes[i]);
    //debugDisplay(String.Format("Tomorrow : %s", departureTimeKeys[i]));
  }
  
  lbTrainDepartures.SelectedIndex = 0;
  adjustTicketDescription(lbTrainDepartures.Items[lbTrainDepartures.SelectedIndex]);
  open_gui(gTrainTickets);
}

function createTrainTimetables()
{
  trainTimeTableSorter = Dictionary.Create(eSorted);
  trainTimetableOrigin = Dictionary.Create(eNonSorted);
  trainTimetableDestination = Dictionary.Create(eNonSorted);
  trainTimetableArrivalTimes = Dictionary.Create(eNonSorted);
  trainInStation = "Null";
  
  //Exeter to London
  addTrainDeparture(Exeter, London, 7, 45, "AM", 12, 1, "PM");
  addTrainDeparture(Exeter, London, 6, 50, "AM", 1, 20, "PM");
  addTrainDeparture(Exeter, London, 10, 25, "AM", 2, 33, "PM");
  addTrainDeparture(Exeter, London, 10, 35, "AM", 4, 43, "PM");
  addTrainDeparture(Exeter, London, 12, 45, "PM", 5, 00, "PM");
  addTrainDeparture(Exeter, London, 1, 11, "PM", 6, 26, "PM");
  addTrainDeparture(Exeter, London, 2, 10, "PM", 7, 52, "PM");
  addTrainDeparture(Exeter, London, 4, 15, "PM", 8, 16, "PM");
  addTrainDeparture(Exeter, London, 6, 00, "PM", 10, 15, "PM");
  
  trainScheduleCreated = true;
}

function isAnyTrainInStation(bool fadeItIn)
{
  int i = 0;
  String depTimes[];
  
  if(!trainScheduleCreated)
  {
    createTrainTimetables();
  }
  
  depTimes = trainTimetableOrigin.GetKeysAsArray();
  
  if(trainInStation != "Null")//There is a train in station
  {
    if(!trainDepartureAnnounced && isThisTimeWithinXminOfThisTime(whatTimeIsIt(false), trainInStation, 1) && object[10].Visible == true)
    {
      cExeterTrainOfficer.SayBackground("Steer clear of the tracks for the train's departure!");
      trainDepartureAnnounced = true;
    } else if(isThisTimeBeforeThisTime(trainInStation, whatTimeIsIt(false)))//Train should leave
    {
      if(fadeItIn)
      {
        if(Game.Camera.X < 100)
        {
          FadeOut(5);
        }
        object[10].Visible = false;
        if(Game.Camera.X < 100)
        {
          FadeIn(5);
        }
      } else
      {
        object[10].Visible = false;
      }
      trainInStation = "Null";
      trainDepartureAnnounced = false;
    }
  } else
  {
    while(i < trainTimetableOrigin.ItemCount)
    {
      if(isThisTimeWithinXminOfThisTime(whatTimeIsIt(false), depTimes[i], 25) && trainInStation == "Null")
      {
        if(fadeItIn)
        {
          player.FaceObject(object[10], eBlock);
          cExeterTrainOfficer.Say(String.Format("The %s train to London is arriving in station!", depTimes[i]));
          if(Game.Camera.X < 100)
          {
            FadeOut(5);
          }
          object[10].Visible = true;
          CallRoomScript(3);
          if(Game.Camera.X < 100)
          {
            FadeIn(5);
          }
          CallRoomScript(2);
        } else {
          object[10].Visible = true;
        }
        cExeterTrainOfficer.SayBackground("All passengers with tickets are required to board immediately");
        cExeterTrainOfficer.SayBackground("This is the one and only call for boarding");
        trainInStation = depTimes[i];
        i = trainTimetableOrigin.ItemCount;
      } else
      {
        i++;
      }      
    }
  }
}


//##### AUTOMATED ACTION FUNCTION ####################################################################################################################

//##### HAWKINS FILES ##################################################################
//Players need to get the requirements (city,  sector,  age), consult the map (city+sector), get the names, use ledger to get the drawer number,  get file by name, validate the age,  bring it back to Hawkins
String generateClientName ()
{
  String clientName;
  String possibleClientNamesArray[];
  possibleClientNamesArray = possibleClientNames.GetItemsAsArray();
  clientName = possibleClientNamesArray[Random(possibleClientNames.ItemCount - 1)];
  possibleClientNames.Remove(clientName);
  return clientName;
}

String createHawkinsPropertyFile (String clientName, String cityName, String sector, int age)
{
  if(clientName == "Random")
  {
    clientName = generateClientName();
  }
  
  hawkinsLedgerCity.Set(clientName, cityName);
  hawkinsLedgerSector.Set(clientName, sector);
  hawkinsLedgerPropertyAge.Set(clientName, String.Format("%d", age));
  
  return clientName;
}

function createHawkinsRequestFile (String clientName, String cityName, String sector, int ageMin,  int ageMax,  String clientMessage,  bool addToRequesters)
{
  if(clientName == "Random")
  {
    clientName = generateClientName();
  }
  
  if(clientMessage == "Auto")
  {
    clientMessage = String.Format("They want a property in %s's %s sector, aged between %d and %d years old", cityName, sector, ageMin, ageMax);
  }
  
  hawkinsRequestCity.Set(clientName, cityName);
  hawkinsRequestSector.Set(clientName, sector);
  hawkinsRequestPropertyAgeMin.Set(clientName, String.Format("%d", ageMin));
  hawkinsRequestPropertyAgeMax.Set(clientName, String.Format("%d", ageMax));
  hawkinsRequestMessage.Set(clientName, clientMessage);
  
  if(addToRequesters)
  {
    hawkinsRequesters.Add(clientName);
  }
}

String getClientListPerCitySector(String thisCity, String sector)
{
  int i;
  String clientFiles[];
  clientFiles = hawkinsLedgerCity.GetKeysAsArray();
  String returnString = "";
  for(i = 0 ; i < hawkinsLedgerCity.ItemCount ; i++)
  {
    if(hawkinsLedgerCity.Get(clientFiles[i]) == thisCity && hawkinsLedgerSector.Get(clientFiles[i]) == sector)
    {
      if(returnString == "")
      {
        returnString = clientFiles[i];
      } else {
        returnString = returnString.Append(String.Format(" , %s", clientFiles[i]));
      }
    }
  }
  return returnString;
}

String generateReadHawkinsFileString(String clientName)
{
  String propAge = hawkinsLedgerPropertyAge.Get(clientName);
  String returnString = String.Format("Name: %s", clientName);
  returnString = returnString.Append(String.Format("[City: %s", hawkinsLedgerCity.Get(clientName)));
  returnString = returnString.Append(String.Format("[Sector: %s", hawkinsLedgerSector.Get(clientName)));
  returnString = returnString.Append(String.Format("[Construction: %d (%s y.o.)", 1893 - (propAge.AsInt), propAge));
  return returnString;
}

String getPropertyRequestMessage(String clientName)
{
  return hawkinsRequestMessage.Get(clientName);
}

Set* getHawkinsSellerList()
{
  Set* sellerList;
  sellerList = Set.Create(eSorted);
  String clientNames[];
  clientNames = hawkinsLedgerCity.GetKeysAsArray();
  int i;
  for(i = 0 ; i < hawkinsLedgerCity.ItemCount ; i++)
  {
    sellerList.Add(clientNames[i]);
  }
  return sellerList;
}

String getPropertyRequesterName()
{
  String returnName;
  String clientNames[];
  clientNames = hawkinsRequesters.GetItemsAsArray();
  returnName = clientNames[Random(hawkinsRequesters.ItemCount - 1)];
  hawkinsRequesters.Remove(returnName);
  return returnName;
}

String capitalizeName(String theName)
{
  if(theName != "")
  {
    String firstLetter = theName.Truncate(1);
    firstLetter = firstLetter.UpperCase();
    theName = String.Format("%s%s", firstLetter, theName.Substring(1, theName.Length-1));
  }
  return theName;
}

String getProposedSeller()
{
  return proposedSeller;
}

bool validatePropertyProposition(String requesterName, String sellerName)
{
  bool validated = true;
  if(hawkinsLedgerCity.Contains(sellerName))
  {
    String propAge = hawkinsLedgerPropertyAge.Get(sellerName);
    String ageMin = hawkinsRequestPropertyAgeMax.Get(requesterName);
    String ageMax = hawkinsRequestPropertyAgeMin.Get(requesterName);
    if( hawkinsLedgerCity.Get(sellerName) != hawkinsRequestCity.Get(requesterName) ||
        hawkinsLedgerSector.Get(sellerName) != hawkinsRequestSector.Get(requesterName) ||
        propAge.AsInt <= ageMax.AsInt ||
        propAge.AsInt >= ageMin.AsInt)
    {
      validated = false;
    }
    sellerName = capitalizeName(sellerName);
    cHawkins.Say(String.Format("Oh yes, the %s's property!", sellerName));
  } else
  {
    sellerName = capitalizeName(sellerName);
    cHawkins.Say(String.Format("%s? I do not know this name. You made a mistake", sellerName));
    validated = false;
  }
  return validated;
}

function createMultipleHawkinsPropertyFile (String thisCity, String sector, int ageMin, int ageMax,  int nbFiles)
{
  int propAge;
  while(nbFiles > 0)
  {
    propAge = ageMin + Random((ageMax - ageMin - 1));
    createHawkinsPropertyFile("Random", thisCity, sector, propAge);
    nbFiles--;
  }
}

function createAllHawkinsFiles ()
{
  createHawkinsRequestFile("Random", "Exeter", "City center", 25, 75, "Auto", true);
  createHawkinsPropertyFile("Random", "Exeter", "City center", 37);
  createMultipleHawkinsPropertyFile("Exeter", "City center", 100, 500, PROPERTIESPERSECTOR - 1);
  
  createHawkinsRequestFile("Random", "Exeter", "North", 100, 200, "Auto", true);
  createHawkinsPropertyFile("Random", "Exeter", "North", 183);
  createMultipleHawkinsPropertyFile("Exeter", "North", 250, 600, PROPERTIESPERSECTOR - 1);
  
  createHawkinsRequestFile("Random", "Exeter", "West", 5, 25, "Auto", true);
  createHawkinsPropertyFile("Random", "Exeter", "West", 17);
  createMultipleHawkinsPropertyFile("Exeter", "West", 30, 200, PROPERTIESPERSECTOR - 1);
  
  createHawkinsRequestFile("Random", "Exeter", "South", 500, 850, "Auto", true);
  createHawkinsPropertyFile("Random", "Exeter", "South", 678);
  createMultipleHawkinsPropertyFile("Exeter", "South", 30, 400, PROPERTIESPERSECTOR - 1);
  
  createHawkinsRequestFile("Random", "Exeter", "East", 10, 40, "Auto", true);
  createHawkinsPropertyFile("Random", "Exeter", "East", 11);
  createMultipleHawkinsPropertyFile("Exeter", "East", 60, 400, PROPERTIESPERSECTOR - 1);
  
  createHawkinsRequestFile("Random", "London", "City center", 200, 300, "Auto", true);
  createHawkinsPropertyFile("Random", "London", "City center", 258);
  createMultipleHawkinsPropertyFile("London", "City center", 310, 750, PROPERTIESPERSECTOR - 1);
  
  createHawkinsRequestFile("Random", "London", "North", 100, 1000, "Auto", true);
  createHawkinsPropertyFile("Random", "London", "North", 852);
  createMultipleHawkinsPropertyFile("London", "North", 10, 80, PROPERTIESPERSECTOR - 1);
  
  createHawkinsRequestFile("Random", "London", "West", 20, 50, "Auto", true);
  createHawkinsPropertyFile("Random", "London", "West", 34);
  createMultipleHawkinsPropertyFile("London", "West", 90, 400, PROPERTIESPERSECTOR - 1);
  
  createHawkinsRequestFile("Random", "London", "South", 500, 850, "Auto", true);
  createHawkinsPropertyFile("Random", "London", "South", 678);
  createMultipleHawkinsPropertyFile("London", "South", 30, 400, PROPERTIESPERSECTOR - 1);
  
  createHawkinsRequestFile("Dracula", "London", "East", 500, 750, "This is a special one, recommanded by Robert Parton himself[Very old East London property, let's say over 500 years old", false);
  createHawkinsPropertyFile("Random", "London", "East", 698);
  createMultipleHawkinsPropertyFile("London", "East", 30, 400, PROPERTIESPERSECTOR - 1);  
}

function setLedgerReadText(String thisLedgerReadText)
{
  ledgerReadText = thisLedgerReadText;
}

String getLedgerReadText()
{
  return ledgerReadText;
}

String getCarfaxSeller()
{
  return carfaxSeller;
}

//##### TRAVEL DESTINATIONS ######################################################################################
String zoneAsString(zone thisZone) 
{
  switch(thisZone)
  {
    case JonathanApt:
      return "Jonathan's Apartment";
      break;
    case HawkinsOffices:
      return "Hawkins Esq. Office";
      break;
    case ExeterTrainStation:
      return "Exeter Train Station";
      break;
    case StationCafe:
      return "Station Café";
      break;
    case LondonTrainStation:
      return "London Train Station";
      break;
    case LondonHotel:
      return "Hotel The Hummums";
      break;
    case Purfleet:
      return "Purfleet";
      break;
    case TelegramOffice:
      return "Telegram Office";
      break;
    case BritishMuseum:
      return "British Museum";
      break;
    case PhotographyShop:
      return "Photography shop";
      break;
    case LawSocietyOffices:
      return "Law Society Offices";
      break;
    case StayHere:
      return "Stay here";
      break;
    default:
      return "Null";
      break;
  }
}

zone stringAsZone(String thisZone) 
{
  switch(thisZone)
  {
    case "Jonathan's Apartment":
      return JonathanApt;
      break;
    case "Hawkins Esq. Office":
      return HawkinsOffices;
      break;
    case "Exeter Train Station":
      return ExeterTrainStation;
      break;
    case "Station Café":
      return StationCafe;
      break;
    case "London Train Station":
      return LondonTrainStation;
      break;
    case "Hotel The Hummums":
      return LondonHotel;
      break;
    case "Purfleet":
      return Purfleet;
      break;
    case "Telegram Office":
      return TelegramOffice;
      break;
    case "British Museum":
      return BritishMuseum;
      break;
    case "Photography shop":
      return PhotographyShop;
      break;
    case "Law Society Offices":
      return LawSocietyOffices;
      break;
    case "Stay here":
      return StayHere;
      break;
    default:
      return StayHere;
      break;
  }
}

commerce stringAsCommerce(String thisCommerce)
{
  switch(thisCommerce)
  {
    case "HawkinsEsq":
      return HawkinsEsq;
      break;
    case "TrainStation":
      return TrainStation;
      break;
    case "LawSocietyBuilding":
      return LawSocietyBuilding;
      break;
    case "Museum":
      return Museum;
      break;
    case "Shop":
      return Shop;
      break;
    case "AlwaysOpened":
      return AlwaysOpened;
      break;
    default:
      debugDisplay(String.Format("Commerce not recognized"));
  }
}

String commerceAsString(commerce thisCommerce)
{
  switch(thisCommerce)
  {
    case HawkinsEsq:
      return "HawkinsEsq";
      break;
    case TrainStation:
      return "TrainStation";
      break;
    case LawSocietyBuilding:
      return "LawSocietyBuilding";
      break;
    case Museum:
      return "Museum";
      break;
    case Shop:
      return "Shop";
      break;
    case AlwaysOpened:
      return "AlwaysOpened";
      break;
    default:
      debugDisplay(String.Format("Commerce not recognized"));
  }
}

function setupTravelDestinations()
{
  String thisZone;
  
  thisZone = zoneAsString(JonathanApt);
  roomForEachTravelDestinations.Set(thisZone, "1");
  x_TravelDestinations.Set(thisZone, "6");
  y_TravelDestinations.Set(thisZone, "2");
  city_TravelDestinations.Set(thisZone, "Exeter");
  zone_CommerceType.Set(thisZone, commerceAsString(AlwaysOpened));
  
  thisZone = zoneAsString(HawkinsOffices);
  roomForEachTravelDestinations.Set(thisZone, "2");
  x_TravelDestinations.Set(thisZone, "3");
  y_TravelDestinations.Set(thisZone, "4");
  city_TravelDestinations.Set(thisZone, "Exeter");
  zone_CommerceType.Set(thisZone, commerceAsString(HawkinsEsq));
  
  thisZone = zoneAsString(ExeterTrainStation);
  roomForEachTravelDestinations.Set(thisZone, "3");
  x_TravelDestinations.Set(thisZone, "3");
  y_TravelDestinations.Set(thisZone, "1");
  city_TravelDestinations.Set(thisZone, "Exeter");
  zone_CommerceType.Set(thisZone, commerceAsString(TrainStation));
  
  thisZone = zoneAsString(StationCafe);
  roomForEachTravelDestinations.Set(thisZone, "3");
  x_TravelDestinations.Set(thisZone, "3");
  y_TravelDestinations.Set(thisZone, "1");
  city_TravelDestinations.Set(thisZone, "Exeter");
  zone_CommerceType.Set(thisZone, commerceAsString(TrainStation));
  
  thisZone = zoneAsString(LondonTrainStation);
  roomForEachTravelDestinations.Set(thisZone, "5");
  x_TravelDestinations.Set(thisZone, "6");
  y_TravelDestinations.Set(thisZone, "4");
  city_TravelDestinations.Set(thisZone, "London");
  cabSellMsg_TravelDestinations.Set(thisZone, "The Waterloo Train Station? State of the art transport wherever you wanna go!");
  zone_CommerceType.Set(thisZone, commerceAsString(TrainStation));
  
  thisZone = zoneAsString(LondonHotel);
  roomForEachTravelDestinations.Set(thisZone, "13");
  x_TravelDestinations.Set(thisZone, "6");
  y_TravelDestinations.Set(thisZone, "4");
  city_TravelDestinations.Set(thisZone, "London");
  cabSellMsg_TravelDestinations.Set(thisZone, "Ride to the Hummums in the Covent Garden? Get some shut eye and one of them baths for cheap!");
  zone_CommerceType.Set(thisZone, commerceAsString(AlwaysOpened));
  
  thisZone = zoneAsString(Purfleet);
  roomForEachTravelDestinations.Set(thisZone, "6");
  x_TravelDestinations.Set(thisZone, "11");
  y_TravelDestinations.Set(thisZone, "4");
  city_TravelDestinations.Set(thisZone, "London");
  cabSellMsg_TravelDestinations.Set(thisZone, "Purfleet? 'Tis a quaint little community to the East o'London");
  zone_CommerceType.Set(thisZone, commerceAsString(AlwaysOpened));
  
  thisZone = zoneAsString(TelegramOffice);
  roomForEachTravelDestinations.Set(thisZone, "8");
  x_TravelDestinations.Set(thisZone, "5");
  y_TravelDestinations.Set(thisZone, "3");
  city_TravelDestinations.Set(thisZone, "London");
  cabSellMsg_TravelDestinations.Set(thisZone, "My buddy James' telegram shop? He just clickety-clack that thing!");
  zone_CommerceType.Set(thisZone, commerceAsString(Shop));
  
  thisZone = zoneAsString(BritishMuseum);
  roomForEachTravelDestinations.Set(thisZone, "8");
  x_TravelDestinations.Set(thisZone, "5");
  y_TravelDestinations.Set(thisZone, "3");
  city_TravelDestinations.Set(thisZone, "London");
  cabSellMsg_TravelDestinations.Set(thisZone, "The British Museum? Lots of old neat stuff there");
  zone_CommerceType.Set(thisZone, commerceAsString(Museum));
  
  thisZone = zoneAsString(LawSocietyOffices);
  roomForEachTravelDestinations.Set(thisZone, "10");
  x_TravelDestinations.Set(thisZone, "6");
  y_TravelDestinations.Set(thisZone, "3");
  city_TravelDestinations.Set(thisZone, "London");
  cabSellMsg_TravelDestinations.Set(thisZone, "The Law Society office? You wearing a suit, people in suits like to go there");
  zone_CommerceType.Set(thisZone, commerceAsString(LawSocietyBuilding));
}

int travelDestinationTimeInMinutes(zone origin, zone destination)
{
  String tempString;
  if(destination == StayHere)
  {
    destination = origin;
  }
  
  tempString = x_TravelDestinations.Get(zoneAsString(origin));
  int x_origin = tempString.AsInt;
  
  tempString = y_TravelDestinations.Get(zoneAsString(origin));
  int y_origin = tempString.AsInt;
  
  tempString = x_TravelDestinations.Get(zoneAsString(destination));
  int x_dest = tempString.AsInt;
  
  tempString = y_TravelDestinations.Get(zoneAsString(destination));
  int y_dest = tempString.AsInt;
  
  float x_dist = IntToFloat(x_origin - x_dest);  
  float y_dist = IntToFloat(y_origin - y_dest);
  
  float dist = Maths.Sqrt(Maths.RaiseToPower(x_dist, 2.0) + Maths.RaiseToPower(y_dist, 2.0));
  
  bool inLondon;
  if(city_TravelDestinations.Get(zoneAsString(destination)) == "London")
  {
    inLondon = true;
  } else
  {
    inLondon = false;
  }
  
  if(inLondon)
  {
    return londonTravelDistanceMultiplier * FloatToInt(dist);
  } else
  {
    return exeterTravelDistanceMultiplier * FloatToInt(dist);
  }
}

function adjustTravelDestinations()
{
  String allDestination[];
  String currentCity = city_TravelDestinations.Get(zoneAsString(currentZone));
  
  allDestination = city_TravelDestinations.GetKeysAsArray();
  int i;
  
  for(i = 0 ; i < city_TravelDestinations.ItemCount ; i++)
  {
    if( city_TravelDestinations.Get(allDestination[i]) == currentCity &&
        availableDestinations.Contains(allDestination[i]) &&
        roomForEachTravelDestinations.Get(allDestination[i]) != String.Format("%d", player.Room))
    {
      dTravel.SetOptionState(stringAsZone(allDestination[i]), eOptionOn);
    } else
    {   
      dTravel.SetOptionState(stringAsZone(allDestination[i]), eOptionOff);
    }
  }
  dTravel.SetOptionState(StayHere, eOptionOn);
}

function addTravelDestination(zone thisZone)
{
  if(!availableDestinations.Contains(zoneAsString(thisZone)))
  {
    availableDestinations.Add(zoneAsString(thisZone));
  }
}

function removeTravelDestination(zone thisZone)
{
  if(availableDestinations.Contains(zoneAsString(thisZone)))
  {
    availableDestinations.Remove(zoneAsString(thisZone));
  }
}

bool playerHasTravelDestination(zone thisZone)
{
  return availableDestinations.Contains(zoneAsString(thisZone));
}

function setCurrentZone(zone thisZone)
{
  currentZone = thisZone;
}

zone getCurrentZone()
{ 
  return currentZone;
}

function changeArrival_X_Y(int roomIndex, int newX, int newY)
{
  arrival_x[roomIndex] = newX;
  arrival_y[roomIndex] = newY;
}

function sayListOfThings(String listOfThings[], Dictionary* dictOfThings, int numberOfThings, Character* talker)
{
  int i;
  
  for(i = 0 ; i < numberOfThings ; i++)
  {
      
    if(listOfThings[i] == "" || listOfThings[i] == null || !dictOfThings.Contains(listOfThings[i]))
    {
      debugDisplay(String.Format("Error processing %s in the 'sayListOfThings' function", listOfThings[i]));
    } else
    {
      talker.Say(dictOfThings.Get(listOfThings[i]));
    }
  }
}

function cabTellPropositions() 
{
  sayListOfThings(cabbyPropositions, cabSellMsg_TravelDestinations, 3, cCabby);
}

String getCabPropositionByIndex(int index)
{
  return cabbyPropositions[index];
}

function setThreeLondonCabRides(bool includePurfleet)
{
  String allPossibleDestination[];
  Set* proposedDestinations = Set.Create(eNonSorted);
  allPossibleDestination = city_TravelDestinations.GetKeysAsArray();
  int maxIndex = city_TravelDestinations.ItemCount - 1;
  int randomIndex;
  int numberOfRandomPropositions;
  if(includePurfleet)
  {
    numberOfRandomPropositions = 2;
  } else
  {
    numberOfRandomPropositions = 3;
  }
  
  while (proposedDestinations.ItemCount < numberOfRandomPropositions)
  {
    randomIndex = Random(maxIndex);
    if(city_TravelDestinations.Get(allPossibleDestination[randomIndex]) == "London" &&  // In London
       allPossibleDestination[randomIndex] != zoneAsString(currentZone) &&              // not current zone
       allPossibleDestination[randomIndex] != zoneAsString(Purfleet))                   // Not Purfleet,  see below
    {
      if(proposedDestinations.ItemCount > 0)
      {
        if(!proposedDestinations.Contains(allPossibleDestination[randomIndex]))           // Not already chosen
        {
          proposedDestinations.Add(allPossibleDestination[randomIndex]);
        }
      } else
      {
        proposedDestinations.Add(allPossibleDestination[randomIndex]);
      }
    }
  }
  
  if(includePurfleet)
  {
    proposedDestinations.Add(zoneAsString(Purfleet));
  }
  
  cabbyPropositions = proposedDestinations.GetItemsAsArray();
}



//##### NOTEBOOK ###################################################################################################################
String getNoteDescription(String key) // returns the description associated with the title for taken notes
{
  return notes.Get(key);
}

function takeNote() // adds a note in the notepad
{
  notes.Set(Notable_title, Notable_description);
  lbNoteTitles.AddItem(Notable_title);
  giveScoreOnce(Notable_description, Notable_score);
}

function makeNotable(String title, String description, int score) // overrides the last notable thing
{
  Notable_title = title;
  Notable_description = description;
  Notable_score = score;
}

function notableRead(String title, String description,  int score) // Displays something and make it notable (establish the added score if noted too)
{
  if(player.HasInventory(iNotebook))
  {
    makeNotable(title,  description,  score);
    Display(String.Format("%s*", description));
  } else {
    Display(description);
  }
}

function notableThought(String title, String description,  int score) // both make the player think something and make it notable (establish the added score if noted too)
{
  if(player.HasInventory(iNotebook))
  {
    makeNotable(title,  description,  score);
    player.Think(String.Format("%s*", description));
  } else {
    player.Think(description);
  }
}

function notableSay(Character* who, String title, String description,  int score) // both make a character say something and make it notable (establish the added score if noted too)
{
  if(player.HasInventory(iNotebook))
  {
    makeNotable(title,  description,  score);
    who.Say(String.Format("%s*", description));
  } else {
    who.Say(description);
  }
}

function closeNotebookThoughts()
{
  String thoughts[];
  int i;
  if(afterNotebookThoughts.ItemCount > 0)
  {
    thoughts = afterNotebookThoughts.GetItemsAsArray();
    for(i = 0 ; i < afterNotebookThoughts.ItemCount ; i++)
    {
      player.Think(thoughts[i]);
    }
    afterNotebookThoughts.Clear();
  }
}

function hasRead(String noteTitle)
{
  switch(noteTitle)
  {
    case "Mina - tea":
      if(Game.DoOnceOnly("Mina's tea")){
        GiveScore(1);
        if(isItBeforeThisTime(11, 0, 0, false, 1)){
          afterNotebookThoughts.Add("Mina and I have a tea rendezvous at 11 at the Station Café");
        } else
        {
          afterNotebookThoughts.Add("Oh no! I missed my tea rendezvous with Mina!");
        }
        addTravelDestination(StationCafe);
      }
      break;
    default:
      break;
  }
}

//##### INTERACTION FUNCTIONS #####

function sit(elementType eT, int index, Character* who, int sittingView, bool alreadySat) // make the character sit on an appropriately setup element
{
  String redir;
  
  switch(eT)
  {
    case roomObjects:
      if(who == player) {
        redir = object[index].GetTextProperty("sit_Direction");
        if(redir.StartsWith("redir", eCaseInsensitive))
        {
          redir = redir.Replace("redir", "", eCaseInsensitive);
          index = redir.AsInt;
        }
      }
      if(object[index].GetTextProperty("sit_Direction") == "Null")
      {
        who.Think("I cannot sit on this.");        
      } else if(!isCharacterNearObject(object[index], reachDistance, who))
      {
        who.Think(String.Format("I cannot reach the %s from here", object[index].Name.LowerCase()));
      } else
      {
        who.Walk(object[index].X + object[index].GetProperty("sit_deltaX"), object[index].Y + object[index].GetProperty("sit_deltaY"), eBlock, eWalkableAreas);
        who.Move(object[index].X + object[index].GetProperty("sit_deltaX"), object[index].Y + object[index].GetProperty("sit_deltaY"), eBlock, eAnywhere);
        who.LockView(sittingView, eStopMoving);
        if(who == player) {
          cHarkersBeard.LockView(6, eKeepMoving);
        }
        who.SetProperty("sitting", index);
        
        if(!alreadySat)
        {
          switch(object[index].GetTextProperty("sit_Direction"))
          {
            case "down":
              who.Animate(0, 6, eOnce, eNoBlock, eForwards);
              break;
            case "left":
              who.Animate(1, 6, eOnce, eNoBlock, eForwards);
              break;
            case "right":
              who.Animate(2, 6, eOnce, eNoBlock, eForwards);
              break;
            case "up":
              who.Animate(3, 6, eOnce, eNoBlock, eForwards);
              break;
            default:
              break;
          }
          if(who == player)
          {
            switch(object[index].GetTextProperty("sit_Direction"))
            {
              case "down":
                cHarkersBeard.Animate(0, 6, eOnce, eBlock, eForwards);
                break;
              case "left":
                cHarkersBeard.Animate(1, 6, eOnce, eBlock, eForwards);
                break;
              case "right":
                cHarkersBeard.Animate(2, 6, eOnce, eBlock, eForwards);
                break;
              case "down":
                cHarkersBeard.Animate(3, 6, eOnce, eBlock, eForwards);
                break;
              default:
                break;
            }
          }
        } else {
          who.Frame = nbFrameInSittingAnim;
        }
        if(who == player)
        {
          mouse.Mode = eModePointer;
          KeyboardMovement.Mode = eKeyboardMovementModeNone;
        }
      }
      break;
    default:
      break;
  }
}

function standUp(Character* who,  int walkingView) // the player stands up
{
  if(who.GetProperty("sitting") > -1)
  {
    who.Animate(player.Loop, 6, eOnce, eNoBlock,  eBackwards);
    if(who == player)
    {
      cHarkersBeard.Animate(player.Loop, 6, eOnce, eBlock, eBackwards);
    }
    who.LockView(walkingView, eKeepMoving);
    if(who == player)
    {
      cHarkersBeard.LockView(5, eKeepMoving);
    }
    who.PlaceOnWalkableArea();
    who.SetProperty("sitting", -1);
    if(who == player)
    {
      mouse.Mode = eModeWalkto;
      KeyboardMovement.Mode = eKeyboardMovementModeTapping;
    }
  } else {
    who.Think("I am not sitting");
  }
}

//##### PARSE COMMAND REACTIONS FUNCTIONS #####
bool sitHighjack()
{
  bool returnBool = false;
  if(useIndex != -1)
  {
      
    switch (useET)
    {
      case roomObjects:
        if(object[useIndex].GetTextProperty("sit_Direction") != "Null")
        {
          returnBool = true;
          sit(roomObjects, useIndex, player, 2, false);
          useIndex = -1;
        }
        break;
      case roomHotspots:
        if(hotspot[useIndex].GetTextProperty("sit_Direction") != "Null")
        {
          returnBool = true;
          sit(roomHotspots, useIndex, player, 2, false);
          useIndex = -1;
        }
        break;
      default:
        break;
    }
  }
  return returnBool;
}

function unhandled_event(int what, int type) // called when a runInteraction is called on something without an appropriate event handler
{
  switch(what)
  {
    case 2: // room object
      switch(type)
      {
        case 1: // use/interact with object
          if(!sitHighjack())
          {
            player.Think("I am not sure what to use this for");
          }
          break;
        case 3: // use inventory item on object
          break;
        default:
          break;
      }
      break;
    case 1: // hotspot
      switch(type)
      {
        case 2: // use/interact with hotspot
          if(!sitHighjack())
          {
            player.Think("I am not sure what to use this for");
          }
          break;
        case 3: // use inventory item on hotspot
          break;
        default:
          break;
      }
      break;
    case 3: // character
      switch(type)
      {
        case 1: // use/interact character
          player.Think("I am not sure what to use them for");
          break;
        case 3: // use inventory item on character
          break;
        default:
          break;
      }
      break;
    case 5: // inventory item
      switch(type)
      {
        case 1: // use/interact with inventory item
          player.Think("I am not sure what to use this for");
          break;
        case 3: // use inventory item on inventory item
          break;
        default:
          break;
      }
      break;
    case 4: // nothing
      switch(type)
      {
        case 2: // use/interact with nothing
          player.Think("I am not sure what to use");
          break;
        case 3: // use inventory item on nothing
          break;
        default:
          break;
      }
      break;
    default:
      break;
  }
}

int findRoomObjectIndexByName(String objectName) // returns the object index of an object named
{
  int i = Room.ObjectCount - 1;
  int foundMatch = -1;
  
  while(i >= 0 && foundMatch == -1)
  {
    if(object[i].Name.LowerCase() == objectName.LowerCase())
    {
      foundMatch = i;
    } else {
      i--;
    }
  }
  
  return foundMatch;
}

int findInvItemIndexByName(String itemName)
{
  int nbInventoryItems = Game.InventoryItemCount;//don't forget the index start at one
  int i = 0;
  int returnIndex = -1;
  bool foundit = false;
  while(i < nbInventoryItems && !foundit)
  {
    i++;
    if(inventory[i].Name == itemName) {
      returnIndex = i;
      foundit = true;
    }
  }
  return returnIndex;
}

String[] findElementIndexByName(String cmd) // returns a String array with array[0] being the index and array[1] being the element type,  both as Strings!!!
{
  int i;
  int y;
  String testedStrings[];
  String allPossibleNames;
  String finalIndex;
  String finalElementType;
  bool foundMatch;
  float distanceFromPlayer;
  String tempArray[];
  float tempArrayF[];
  String returnArray[] = new String[2];
  
  int nbObjects = Room.ObjectCount;
  int nbHotpots = 50;
  int nbCharacters = Game.CharacterCount;
  int nbInventoryItems = Game.InventoryItemCount;//don't forget the index start at one
  Dictionary* correspondingRoomElements = Dictionary.Create(eSorted, eCaseInsensitive);
  
  //OBJECTS
  for(i = 0; i < (nbObjects); i++)
  {
    allPossibleNames = object[i].Name.Append(", ");
    if(object[i].GetTextProperty("alternateNames") != "")
    {
      allPossibleNames = allPossibleNames.Append(object[i].GetTextProperty("alternateNames"));
      allPossibleNames = allPossibleNames.Append(", ");
    }
    //debugDisplay(allPossibleNames);
    testedStrings = split(allPossibleNames, ", ");
    int testedStringsLength = testedStrings[0].AsInt;
    y = 1;
    foundMatch = false;
    while(y < testedStringsLength && !foundMatch)
    {
      if(object[i].Name != "" && testedStrings[y] != "" && cmd.IndexOf(testedStrings[y]) != -1)
      {
        if(object[i].Visible || object[i].GetProperty("InteractableWhenInvisible"))
        {
          foundMatch = true;
          distanceFromPlayer = calculateDistanceFromCharacter(getObjectMidX(object[i]), object[i].Y, player);
          correspondingRoomElements.Set(String.Format("%d_%s", i, etToString(roomObjects)), String.Format("%d", FloatToInt(distanceFromPlayer)));
        } else {
          y++;
        }
      } else {
        y++;
      }
    }
  }
  
  //HOTSPOTS
  for(i = 0; i < (nbHotpots); i++)
  {
    allPossibleNames = hotspot[i].Name.Append(", ");
    allPossibleNames = allPossibleNames.Append(hotspot[i].GetTextProperty("alternateNames"));
    testedStrings = split(allPossibleNames, ", ");
    int testedStringsLength = testedStrings[0].AsInt;
    y = 1;
    foundMatch = false;
    while(y < testedStringsLength && !foundMatch)
    {
      if(hotspot[i].Name != "" && cmd.IndexOf(testedStrings[y]) != -1)
      {
        foundMatch = true;
        distanceFromPlayer = calculateDistanceFromCharacter(hotspot[i].WalkToX, hotspot[i].WalkToY, player);
        correspondingRoomElements.Set(String.Format("%d_%s", i, etToString(roomHotspots)), String.Format("%d", FloatToInt(distanceFromPlayer)));
      } else {
        y++;
      }
    }
  }
  
  //CHARACTERS
  for(i = 0; i < (nbCharacters); i++)
  {
    allPossibleNames = character[i].Name.Append(", ");
    allPossibleNames = allPossibleNames.Append(character[i].GetTextProperty("alternateNames"));
    testedStrings = split(allPossibleNames, ", ");
    int testedStringsLength = testedStrings[0].AsInt;
    y = 1;
    foundMatch = false;
    while(y < testedStringsLength && !foundMatch)
    {
      if(character[i].Room == player.Room && character[i].Name != "" && cmd.IndexOf(testedStrings[y]) != -1)
      {
        foundMatch = true;
        distanceFromPlayer = calculateDistanceFromCharacter(character[i].x, character[i].y,  player);
        correspondingRoomElements.Set(String.Format("%d_%s", i, etToString(allCharacters)), String.Format("%d", FloatToInt(distanceFromPlayer)));
      } else {
        y++;
      }
    }
  }
  
  //INVENTORY ITEMS
  for(i = 1; i <= (nbInventoryItems); i++)//inventory item index start at 1
  {
    allPossibleNames = inventory[i].Name.Append(", ");
    allPossibleNames = allPossibleNames.Append(inventory[i].GetTextProperty("alternateNames"));
    testedStrings = split(allPossibleNames, ", ");
    int testedStringsLength = testedStrings[0].AsInt;
    y = 1;
    foundMatch = false;
    
    while(y < testedStringsLength && !foundMatch)
    {
      if(player.HasInventory(inventory[i]) && inventory[i].Name != "" && cmd.IndexOf(testedStrings[y]) != -1)
      {
        foundMatch = true;
        if(cmd.IndexOf(" my ") != -1)
        {
          distanceFromPlayer = 0.0;
        } else {
          distanceFromPlayer = 400.0;
        }
        correspondingRoomElements.Set(String.Format("%d_%s", i, etToString(allInventoryItems)), String.Format("%d", FloatToInt(distanceFromPlayer)));
      } else {
        y++;
      }
    }
  }
    
  switch(correspondingRoomElements.ItemCount)
  {
    case 0:
      returnArray[0] = "-1";
      returnArray[1] = "Null";
      break;
    case 1:
      tempArray = correspondingRoomElements.GetKeysAsArray();
      finalIndex = tempArray[0].Truncate(tempArray[0].IndexOf("_"));
      finalElementType = tempArray[0].Replace(finalIndex, "", eCaseInsensitive);
      finalElementType = finalElementType.Replace("_", "", eCaseInsensitive);
      returnArray[0] = finalIndex;
      returnArray[1] = finalElementType;
      break;
    default:
      tempArray = correspondingRoomElements.GetValuesAsArray();
      tempArrayF = new float[correspondingRoomElements.ItemCount];
      for(i = 0; i < correspondingRoomElements.ItemCount; i++)
      {
        tempArrayF[i] = tempArray[i].AsFloat;
      }
      tempArray = correspondingRoomElements.GetKeysAsArray();
      returnArray = findClosestElement(tempArray, tempArrayF, correspondingRoomElements.ItemCount);
      break;
  }  
  
  return returnArray;
}

String findVerbInDictionary(String cmd) // finds the verb in the verbDictionary
{
  int i;
  int stringPosition = -1;
  String verbs[] = verbDictionary.GetKeysAsArray();
  Set* foundVerbs = Set.Create(eSorted);
  String returnVerb;
   
  for(i = 0 ; i < verbDictionary.ItemCount ; i++){
    stringPosition = cmd.IndexOf(String.Format("%s ", verbs[i]));
    if(stringPosition != -1) {
      foundVerbs.Add(verbs[i]);
    }
  }
  
  if(foundVerbs.ItemCount == 0) 
  {
    return "Null";
  } else 
  {
    verbs = foundVerbs.GetItemsAsArray();
    returnVerb = verbs[0];
    for(i = 1 ; i < foundVerbs.ItemCount ; i++)
    {
      if(verbs[i].Length > returnVerb.Length)
      {
        returnVerb = verbs[i];
      }
    }
    return verbDictionary.Get(returnVerb);
  }
}

// this function allows 2 inventory items to be merged together (keeps one,  modifies its parameters and removes the other)
function fitInventoryItemsTogether(InventoryItem* keptItem, InventoryItem* fittedItem, String newKeptItemName, int newItemGraphic, bool ReplaceDesc_orAppend, String newItemDescription, int AddedScore)
{
  String oldDescription = keptItem.GetTextProperty("TextDescription");
  String oldName = keptItem.Name;
  
  keptItem.Name = newKeptItemName;
  if(ReplaceDesc_orAppend)
  {
    keptItem.SetTextProperty("TextDescription", newItemDescription);
  } else {
    keptItem.SetTextProperty("TextDescription", oldDescription.Append(String.Format(" %s", newItemDescription)));
  }
  keptItem.Graphic = newItemGraphic;
  player.LoseInventory(fittedItem);
  if(AddedScore > 0)
  {
    giveScoreOnce(String.Format("Fit %s in %s", fittedItem.Name, oldName), AddedScore);
  }
}

//##### ITEMS IN ITEMS #####
Set* getClassifySolutionSet(String parentItemName)
{
  InventoryItem* parentItem = inventory[findInvItemIndexByName(parentItemName)];
  
  switch(parentItem)
  {
    case iLegalPapers:
      return legalPapers_solution;
      break;
    case iSalesDossier:
      return saleDossier_solution;
      break;
    default:
      debugDisplay(String.Format("%s is not handled by getClassifySolutionSet function", parentItemName));
      break;
  }
}

Dictionary* getDictionariesForParentItems(InventoryItem* parentItem, parentItemDict aspect)
{
  switch (parentItem)
  {
    case iLegalPapers:
      if(aspect == subitemDescription)
      {
        return legalPapers_description;
      } else if(aspect == subitemNote)
      {
        return legalPapers_notes;
      } else
      {
        debugDisplay("Unhandled aspect of legal papers from getDictionariesForParentItems");
      }
      break;
    case iFilm:
      if(aspect == subitemDescription)
      {
        return film_description;
      } else if(aspect == subitemNote)
      {
        return film_notes;
      } else
      {
        debugDisplay("Unhandled aspect of film from getDictionariesForParentItems");
      }
      break;
    case iPhotos:
      if(aspect == subitemDescription)
      {
        return photo_description;
      } else if(aspect == subitemNote)
      {
        return photo_notes;
      } else
      {
        debugDisplay("Unhandled aspect of photos from getDictionariesForParentItems");
      }
      break;
    case iSalesDossier:
      if(aspect == subitemDescription)
      {
        return saleDossier_description;
      } else if(aspect == subitemNote)
      {
        return saleDossier_notes;
      } else
      {
        debugDisplay("Unhandled aspect of saleDossier from getDictionariesForParentItems");
      }
      break;
    case iTelegrams:
      if(aspect == subitemDescription)
      {
        return telegram_description;
      } else if(aspect == subitemNote)
      {
        return telegram_notes;
      } else
      {
        debugDisplay("Unhandled aspect of telegram from getDictionariesForParentItems");
      }
      break;        
    case iFood:
      if(aspect == subitemDescription)
      {
        return food_description;
      } else if(aspect == subitemNote)
      {
        return food_notes;
      } else if(aspect == subItemSpoiltime)
      {
        return food_spoilTime;
      } else if(aspect == subItemAlternateName)
      {
        return food_alternateNames;
      } else
      {
        debugDisplay("Unhandled aspect of food from getDictionariesForParentItems");
      }
      break;
    case iBooks:
      if(aspect == subitemDescription)
      {
        return books_description;
      } else if(aspect == subitemNote)
      {
        return books_notes;
      } else
      {
        debugDisplay("Unhandled aspect of books from getDictionariesForParentItems");
      }
      break;  
    default:
      debugDisplay(String.Format("%d is not handled by the getDictionariesForParentItems function", parentItem.Name));
      break;
  }
  
}

bool playerHasSubitem(String subItemName, InventoryItem* parentItem)
{
  Dictionary* thisParentItemDict = getDictionariesForParentItems(parentItem, subitemDescription);
  return thisParentItemDict.Contains(subItemName);
}

function changeSubItemNote(InventoryItem* thisParentItem, String thisSubItemName, String newNote)
{
  Dictionary* thisParentItemDict = getDictionariesForParentItems(thisParentItem, subitemNote);
  
  if(playerHasSubitem(thisSubItemName, thisParentItem))
  {
    thisParentItemDict.Set(thisSubItemName, newNote);
  }
}

function changeAllSubItemNoteInParent(InventoryItem* thisParentItem, String newNote)
{
  Dictionary* thisParentItemDict = getDictionariesForParentItems(thisParentItem, subitemNote);
  String subItemNames[];
  subItemNames = thisParentItemDict.GetKeysAsArray();
  int i;
  
  for(i = 0 ; i < thisParentItemDict.ItemCount ; i++)
  {
    changeSubItemNote(thisParentItem, subItemNames[i], newNote);
  }
}

function removeSubitem(InventoryItem* parentItem, String thisSubitemName,  bool showWarningOnError)
{
  Dictionary* mySubitemDescription = getDictionariesForParentItems(parentItem, subitemDescription);
  Dictionary* mySubitemNote = getDictionariesForParentItems(parentItem, subitemNote);
  
  if(mySubitemDescription.Contains(thisSubitemName) && mySubitemNote.Contains(thisSubitemName))
  {
    mySubitemDescription.Remove(thisSubitemName);
    mySubitemNote.Remove(thisSubitemName);
  } else if (showWarningOnError)
  {
    debugDisplay(String.Format("%s is not a subitem of %s", thisSubitemName, parentItem.Name));
  }    
}

function addSubitem(InventoryItem* parentItem, String thisSubitemName, String thisSubitemDescription, String thisSubitemNote)
{
  Dictionary* mySubitemDescription;
  Dictionary* mySubitemNote;
   
  if(parentItem.GetTextProperty("InvContext") == "Classify" || parentItem.GetTextProperty("InvContext") == "Contains")
  {
    mySubitemDescription = getDictionariesForParentItems(parentItem, subitemDescription);
    mySubitemDescription.Set(thisSubitemName, thisSubitemDescription);
    mySubitemNote = getDictionariesForParentItems(parentItem, subitemNote);
    mySubitemNote.Set(thisSubitemName, thisSubitemNote);
    if(!player.HasInventory(parentItem))
    {
      player.AddInventory(parentItem);
    }
  } else
  {
    debugDisplay(String.Format("%d does not have an appropriate invContext parameter", parentItem.Name));
  }  
}

function transfertSubitemFromOneParentToAnother(InventoryItem* originalParentItem, InventoryItem* targetParentItem, String subItemName,  bool showWarningOnError)
{
  Dictionary* mySubitemDescription_origin = getDictionariesForParentItems(originalParentItem, subitemDescription);
  Dictionary* mySubitemNote_origin = getDictionariesForParentItems(originalParentItem, subitemNote);
  Dictionary* mySubitemDescription_target = getDictionariesForParentItems(targetParentItem, subitemDescription);
  Dictionary* mySubitemNote_target = getDictionariesForParentItems(targetParentItem, subitemNote);
  
  if(mySubitemDescription_origin.Contains(subItemName) && mySubitemNote_origin.Contains(subItemName))
  {
    addSubitem(targetParentItem, subItemName, mySubitemDescription_origin.Get(subItemName), mySubitemNote_origin.Get(subItemName));
    removeSubitem(originalParentItem, subItemName, showWarningOnError);
  } else
  {
    if(showWarningOnError)
    {
      debugDisplay(String.Format("%s is not a subitem of %s", subItemName, originalParentItem.Name));
    }
  }
}

function tranfertAllSubitemFromOneParentToAnother(InventoryItem* originalParentItem, InventoryItem* targetParentItem)
{
  Dictionary* mySubitemDescription_origin = getDictionariesForParentItems(originalParentItem, subitemDescription);
  Dictionary* mySubitemNote_origin = getDictionariesForParentItems(originalParentItem, subitemNote);
  Dictionary* mySubitemDescription_target = getDictionariesForParentItems(targetParentItem, subitemDescription);
  Dictionary* mySubitemNote_target = getDictionariesForParentItems(targetParentItem, subitemNote);
  String subitemNames[];
  subitemNames = mySubitemDescription_origin.GetKeysAsArray();
  int i;
  
  for(i = 0 ; i < mySubitemDescription_origin.ItemCount ; i++)
  {
    transfertSubitemFromOneParentToAnother(originalParentItem, targetParentItem, subitemNames[i], true);
  }
}

function lbInventory_Selector_adapt(String itemName){
  int i = Game.InventoryItemCount;
  String allContexts = "Classify, Contains";
  bool foundMatch = false;
  
  while(i > 0 && !foundMatch) 
  {
    if(inventory[i].Name == itemName)
    {
      //imgSelectedInv.NormalGraphic = inventory[i].Graphic;
      if(inventory[i].GetProperty("tellsTime"))
      {
        lblDescriptionSelectedItem.Text = String.Format("%s[It is %s, currently.", inventory[i].GetTextProperty("TextDescription"), whatTimeIsIt(true));
      } else {
        lblDescriptionSelectedItem.Text = String.Format("%s", inventory[i].GetTextProperty("TextDescription"));
      }
      
      if(inventory[i].GetTextProperty("invContext") == "Null")
      {
        btnInvContext.Visible = false;
      } else if (allContexts.IndexOf(inventory[i].GetTextProperty("invContext")) != -1)
      {
        btnInvContext.Text = String.Format("> %s", inventory[i].GetTextProperty("invContext"));
        btnInvContext.Visible = true;
      }
      foundMatch = true;
    } else {
      i--;
    }
  }
}

function fillInventoryListBox ()
{
  int i;
  bool firstItem = false;
  String itemDescription;
  lbInventory.Clear();
  
  for(i = Game.InventoryItemCount ; i > 0 ; i--) 
  {
    if(player.HasInventory(inventory[i]))
    {
      lbInventory.AddItem(inventory[i].Name);
      if(firstItem == false) {
        lbInventory_Selector_adapt(inventory[i].Name);
        firstItem = true;
      }
    }
  }
}

int findListBoxIndexbyName(ListBox* thisLB, String itemLookedFor)
{
  int selectedIndex = 0;
  int i = 0;
  bool foundit = false;
  while (i < thisLB.ItemCount && !foundit)
  {
    if(thisLB.Items[i] == itemLookedFor)
    {
      selectedIndex = i;
      foundit = true;
    }
    i++;
  }
  return selectedIndex;
}

function show_inventory_window()
{
  fillInventoryListBox();
  playConfirm();
  open_gui(gInventory);
}

function ValidateFileIt (ListBox* classifiedProposition, Set* classifiedSolution, InventoryItem* thisItem, int classifiedSpriteNumber,  String classifiedItemName, int addScoreAmount)
{
  bool allGood = true;
  int i = 0;
  String orderedSolution[];
  orderedSolution = classifiedSolution.GetItemsAsArray();
  
  close_gui(gClassify);
  if(classifiedSolution.ItemCount != classifiedProposition.ItemCount)
  {
    player.Think("Hmm... That's not right");
    player.Think("Something is missing");
  } else
  {
    while(i < classifiedSolution.ItemCount && allGood)
    {
      if(orderedSolution[i] != classifiedProposition.Items[i]) {
        allGood = false;
      }
      i++;
    }
    
    if(allGood)
    {
      player.Say("Hurray! Perfectly organized");
      thisItem.Graphic = classifiedSpriteNumber;
      giveScoreOnce(thisItem.Name, addScoreAmount);
      thisItem.Name = classifiedItemName;
      thisItem.SetTextProperty("invContext", "Null");
      fillInventoryListBox();
      lbInventory.SelectedIndex = findListBoxIndexbyName(lbInventory, thisItem.Name);
      lblDescriptionSelectedItem.Text = inventory[findInvItemIndexByName(lbInventory.Items[lbInventory.SelectedIndex])].GetTextProperty("TextDescription");
    } else {
      player.Think("Hmm... That's not right");
    }
  }
  open_gui(gInventory);  
}

Set* breakWrittenContentByPage(String fullMessage, String pageBreakSymbol)
{
    Set* returnSet = Set.Create(eSorted);
    String currentPage;
    int currentPageNumber = 1;
    
    while(fullMessage.IndexOf(pageBreakSymbol) != -1)
    {
      currentPage = fullMessage.Truncate(fullMessage.IndexOf(pageBreakSymbol));
      currentPage = currentPage.Replace(pageBreakSymbol, "", eCaseInsensitive);
      fullMessage = removeOneStringInstance(fullMessage, currentPage.Append(pageBreakSymbol));
      currentPage = String.Format("PAGE %d[%s", currentPageNumber, currentPage);
      returnSet.Add(currentPage);
      
      currentPageNumber++;
    }
    fullMessage = String.Format("PAGE %d[%s", currentPageNumber, fullMessage);
    returnSet.Add(fullMessage);
    
    return returnSet;
}

function readThis(String fullMessage, String pageSeparator)
{
  Set* readContent = breakWrittenContentByPage(fullMessage, pageSeparator);
  String readContentToDisplay[] = readContent.GetItemsAsArray();
  int i;
  for(i = 0 ; i < readContent.ItemCount ; i++)
  {
    Display(readContentToDisplay[i]);
  }
}

function fillSubItemLB(ListBox* lbToFill, Dictionary* Dict_desc, Dictionary* Dict_note, Label* lblThisSubitemDescription)
{
  int i;
  String dictKeys[] = Dict_desc.GetKeysAsArray();
  String descDisplay;
  
  lbToFill.Clear();
  for(i = 0 ; i < Dict_desc.ItemCount ; i++) {
    lbToFill.AddItem(dictKeys[i]);
  }
  lbToFill.SelectedIndex = 0;
  
  descDisplay = Dict_desc.Get(lbToFill.Items[lbToFill.SelectedIndex]);
  descDisplay = descDisplay.Append("[");
  descDisplay = descDisplay.Append(Dict_note.Get(lbToFill.Items[lbToFill.SelectedIndex]));
  
  lblThisSubitemDescription.Text = descDisplay;
}

function openSubinventoryGUI(String parentItemName)
{
  InventoryItem* parentItem = inventory[findInvItemIndexByName(parentItemName)];
  Dictionary* subitemDescDict_desc = getDictionariesForParentItems(parentItem, subitemDescription);
  Dictionary* subitemDescDict_note = getDictionariesForParentItems(parentItem, subitemNote);
  String invContext = parentItem.GetTextProperty("InvContext");
  
  switch(invContext)
  {
    case "Classify":
      fillSubItemLB(lbClassifiable, subitemDescDict_desc, subitemDescDict_note, lblClassifyDescription);
      lblClassifyTitle.Text = lblClassifyTitle.Text.Replace("items", parentItemName, eCaseInsensitive);
      open_gui(gClassify);
      break;
    case "Contains":
      fillSubItemLB(lbSubtiems, subitemDescDict_desc, subitemDescDict_note, lblSubitemDescription);
      lblSubitem_titles.Text = lblSubitem_titles.Text.Replace("items", parentItemName, eCaseInsensitive);
      open_gui(gSubitems);
      break;
    default:
      debugDisplay(String.Format("Unhandled invContext type : %s", invContext));
      break;
  }
}

//##### TELEGRAMS AND ADDRESS BOOK #####
function addHotelPackage(String packageName, int delayReceptionByMinutes)
{
  int arrivalTime = translateTimeToMinutes(whatTimeIsIt(false)) + delayReceptionByMinutes;
  hotelPackages.Set(packageName, translateMinutesToHHMMAM(arrivalTime));
}

Set* getHotelPackages()
{
  Set* arrivedHotelPackages = Set.Create(eNonSorted);
  String packageList[];
  String packageArrivalTime;
  packageList = hotelPackages.GetKeysAsArray();
  int i;
  
  for(i = 0 ; i < hotelPackages.ItemCount ; i++)
  {
    packageArrivalTime = hotelPackages.Get(packageList[i]);
    if(isThisTimeBeforeThisTime(packageArrivalTime, whatTimeIsIt(false)))
    {
      arrivedHotelPackages.Add(packageList[i]);
      hotelPackages.Remove(packageList[i]);
    }
  }
  
  return arrivedHotelPackages;
}

function addPlannedTelegram(String recipientName, String recipientAlternateNames,  String recipientFullNameAndCity, String telegramMsg)
{
  addressBook_alternateNames.Set(recipientName, String.Format("%s,%s", recipientName, recipientAlternateNames));
  addressBook_recipientDescription.Set(recipientName, recipientFullNameAndCity);
  addressBook_message.Set(recipientName, telegramMsg);
  addTravelDestination(TelegramOffice);
}

function updateTelegramMessage(String recipient, String alternateNames, String realNameAndCity, String newOrSent, String mergedMsg)
{
  if(addressBook_message.Contains(recipient))
  {
    if(addressBook_message.Get(recipient) == "SENT")
    {
      addressBook_message.Set(recipient, newOrSent);
    } else
    {
      addressBook_message.Set(recipient, mergedMsg);
    }
  } else {
    addPlannedTelegram(recipient, alternateNames, realNameAndCity,  newOrSent);
  }
}

function sendTelegram(String recipientName)
{
  player.Say(addressBook_recipientDescription.Get(recipientName));
  if(addressBook_message.Get(recipientName) == "SENT")
  {
    player.Say("Wait no,");
    player.Say("I have sent this telegram already...");
    cTelegramOperator.Say("Oh now, you are being silly!");
    dTelegram.Start();
  } else
  {
    cTelegramOperator.Say("Your name?");
    if(player.HasInventory(iDiploma))
    {
      player.Say("Harker, Jonathan Harker, Esq.");
    } else 
    {
      player.Say("Harker, Jonathan Harker");
    }
    player.Say("I reside at the Hotel the Hummums while in London");
    cTelegramOperator.Say("And the message?");
    player.Say(addressBook_message.Get(recipientName));
    giveScoreOnce(String.Format("Telegram to %s: '%s'", recipientName, addressBook_message.Get(recipientName)), 1);
    addressBook_message.Set(recipientName, "SENT");
    cTelegramOperator.Say("I will send that message in a minute, Mr Harker");
    cTelegramOperator.Say("Any answer will be delivered to your hotel by messenger");
    addHotelPackage(String.Format("TelegramAnswer_%s", recipientName), 60 + Random(360));
    
    if(!playerHasSubitem("Hawkins", iTelegrams))
    {
      cTelegramOperator.Say("Wait, your name is Harker?");
      player.Say("Jonathan Harker, yes");
      cTelegramOperator.Say("I have received a telegram for you");
      if(recipientName == "Hawkins")
      {
        cTelegramOperator.Say("From that Hawkins person in Exeter too!");
        cTelegramOperator.Say("Isn't that a fun coincidence!");
        player.Say("Absolutely");
        cTelegramOperator.Say("Well...");
      } else
      {
        cTelegramOperator.Say("It is from Exeter, sender: Hawkins Esq.");
      }
      cTelegramOperator.Say("Here it is!");
      int arrivalTime = translateTimeToMinutes(whatTimeIsIt(false)) - 23 - Random(40);
      addSubitem(iTelegrams, "Hawkins", "Harker STOP[You need to go to Count Dracula's castle STOP[Cannot go STOP[gout is acting up STOP[Will send letter for Count to Hotel by courrier", String.Format("From Hawkins, Esq. : %s", translateMinutesToHHMMAM(arrivalTime)));
      arrivalTime = (4 * 60) + Random(60) - (translateTimeToMinutes(whatTimeIsIt(false)) - arrivalTime);
      updateTelegramMessage("Mina", "Wilhelmina,Murray,bethroted,love,fiancee", "Wilhelmina Murray, in Exeter", 
                            "Mr. Hawkins victim to an attack of gout STOP[Will need to go to Transylvania in his guise STOP[Should be back within a month", 
                            "Mr. Hawkins victim to an attack of gout STOP[Will need to go to Transylvania in his guise STOP[Should be back within a month STOP[Also succeeded my exam STOP Now full sollicitor STOP[We can finally get married when I come back STOP[Love");
      addHotelPackage("ItineraryLetterFromDracula", arrivalTime);
    }
  }
}

String findTelegramRecipientByName(String givenName)
{
  String possibleName[];
  possibleName = addressBook_alternateNames.GetKeysAsArray();
  int i = 0;
  String returnName = "Null";
  String listOfAlternates;
  
  while(i < addressBook_alternateNames.ItemCount)
  {
    listOfAlternates = addressBook_alternateNames.Get(possibleName[i]);
    if(listOfAlternates.IndexOf(givenName) != -1)
    {
      returnName = possibleName[i];
      i = addressBook_alternateNames.ItemCount;
    } else {
      i++;
    }
  }
  
  return returnName;
}

function handleTelegramRecipient(String textInput)
{
  String actualRecipient = findTelegramRecipientByName(textInput);
  if(actualRecipient == "Null")
  {
    player.Say(String.Format("%s?", textInput));
    cTelegramOperator.Say("That sounded more like a question than an answer!");
    cTelegramOperator.Say("Do you think I'll find this name with an interrogation point in my directory?");
    cTelegramOperator.Say("Ha ha ha!");
    cTelegramOperator.Say("I'm just being silly");
    cTelegramOperator.Say("But that name is not in my directory");
    dTelegram.Start();
  } else
  {
    sendTelegram(actualRecipient);
  }
}

//##### PERMITTED ENTRANCE #####
function setOpeningAndClosingTimeForACommerce(commerce thisCommerce, String thisOpeningTime, String thisClosingTime)
{
  commerce_openingTime.Set(commerceAsString(thisCommerce), thisOpeningTime);
  commerce_closingTime.Set(commerceAsString(thisCommerce), thisClosingTime);
}

function setOpeningAndClosingTimes()
{
  setOpeningAndClosingTimeForACommerce(Museum, translateTimeToHHMMAM(10, 0, "AM"), translateTimeToHHMMAM(5, 0, "PM"));
  setOpeningAndClosingTimeForACommerce(HawkinsEsq, translateTimeToHHMMAM(8, 0, "AM"), translateTimeToHHMMAM(4, 30, "PM"));
  setOpeningAndClosingTimeForACommerce(LawSocietyBuilding, translateTimeToHHMMAM(10, 0, "AM"), translateTimeToHHMMAM(4, 30, "PM"));
  setOpeningAndClosingTimeForACommerce(Shop, translateTimeToHHMMAM(9, 0, "AM"), translateTimeToHHMMAM(6, 0, "PM"));
  setOpeningAndClosingTimeForACommerce(TrainStation, translateTimeToHHMMAM(6, 0, "AM"), translateTimeToHHMMAM(11, 0, "PM"));
  setOpeningAndClosingTimeForACommerce(AlwaysOpened, translateTimeToHHMMAM(0, 00, "AM"), translateTimeToHHMMAM(11, 59, "PM"));
}

commerce getCommerceType(zone targetZone)
{
  return stringAsCommerce(zone_CommerceType.Get(zoneAsString(targetZone)));
}

String isThisPlaceOpened(commerce commerceType)
{
  String thisTime = whatTimeIsIt(false);
  String minTime = commerce_openingTime.Get(commerceAsString(commerceType));
  String maxTime = commerce_closingTime.Get(commerceAsString(commerceType));
  int openedFor;
  String giveOpeningTimes = String.Format("Closed! The sign says it is opened from %s to %s", minTime, maxTime);
  
  if(commerceType == AlwaysOpened)
  {
    return "opened";
  } else if(isThisTimeBeforeThisTime(thisTime, minTime)) //not opened yet
  {
    return giveOpeningTimes;
  } else if (isThisTimeBeforeThisTime(maxTime, thisTime)) //alreadyclosed
  {
    return giveOpeningTimes;
  } else if (isThisTimeWithinXminOfThisTime(thisTime, maxTime, 30))
  {
    openedFor = translateTimeToMinutes(maxTime) - translateTimeToMinutes(thisTime);
    return String.Format("%d");
  } else
  {
    return "opened";
  }
}

zone manageEntranceToCommerce(zone destination)
{
  commerce commerceType = getCommerceType(destination);
  String state = isThisPlaceOpened(commerceType);
  bool rebute = state.StartsWith("Close");
  
  commerce commerceType2 = getCommerceType(currentZone);
  String state2 = isThisPlaceOpened(commerceType2);
  bool rebute2 = state2.StartsWith("Close");
  
  if (!rebute)
  {
    return destination;
  } else if (rebute && !rebute2)
  {
    return currentZone;
  } else
  {
    if (city_TravelDestinations.Get(zoneAsString(currentZone)) == "Exeter")
    {
      return JonathanApt;
    } else
    {
      return LondonTrainStation;
    }
  }
}

zone getWantedDestination()
{
  return wantedDestination;
}

zone getRealDestination()
{
  return realDestination;
}

function setTravellingBool(bool targetbool)
{
  travelling = targetbool;
}

bool getTravellingBool()
{
  return travelling;
}

function travel_movePlayer(zone destination)
{
  CharacterDirection arrivalDirection;
  String roomDestination;
  int futureRoom;
  
  wantedDestination = destination;
  travelling = true;
  
  realDestination = manageEntranceToCommerce(destination);
  
  if(wantedDestination != realDestination)
  {
    player.ChangeRoom(12, 156, 142, eDirectionDown);
  } else
  {
    roomDestination = roomForEachTravelDestinations.Get(zoneAsString(realDestination));
    futureRoom = roomDestination.AsInt;
  
    player.ChangeRoom(futureRoom, arrival_x[futureRoom], arrival_y[futureRoom], faceDirection[futureRoom]);
    cHarkersBeard.ChangeRoom(futureRoom, arrival_x[futureRoom], arrival_y[futureRoom], faceDirection[futureRoom]);
    addTravelDestination(wantedDestination);
    setCurrentZone(realDestination);
    currentCommerceType = getCommerceType(currentZone);
    travelling = false;
  }
}

function travel(zone destination)
{
  if(destination != StayHere)
  {
    travel_movePlayer(destination);
  } else {
    player.Walk(arrival_x[player.Room], arrival_y[player.Room], eBlock, eAnywhere);
    player.FaceDirection(faceDirection[player.Room]);
  }
}

//##### FOOD #######
function addFood(String foodName, String alternateNames, String textDescription)
{
  if(!food_description.Contains(foodName))
  {
    int spoilTime = translateTimeToMinutes(whatTimeIsIt(false)) + (6*60) + (currentDay * 24 * 60);
    String spoilTimeAsString = String.Format("%d", spoilTime);
    addSubitem(iFood, foodName, textDescription, "This food is still good");
    food_alternateNames.Set(foodName, String.Format("%s,%s", foodName, alternateNames));
    food_spoilTime.Set(foodName, spoilTimeAsString);
  } else
  {
    player.Say(String.Format("I already have %s, I better eat mine instead, before it spoils", foodName));
  }
}

bool isFoodSpoiled(String foodName)
{
  int currentMinutes = translateTimeToMinutes(whatTimeIsIt(false)) + (currentDay * 24 * 60);
  String foodSpoilTime_asString = food_spoilTime.Get(foodName);
  int foodSpoilTime = foodSpoilTime_asString.AsInt;
  return (currentMinutes > foodSpoilTime);
}

function updateFoodFreshness()
{
  String foodNames[];
  foodNames = food_spoilTime.GetKeysAsArray();
  int i;
  
  for(i = 0 ; i < food_spoilTime.ItemCount ; i++)
  {
    if(isFoodSpoiled(foodNames[i]))
    {
      food_notes.Set(foodNames[i], "This food is spoiled. I can throw it out in any café's bin");
    } 
  }
}

function cleanAllSpoiledFood()
{
  String foodNames[];
  foodNames = food_spoilTime.GetKeysAsArray();
  int i;
  for(i = 0 ; i < food_spoilTime.ItemCount ; i++)
  {
    if(isFoodSpoiled(foodNames[i]))
    {
      switch(Random(3))
      {
        case 0:
          player.Say(String.Format("Away with the spoiled %s", foodNames[i]));
          break;
        case 1:
          player.Say(String.Format("Spoiled %s is discarded", foodNames[i]));
          break;
        case 2:
          player.Say(String.Format("No need for a spoiled %s", foodNames[i]));
          break;
        default:
          player.Say(String.Format("Spoiled %s are smelly", foodNames[i]));
          break;
      }
      removeSubitem(iFood, foodNames[i], false);
    } 
  }
}

bool playerHasSpoiledFood()
{
  bool returnBool = false;
  String foodNames[];
  foodNames = food_spoilTime.GetKeysAsArray();
  int i = 0;
  while(i < food_spoilTime.ItemCount)
  {
    if(isFoodSpoiled(foodNames[i]))
    {
      i = food_spoilTime.ItemCount;
      returnBool = true;
    } else
    {
      i++;
    }
  }
  return returnBool;
}


bool isPlayerHungry()
{
  int nowInMinutes = translateTimeToMinutes(whatTimeIsIt(false)) + (currentDay * 24 * 60);
  return ((lastMealTime + (4 * 60)) < nowInMinutes);
}

String findFoodByName(String foodName)
{
  String returnName = "Null";
  String altNames;
  String foodList[];
  int i = 0;
  
  if(food_alternateNames.Contains(foodName))
  {
    returnName = foodName;
  } else 
  {
    foodList = food_alternateNames.GetKeysAsArray();
    while(i < food_alternateNames.ItemCount)
    {
      if(foodList[i].IndexOf(foodName) != -1)
      {
        returnName = foodList[i];
        i = food_alternateNames.ItemCount;
      } else
      {
        i++;
      }
    }
  }
  return returnName;
}

function eatFood(String foodName)
{
  foodName = findFoodByName(foodName);
  if(foodName == "Null")
  {
    player.Say(String.Format("I do not have a %s to eat"));
  } else
  {
    if(isPlayerHungry())
    {
      player.Say(String.Format("I am hungry for a %s", foodName));
      if(isFoodSpoiled(foodName))
      {
        player.Say("Blo... H...! Ew!");
        player.Say("That food is spoiled");
        removeSubitem(iFood, foodName, false);
        GiveScore(-1);
      } else
      {
        player.Say("Delicious!");
        removeSubitem(iFood, foodName, false);
        GiveScore(1);
        lastMealTime = translateTimeToMinutes(whatTimeIsIt(false)) + (currentDay * 24 * 60);
      }
    } else
    {
      player.Say("I ate not that long ago");
    }
  }
}

//####### PICTURES ######
int getNbNegative()
{
  return nbNegatives;
}

int getNbMissingNegatives()
{
  return MAXNEGATIVE - nbNegatives;
}

function setNumberOfNegative(int targetNbNegative)
{
  String nbNegativesMsg = "I have ### negative@ left";
  
  if(targetNbNegative < 0)
  {
    nbNegatives = 0;
  } else if (targetNbNegative > MAXNEGATIVE)
  {
    nbNegatives = MAXNEGATIVE;
  } else
  {
    nbNegatives = targetNbNegative;
  }
  
  switch(nbNegatives)
  {
    case 0:
      nbNegativesMsg = nbNegativesMsg.Replace("###", "no", eCaseInsensitive);
      nbNegativesMsg = nbNegativesMsg.Replace("@", "s", eCaseInsensitive);
      break;
    case 1:
      nbNegativesMsg = nbNegativesMsg.Replace("###", "1", eCaseInsensitive);
      nbNegativesMsg = nbNegativesMsg.Replace("@", "", eCaseInsensitive);
      break;
    default:
      nbNegativesMsg = nbNegativesMsg.Replace("###", String.Format("%d", nbNegatives), eCaseInsensitive);
      nbNegativesMsg = nbNegativesMsg.Replace("@", "s", eCaseInsensitive);
      break;
  }
  iCamera.SetTextProperty("TextDescription", String.Format("This is the office's photo camera. State of the art technology![[%s", nbNegativesMsg));
  
  if(!playerHasTravelDestination(PhotographyShop) && nbNegatives < 4)
  {
    gameIsOver("Jonathan likes photos too much");
  }
}

function resetNbNegativesToMax()
{
  setNumberOfNegative(MAXNEGATIVE);
}

bool playerHasAllCarfaxPictures() // test me
{
  bool allPhotos = true;
  String currentSubject;
  InventoryItem* photoItem = iPhotos;
  InventoryItem* filmItem = iFilm;
  
  currentSubject = "Carfax's Kitchen";
  allPhotos = (allPhotos && (playerHasSubitem(currentSubject, photoItem) || playerHasSubitem(currentSubject, filmItem)));
  
  currentSubject = "Carfax's Living";
  allPhotos = (allPhotos && (playerHasSubitem(currentSubject, photoItem) || playerHasSubitem(currentSubject, filmItem)));
  
  currentSubject = "Carfax's Dining";
  allPhotos = (allPhotos && (playerHasSubitem(currentSubject, photoItem) || playerHasSubitem(currentSubject, filmItem)));
  
  currentSubject = "Carfax's Bedroom";
  allPhotos = (allPhotos && (playerHasSubitem(currentSubject, photoItem) || playerHasSubitem(currentSubject, filmItem)));
}

function takeAPicture(String subject, String pictureDescription, int score)
{
  if(!player.HasInventory(iCamera))
  {
    player.Say("I need a camera to take pictures");
  } else if(nbNegatives < 1)
  {
    player.Say("I am out of film...");
  } else
  {
    setNumberOfNegative(nbNegatives - 1);
    addSubitem(iFilm, subject, pictureDescription, "This picture must be developed by a professional before I can use it");
    Display("Click!");
    player.Say(String.Format("I took a picture of the %s", subject));
    if(Game.DoOnceOnly("Talk about developped photos"))
    {
      player.Say("Of course it must be developed by a professional before I can use it");
    }
    
    if(city_TravelDestinations.Get(zoneAsString(currentZone)) == "London")
    {
      if(Game.DoOnceOnly("Remember the photo service at the Law Society"))
      {
        player.Say("Oh wait a minute!");
        player.Say("The Law Society has a photo development centre");
        player.Say("I remember seeing it when I came to London to take my sollicitor exam");
        player.Say("Maybe they can develop these negatives");
        addTravelDestination(LawSocietyOffices);
        dLawSocietyReceptionist.SetOptionState(9, eOptionOn);
      }
    }
    
    if(score != 0)
    {
      giveScoreOnce(String.Format("Picture of %s", subject), score);
    }
    
    if(playerHasAllCarfaxPictures())
    {
      if(Game.DoOnceOnly("All Carfax's pictures"))
      {
        player.Say("Splendid, I have all four pictures of this property for the file");
        player.Say("Time to head back to London");
        player.Say("I can probably develop the negatives at the Law Society's photo counter");
      }
    }
  }
}

//####### INTERACTIONS #######

bool interact(String indexElementVerbHandled[]) // reacts appropriately based on the index,  element and verb passed (reactions detailed in this function's switch)
{
  int index = indexElementVerbHandled[0].AsInt;
  elementType eT = stringToET(indexElementVerbHandled[1]);
  String verb = indexElementVerbHandled[2];
  String lookDescription;
  int alternateSpriteNumber;
  int walkableAreaNumber;
  bool handledInteraction = true;
  
  Set* readContent;
  String readContentToDisplay[];
  int i;
  
  switch (verb)
  {
    case "look":
      switch (eT)
      {
        case roomObjects:
          if(object[index].Visible || object[index].GetProperty("InteractableWhenInvisible"))
          {
            lookDescription = object[index].GetTextProperty("TextDescription");
            if(object[index].GetProperty("tellsTime"))
            {
              lookDescription = addTimeToDescription(lookDescription);
            }
            player.FaceObject(object[index], eBlock);
            player.Say(lookDescription);
          } else {
            player.Say("I'm not sure what I'm looking at...");
          }
          break;
        case roomHotspots:
          lookDescription = hotspot[index].GetTextProperty("TextDescription");
          if(hotspot[index].GetProperty("tellsTime"))
            {
              lookDescription = addTimeToDescription(lookDescription);
            }
          player.FaceLocation(hotspot[index].WalkToX, hotspot[index].WalkToY, eBlock);
          player.Say(lookDescription);
          break;
        case allCharacters:
          if(character[index].Transparency < 100){
            lookDescription = character[index].GetTextProperty("TextDescription");
            player.FaceCharacter(character[index], eBlock);
            player.Say(lookDescription);
          } else {
            player.Say("I'm not sure what I'm looking at...");
          }
          break;
        case allInventoryItems:
          lookDescription = inventory[index].GetTextProperty("TextDescription");
          player.FaceDirection(eDirectionDown, eBlock);
          if(inventory[index].GetProperty("tellsTime"))
            {
              lookDescription = addTimeToDescription(lookDescription);
            }
          player.Say(lookDescription);
          break;
        default:
          player.Say("I'm not sure what I'm looking at...");
          break;
      }
      break;
    case "open":
      switch(eT)
      {
        case roomObjects:
          alternateSpriteNumber = object[index].GetProperty("Open_SpriteNumber");
          walkableAreaNumber = object[index].GetProperty("WalkableArea_opened");
          if(alternateSpriteNumber == -1)
          {
            player.Think("I cannot open this");
          } else if(isCharacterNearObject(object[index], reachDistance,  player))
          {
            if(alternateSpriteNumber == -2) {
              if(!object[index].Visible)
              {
                player.Think("It is already opened");
              } else {
                object[index].Visible = false;
              }
            } else if(object[index].Graphic == alternateSpriteNumber)
            {
              if(object[index].Visible)
              {
                player.Think("It is already opened");
              } else {
                object[index].Visible = true;
              }
            } else {
              object[index].Graphic = alternateSpriteNumber;
            }
            if(walkableAreaNumber != -1)
            {
              RestoreWalkableArea(walkableAreaNumber);
            }
          } else {
            player.Think("I can't reach from here");
          }
          break;
        case allInventoryItems:
          alternateSpriteNumber = inventory[index].GetProperty("Open_SpriteNumber");
          if(alternateSpriteNumber == -1)
          {
            player.Think("I cannot open this");
          } else if(inventory[index].Graphic == alternateSpriteNumber) 
          {
            player.Think("It is already opened");
          } else {
            inventory[index].Graphic = alternateSpriteNumber;
          }
          break;
        default:
          player.Think("I cannot open this");
          break;
      }
      break;
    case "close":
      switch(eT)
      {
        case roomObjects:
          alternateSpriteNumber = object[index].GetProperty("Close_SpriteNumber");
          walkableAreaNumber = object[index].GetProperty("WalkableArea_opened");
          if(alternateSpriteNumber == -1)
          {
            player.Think("I cannot close this");
          } else if(isCharacterNearObject(object[index], reachDistance,  player))
          {
            if(alternateSpriteNumber == -2) 
            {
              if(!object[index].Visible)
              {
                player.Think("It is already closed");
              } else {
                object[index].Visible = false;
              }
            } else if(object[index].Graphic == alternateSpriteNumber)
            {
              if(object[index].Visible)
              {
                player.Think("It is already closed");
              } else {
                object[index].Visible = false;
              }
            } else {
              object[index].Graphic = alternateSpriteNumber;
            }
            if(walkableAreaNumber != -1)
            {
              RemoveWalkableArea(walkableAreaNumber);
            } 
          } else {
            player.Think("I can't reach from here");
          }
          break;
        case allInventoryItems:
          alternateSpriteNumber = inventory[index].GetProperty("Close_SpriteNumber");
          if(alternateSpriteNumber == -1)
          {
            player.Think("I cannot close this");
          } else if(inventory[index].Graphic == alternateSpriteNumber) 
          {
            player.Think("It is already closed");
          } else {
            inventory[index].Graphic = alternateSpriteNumber;
          }
          break;
        default:
          player.Think("I cannot close this");
          break;
      }
      break;
    case "approach":
      if(!showHints){
        player.Think("I can walk there on my own");
      } else {
        switch(eT)
        {
          case roomObjects:
            player.Walk(object[index].X, object[index].Y, eNoBlock, eWalkableAreas);
            break;
          case roomHotspots:
            player.Walk(hotspot[index].WalkToX, hotspot[index].WalkToY, eNoBlock, eWalkableAreas);
            break;
          case allCharacters:
            player.Walk(character[index].x, character[index].y, eNoBlock, eWalkableAreas);
            break;
          default:
            player.Think("I am not not where to go");
            break;
        }
      }
      break;
    case "sit":
      sit(eT, index, player, 2,  false);
      break;
    case "take":
      if(eT == roomObjects)
      {
        if(object[index].GetProperty("takable") != -1)
        {
          if(isCharacterNearObject(object[index], reachDistance, player))
          {
            player.Think("This can be useful");
            player.AddInventory(inventory[object[index].GetProperty("takable")]);
            object[index].Visible = false;
            giveScoreOnce(inventory[object[index].GetProperty("takable")].Name, 1);
          } else {
            player.Think("I need to go a little closer");
          }
        } else {
          player.Think("I would rather leave this where it is");
        }
      }
      break;
    case "talk":
      switch (eT)
      {
        case allCharacters:
          if(character[index].Room != player.Room)
          {
            player.Think("I am not sure whom to speak to");
          } else
          {
            if (character[index].GetProperty("dialogIndex") == -1)
            {
              player.FaceCharacter(character[index], eBlock);
              player.Think("I do not know what I should say.");
            } else 
            {
              if (character[index].GetProperty("dialogMaxDistance") > -1 && !isCharacterNearCharacter(character[index], IntToFloat(character[index].GetProperty("dialogMaxDistance")), player))
              {
                player.FaceCharacter(character[index], eBlock);
                player.Think(String.Format("%s will not hear me from this distance", character[index].Name));
              } else 
              {
                if (character[index].GetProperty("dialogWhileSitting") != -1 && (player.GetProperty("sitting") != character[index].GetProperty("dialogWhileSitting")))
                {
                player.FaceCharacter(character[index], eBlock);
                  player.Think(String.Format("Politeness dictates that I should sit in the %s before speaking to %s", object[character[index].GetProperty("dialogWhileSitting")].Name.LowerCase(), character[index].Name));
                } else
                {
                  dialog[character[index].GetProperty("dialogIndex")].Start();
                }
              }
            }
          }
          break;
        default:
          player.Think("I am not sure whom to speak to");
          break;
      }
      break;
    case "read":
      if(eT == allInventoryItems && inventory[index].GetTextProperty("ReadDisplay") != "Null")
      {
        readThis(inventory[index].GetTextProperty("ReadDisplay"), "¶");
      } else {
        player.Think("I cannot read this");
      }
      break;
    case "organize":
      if(eT != allInventoryItems || inventory[index].GetTextProperty("invContext") != "Classify")
      {
        player.Think("I cannot classify this");
      } else{
        switch(inventory[index].Name)
        {
          case "Legal papers":
            openSubinventoryGUI("Legal papers");
            break;
          default:
            debugDisplay(String.Format("%s is not a defined fileFamily", inventory[index].Name));
            break;
        }
      }
      break;
    case "photograph":
      switch(eT)
      {
        case roomObjects:
          takeAPicture(object[index].Name, object[index].GetTextProperty("TextDescription"), 0);
          break;
        case roomHotspots:
          takeAPicture(hotspot[index].Name, hotspot[index].GetTextProperty("TextDescription"), 0);
          break;
        case allCharacters:
          takeAPicture(character[index].Name, character[index].GetTextProperty("TextDescription"), 0);
          break;
        case allInventoryItems:
          takeAPicture(inventory[index].Name, object[index].GetTextProperty("TextDescription"), 0);
          break;
        default:
          player.Think("I am not sure what to photograph");
          break;
      }
      break;
    default:
      handledInteraction = false;
      break;
  }
  return handledInteraction;
}

function findElementContaining(String keyword) // makes a list of found things reacting to the 'find' keyword
{
  int i;
  bool intro = false;
  bool invIntro = false;
  String nameAndAKA;
  String article = "";
  String allElementsMentionned = "";
  
  //OBJECTS IN THE ROOM
  for(i = 0; i < Room.ObjectCount; i++) {
    nameAndAKA = object[i].Name;
    if(object[i].GetTextProperty("alternateNames") != "")
    {
      nameAndAKA = nameAndAKA.Append(", ");
      nameAndAKA = nameAndAKA.Append(object[i].GetTextProperty("alternateNames"));
    }
    if(nameAndAKA.IndexOf(keyword) != -1) {
      if(!intro)
      {
        player.Say("Looking around, I can spot...");
        intro = true;
      }
      player.FaceObject(object[i], eBlock);
      article = whichArticle(allElementsMentionned, object[i].Name);
      player.Say(String.Format("%s %s over there.", article,  object[i].Name));
      allElementsMentionned = allElementsMentionned.Append(String.Format("%s ", object[i].Name));
    }
  }
  //HOTSPOTS IN THE ROOM
  for(i = 0; i < 50; i++) {
    nameAndAKA = hotspot[i].Name;
    if(hotspot[i].GetTextProperty("alternateNames") != "")
    {
      nameAndAKA = nameAndAKA.Append(", ");
      nameAndAKA = nameAndAKA.Append(hotspot[i].GetTextProperty("alternateNames"));
    }
    if(nameAndAKA.IndexOf(keyword) != -1) {
      if(!intro)
      {
        player.Say("Looking around, I can spot...");
        intro = true;
      }
      player.FaceLocation(hotspot[i].WalkToX, hotspot[i].WalkToY, eBlock);
      article = whichArticle(allElementsMentionned, hotspot[i].Name);
      player.Say(String.Format("%s %s over there.", article,  hotspot[i].Name));
      allElementsMentionned = allElementsMentionned.Append(String.Format("%s ", hotspot[i].Name));
    }
  }
  //CHARACTERS IN THE ROOM
  for(i = 0; i < Game.CharacterCount; i++) {
    nameAndAKA = character[i].Name;
    if(character[i].GetTextProperty("alternateNames") != "")
    {
      nameAndAKA = nameAndAKA.Append(", ");
      nameAndAKA = nameAndAKA.Append(character[i].GetTextProperty("alternateNames"));
    }
    if(nameAndAKA.IndexOf(keyword) != -1 && player.Room == character[i].Room) {
      if(!intro)
      {
        player.Say("Looking around, I can spot...");
        intro = true;
      }
      player.FaceCharacter(character[i]);
      player.Say(String.Format("%s over there.", character[i].Name));
    }
  }
  //OWNED INVENTORY ITEMS
  for(i = 1; i <= Game.InventoryItemCount; i++) {
    nameAndAKA = inventory[i].Name;
    if(inventory[i].GetTextProperty("alternateNames") != "")
    {
      nameAndAKA = nameAndAKA.Append(", ");
      nameAndAKA = nameAndAKA.Append(inventory[i].GetTextProperty("alternateNames"));
    }
    if(nameAndAKA.IndexOf(keyword) != -1 && player.HasInventory(inventory[i])) {
      if(!invIntro)
      {
        if(intro)
        {
          player.Say("Also...");
        }
        player.Say("In my inventory, I can spot...");
        invIntro = true;
        intro = true;
      }
      player.FaceDirection(eDirectionDown);
      article = whichArticle(allElementsMentionned, inventory[i].Name);
      player.Say(String.Format("%s %s.", article, inventory[i].Name));
      allElementsMentionned = allElementsMentionned.Append(String.Format("%s ", inventory[i].Name));
    }
  }
}

function useInteraction(String cmd) // either 'interact' or 'UseInv' version of runInteraction is used
{
  String OnSynonym = isInteractionOnElement(cmd);
  String useSynonym = cmdStartsWithUSEsynonym(cmd);
  
  String cmdUsed;
  String cmdOn;
  
  String indexElementUsed[] = new String[2];
  elementType eTUsed;
  int indexUsed;
  bool canUse = true;
  
  String indexElementOn[] = new String[2];
  elementType eTOn;
  int indexOn;
  
  elementType eTTemp;
  int indexTemp;
    
  if(OnSynonym == "Null") // there is only one verb (use) and a target
  {
      cmd = removeOneStringInstance(cmd, useSynonym.Append(" "));
      indexElementUsed = findElementIndexByName(cmd);
      
      if(indexElementUsed[1] == "Null")
      {
        player.Think("I am not sure what to use");
      } else {
        eTUsed = stringToET(indexElementUsed[1]);
        indexUsed = indexElementUsed[0].AsInt;
        // to handled generic unhandled exception later
        useET = eTUsed;
        useIndex = indexUsed;
        
        switch(eTUsed)
        {
          case roomObjects:
            if(isCharacterNearObject(object[indexUsed], reachDistance, player))
            {
              object[indexUsed].RunInteraction(eModeInteract);
            } else {
              player.Think(String.Format("I need to get closer to the %s to use it", object[indexUsed].Name.LowerCase()));
            }
            break;
          case roomHotspots:
            if(isCharacterNearHotspot(hotspot[indexUsed], reachDistance, player))
            {
              hotspot[indexUsed].RunInteraction(eModeInteract);
            } else {
              player.Think(String.Format("I need to get closer to the %s to use it", hotspot[indexUsed].Name.LowerCase()));
            }
            break;
          case allInventoryItems:
            if(player.HasInventory(inventory[indexUsed]))
            {
              inventory[indexUsed].RunInteraction(eModeInteract);
            } else {
              player.Think("I am not sure what you want me to use");
            }
            break;
          default:
            player.Think("I am not sure what you want me to use");
            break;
        }
      } 
  } else // The player wants to use something on/with something
  {
    cmd = removeOneStringInstance(cmd, useSynonym.Append(" "));
    cmdUsed = cmd.Truncate(cmd.IndexOf(OnSynonym));
    cmd = removeOneStringInstance(cmd, cmdUsed);
    cmdOn = removeOneStringInstance(cmd, OnSynonym);
    
    indexElementUsed = findElementIndexByName(cmdUsed);
    indexElementOn = findElementIndexByName(cmdOn);
    
    if(indexElementOn[1] == "Null" || indexElementUsed[1] == "Null")
    {
      player.Think("I am not sure what you want me to do");
    } else {
      eTUsed = stringToET(indexElementUsed[1]);
      indexUsed = indexElementUsed[0].AsInt;
      eTOn = stringToET(indexElementOn[1]);
      indexOn = indexElementOn[0].AsInt;
      
      if(eTOn == allInventoryItems && eTUsed != allInventoryItems) // if the 2nd is an item but not the first,  invert them
      {
        indexTemp = indexOn;
        eTTemp = eTOn;
        indexOn = indexUsed;
        eTOn = eTUsed;
        indexUsed = indexTemp;
        eTUsed = eTTemp;
      }
      if(eTUsed == allCharacters && eTOn != allCharacters) // if the 1st is a character but not the second,  invert them
      {
        indexTemp = indexOn;
        eTTemp = eTOn;
        indexOn = indexUsed;
        eTOn = eTUsed;
        indexUsed = indexTemp;
        eTUsed = eTTemp;
      }
      
      if(eTUsed == allInventoryItems)
      {
        if(!player.HasInventory(inventory[indexUsed]))
        {
          canUse = false;
        }
      } else if (eTUsed == allCharacters)
      {
        if(character[indexUsed].Room != player.Room)
        {
          canUse = false;
        }
      }
          
          
      if(canUse)
      {
        activeElementToUse_ElementType = etToString(eTUsed);
        activeElementToUse_Index = indexUsed;

        switch(eTOn)
        {
          case roomObjects:
            if(isCharacterNearObject(object[indexOn], reachDistance, player))
            {
              object[indexOn].RunInteraction(eModeUseinv);
            } else {
              player.Think(String.Format("I need to get closer to the %s to use my %s on it", object[indexOn].Name.LowerCase(), inventory[indexUsed].Name.LowerCase()));
            }              
            break;
          case roomHotspots:
            if(isCharacterNearHotspot(hotspot[indexOn], reachDistance, player))
            {
              hotspot[indexOn].RunInteraction(eModeUseinv);
            } else {
              player.Think(String.Format("I need to get closer to the %s to use my %s on it", hotspot[indexOn].Name.LowerCase(), inventory[indexUsed].Name.LowerCase()));
            }
            break;
          case allCharacters:
            if(character[indexOn].Room == player.Room && isCharacterNearCharacter(character[indexOn], reachDistance, player))
            {
              character[indexOn].RunInteraction(eModeUseinv);
            } else {
              player.Think(String.Format("I need to get closer to %s to use my %s on them", hotspot[indexOn].Name.LowerCase(), inventory[indexUsed].Name.LowerCase()));
            }
            break;
          case allInventoryItems:
            if(player.HasInventory(inventory[indexOn]))
            {
              inventory[indexOn].RunInteraction(eModeUseinv);
            } else {
              player.Think("I am not sure what you want me to use");
            }
            break;
          default:
            break;
        }
      } else {
        player.Think("I am not sure what you want me to use");
      }
    }
  }
}

// called on every game cycle, except when the game is blocked
function repeatedly_execute()
{
  currentTime = currentTime + currentTimeIncrementPerLoop;
  if(currentTime > (loopPerSecond*86400)) {
    currentTime = currentTime - (loopPerSecond*86400);
  }
  if(timeUITransparency < 200.0)
  {
    timeUITransparency = timeUITransparency + timeUIFadeSpeed;
    lblCurrentThought.Transparency = FloatToInt(timeUITransparency/2.0, eRoundDown);
    if(lblNoteDescriptionHighlight.Transparency < 100)
    {
      lblNoteDescriptionHighlight.Transparency = lblNoteDescriptionHighlight.Transparency + 1;
    }
  }
  
  //isThisPlaceClosingOnThePlayer(currentCommerceType, 
  
}

// called on every game cycle, even when the game is blocked
function repeatedly_execute_always()
{
  if(cHarkersBeard.Transparency < 100 && cHarker.GetProperty("sitting") == -1) // in REAlways,  becase we want it to continue even when a 'eBlock' animation is running
  {
    cHarkersBeard.FaceDirection(cHarker.Loop);
  }
}

// called when a key is pressed
function on_key_press(eKeyCode keycode, int mod)
{
  // check for Escape first, so it can be used on GUIs that pause the game
  if (keycode == eKeyEscape)
  {
    if (gRestart.Visible)
    {
      // Escape will cancel a restart
      close_gui(gRestart);
    }
    else if (gPanel.Visible)
    {
      // Escape will turn the panel off
      close_gui(gPanel);
    }
    else if (gSaveGame.Visible)
    {
      // Escape will close the save game dialog
      close_gui(gSaveGame);
    }
    else if (gRestoreGame.Visible)
    {
      // Escape will close the restore game dialog
      close_gui(gRestoreGame);
    }
    else if (gInventory.Visible)
    {
      // Escape will close the restore game dialog
      close_gui(gInventory);
    }
    else if (gExitGame.Visible)
    {
      // Escape will cancel exiting the game
      close_gui(gExitGame);
    }
    else if (gParser.Visible) {
      // Escape will cancel the text parser
      close_gui(gParser);
    }
    else if (gWait.Visible) {
      // Escape will close the GUI
      close_gui(gWait);
    }
    else if (gClassify.Visible) {
      // Escape will close the GUI
      close_gui(gClassify);
      show_inventory_window();
    }
    else if (gNotebook.Visible) {
      // Escape will close the GUI
      close_gui(gNotebook);
      closeNotebookThoughts();
    }
    else
    {
      // Escape will turn the panel on
      open_gui(gPanel);
    }
  }
  else if (keycode == eKeyF4)
  {
    if(lblCurrentThought.Transparency < 100)
    {
      if(gParser.Visible) {
        tbParser.Text = tbParser.Text.Append(lblCurrentThought.Text);
      } else if (gSimpleTextbox.Visible) {
        tbSimpleTextbox.Text = tbSimpleTextbox.Text.Append(lblCurrentThought.Text);
      }
    }
  }
  else if (IsGamePaused() || !IsInterfaceEnabled())
  {
    // game paused, so don't react to any keypresses
    keycode = 0;
  }
  else if (keycode == eKeyQ && (mod & eKeyModCtrl))
  {
    // Ctrl-Q will quit the game
    open_gui(gExitGame);
  }
  else if (keycode == eKeyF5)
  {
    // F5 will prompt to save a game
    show_save_game_dialog();
  }
  else if (keycode == eKeyF7)
  {
    // F7 will prompt to save a game
    show_restore_game_dialog();
  }
  else if (keycode == eKeyF9)
  {
    // F9 will prompt to restart the game
    open_gui(gRestart);
  }
  else if (keycode == eKeyF12)
  {
    // F12 will save a screenshot to the save game folder
    SaveScreenShot("screenshot.pcx");
  }
  else if (keycode >= 65 && keycode <= 90)
  {
    open_gui(gParser);
    //debugDisplay(String.Format("%d", keycode));
    tbParser.Text = keycodeToString(keycode);
  }
  else if (keycode == eKeyF3)
  {
    open_gui(gParser);
    //debugDisplay(keycodeToString(keycode));
    tbParser.Text = lastCMD;
  }
  else if (keycode == eKeyTab)
  {
    // Tab opens the inventory
    show_inventory_window();
  }
  else if (mod & eKeyModCtrl)
  {
    if (keycode == eKeyS)
    {
      // Ctrl-S will give the player all defined inventory items
      Debug(0, 0);
    }
    else if (keycode == eKeyV)
    {
      // Ctrl-V will show game engine version and build date
      Debug(1, 0);
    }
    else if (keycode == eKeyA)
    {
      // Ctrl-A will show walkable areas
      Debug(2, 3);
    }
    else if (keycode == eKeyX)
    {
      // Ctrl-X will let the player teleport to any room
      Debug(3, 0);
    }
  }
}



// called when a mouse button is clicked
function on_mouse_click(MouseButton button)
{
  // called when a mouse button is clicked. button is either LEFT or RIGHT
  if (IsGamePaused())
  {
    
    // game is paused, so do nothing (i.e. don't process mouse clicks)
  }
  else if (button == eMouseLeft)
  {
    // left-click, so try using the current mouse cursor mode at this position
    //Room.ProcessClick(mouse.x, mouse.y, mouse.Mode );
    if(player.GetProperty("sitting") == -1)
    {
      player.Walk(mouse.x + Game.Camera.X, mouse.y + Game.Camera.Y, eNoBlock, eWalkableAreas);
    } else {
      int destX = mouse.x + Game.Camera.X;
      int destY = mouse.y + Game.Camera.Y;
      standUp(player, 1);
      player.Walk(destX, destY, eNoBlock, eWalkableAreas);
    }
  }
}

// triggered when the Inventory button from the gQuickInventory is clicked
function btnIconInv_Click(GUIControl *control, MouseButton button)
{
  show_inventory_window();
}

//START OF CONTROL PANEL FUNCTIONS
function btnSave_OnClick(GUIControl *control, MouseButton button)
{
  close_owning_gui(control);
  playConfirm();
  show_save_game_dialog();
}

function btnAbout_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  Display("%s[AGS %s", Game.Name, System.Version);
}

function btnQuit_OnClick(GUIControl *control, MouseButton button)
{
  close_owning_gui(control);
  playSelect();
  open_gui(gExitGame);
}

function btnLoad_OnClick(GUIControl *control, MouseButton button)
{
  close_owning_gui(control);
  playConfirm();
  show_restore_game_dialog();
}

function sldAudio_OnChange(GUIControl *control)
{
  System.Volume = sldAudio.Value;
}

function btnDefault_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  set_default_options();
}

function sldSpeed_OnChange(GUIControl *control)
{
  SetGameSpeed(sldSpeed.Value);
}

function btnRestart_OnClick(GUIControl *control, MouseButton button)
{
  playConfirm();
  close_owning_gui(control);
  open_gui(gRestart);
}

function btnRestartYes_OnClick(GUIControl *control, MouseButton button)
{
  playConfirm();
  RestartGame();
}

int find_save_slot(String name)
{
  bool slots[] = new bool[999];
  int i = 0;

  while (i < lstSaveGamesList.ItemCount)
  {
    if (lstSaveGamesList.Items[i] == name)
    {
      // found existing save with matching name
      return lstSaveGamesList.SaveGameSlots[i];
    }

    // remember which slots are already taken
    slots[lstSaveGamesList.SaveGameSlots[i]] = true;
    i ++;
  }

  // find first free save slot, starting with slot 1
  i = 1;

  while (i < 999)
  {
    if (!slots[i])
    {
      return i;
    }

    i ++;
  }

  // no free slots found
  return -1;
}

function btnSaveGame_OnClick(GUIControl *control, MouseButton button)
{
  int gameSlotToSaveInto = find_save_slot(txtNewSaveName.Text);
  playSelect();
  if (gameSlotToSaveInto < 0)
  {
    Display("No more free save slots!");
  }
  else
  {
    SaveGameSlot(gameSlotToSaveInto, txtNewSaveName.Text);
    close_owning_gui(control);
  }
}

function btnRestoreGame_OnClick(GUIControl *control, MouseButton button)
{
  close_gui(gPanel);
  playSelect();
  if (lstRestoreGamesList.SelectedIndex >= 0)
  {
    RestoreGameSlot(lstRestoreGamesList.SaveGameSlots[lstRestoreGamesList.SelectedIndex]);
  }
  
  close_owning_gui(control);
  
}

function lstSaveGamesList_OnSelectionCh(GUIControl *control)
{
  playSelect();
  txtNewSaveName.Text = lstSaveGamesList.Items[lstSaveGamesList.SelectedIndex];
}

function txtNewSaveName_OnActivate(GUIControl *control)
{
  // pressing Return in the text box simulates clicking the save button
  btnSaveGame_OnClick(control, eMouseLeft);
}

function btnDeleteSave_OnClick(GUIControl *control, MouseButton button)
{
  if (lstSaveGamesList.SelectedIndex >= 0)
  {
    playConfirm();
    DeleteSaveSlot(lstSaveGamesList.SaveGameSlots[lstSaveGamesList.SelectedIndex]);
    lstSaveGamesList.FillSaveGameList();
  }
}

function btnConfirmedQuit_OnClick(GUIControl *control, MouseButton button)
{
  playConfirm();
  QuitGame(0);
}

function lbInventory_OnSelectionChanged(GUIControl *control)
{
  String itemName = lbInventory.Items[lbInventory.SelectedIndex];
  playSelect();
  lbInventory_Selector_adapt(itemName);
}

function btnToggleHints_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  if(showHints)
  {
    lblOverHotspot.Visible = false;
    lblOverHotspot.Text = "";
    btnToggleHints.Text = "Hints hidden";
    showHints = false;
  } else {
    lblOverHotspot.Text = "@OVERHOTSPOT@";
    lblOverHotspot.Visible = true;
    btnToggleHints.Text = "Hints shown";
    showHints = true;
  }
}

function tbParser_OnActivate(GUIControl *control) // function that calls the room function 'on call' with index '1' (to start the text parsing)
{
  //PRESS ENTER
  playSelect();
  if(gParser.Visible) {
    String cmd = tbParser.Text;
    lastCMD = cmd;
    //debugDisplay(String.Format("lastCMD = %s", lastCMD));
    CallRoomScript (1);
  }
}

function lbVerbs_OnSelectionChanged(GUIControl *control)
{
  playSelect();
  lblHelpVerbDesc.Text = verbDescriptionDictionary.Get(lbVerbs.Items[lbVerbs.SelectedIndex]);
}

function btnHelpPanel_OnClick(GUIControl *control, MouseButton button)
{
  playConfirm();
  open_gui(gHelp);
  close_gui(gPanel);
}

function btnHelpResume_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  close_gui(gHelp);
  open_gui(gPanel);
}

function btnConfirmCancel_OnClick(GUIControl *control, MouseButton button)
{
  playCancel();
  close_gui(gConfirm);
}

function btnDelete_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  open_gui(gConfirm);
}

function btnLoadAtStart_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  show_restore_game_dialog();
}

function btnToggleHintsTitleMenu_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  if(showHints)
  {
    lblOverHotspot.Visible = false;
    lblOverHotspot.Text = "";
    btnToggleHints.Text = "Hints hidden";
    btnToggleHintsTitleMenu.Text = "Hints hidden";
    showHints = false;
  } else {
    lblOverHotspot.Text = "@OVERHOTSPOT@";
    lblOverHotspot.Visible = true;
    btnToggleHints.Text = "Hints shown";
    btnToggleHintsTitleMenu.Text = "Hints shown";
    showHints = true;
  }
}

//##### SCRIPTED CUTSCENES #####
function setStoryBeat(storyBeat newStoryBeat)
{
  CurrentStoryBeat = newStoryBeat;
}

storyBeat getStoryBeat()
{
  return CurrentStoryBeat;
}

function triggerCutscene(cutsceneIndex index)
{
  
  if(!skipAllCutscene)
  {
    switch(index)
    {
      case beginQuest:
        setStoryBeat(startYourDay);
        setOpeningAndClosingTimes();
        setCurrentZone(JonathanApt);
        lastMealTime = translateTimeToMinutes(translateTimeToHHMMAM(8, 0, "AM")) + (currentDay * 24 * 60);
        setupTravelDestinations();
        addTravelDestination(JonathanApt);
        addTravelDestination(HawkinsOffices);
        object[10].Visible = false; // open bedroom door;
        player.Transparency = 50;
        cHarkersBeard.Transparency = 90;
        Wait(10);
        player.Transparency = 0;
        cHarkersBeard.Transparency = 85;
        player.Walk(54, 170, eBlock, eAnywhere);
        player.FaceDirection(eDirectionLeft, eBlock);
        Wait(5);
        object[10].Visible = true; // close bedroom door;
        Wait(5);
        player.FaceDirection(eDirectionRight, eBlock);
        player.Think("What a night...");
        player.Think("I must have worked on those contracts until 3 AM");
        player.Think("I hope Mr. Hawkins will be happy with them");
        player.Think("I guess I should hurry if I want to make it to work before 10 AM");
        //player.Walk(158, 169, eBlock, eAnywhere);
        player.PlaceOnWalkableArea();
        player.FaceDirection(eDirectionDown);
        break;
      case getToWork:
        cHawkins.Say("Ah! Harker!");
        cHarker.FaceCharacter(cHawkins);
        if(isItBeforeThisTime(10, 00, 00, false, 1))
        {
          cHawkins.Say("Good you are on time!");
          giveScoreOnce("atWorkOnSchedule", 1);
        } else {
          cHawkins.Say("%s![You are late, young man");
          giveScoreOnce("atWorkOnSchedule", -1);
        }
        if(cHarkersBeard.Transparency == 100)
        {
          giveScoreOnce("shavedHarker", 1);
        } else {
          cHawkins.Say("I would appreciate a clean shaven clerk");
          cHawkins.Say("You are not presentable");
          giveScoreOnce("shavedHarker", -1);
          cHawkins.Say("Anyway.");
        }
        cHawkins.Say("I trust you brought back the contracts from last night");
        cHawkins.Say("Come to my office");
        cHawkins.Walk(object[43].X, object[43].Y, eBlock, eWalkableAreas);
        sit(roomObjects, 43, cHawkins, 4, false);
        break;
      case arriveInLondon:
        player.Say(String.Format(whatTimeIsIt(true)));
        player.Say("Right on time");
        player.Say("I have Mr. Hawkins' reservation at the hotel in Covent Garden, the Hummums");
        addTravelDestination(LondonHotel);
        player.Say(String.Format("I need to find my way to Purfleet too, to that %s property", proposedSeller));
        setStoryBeat(HarkerinLondon);
        break;
      case arriveInPurfleet:
        carfaxSeller = createHawkinsPropertyFile("Random", "London", "East", 764); 
        hotspot[1].SetTextProperty("TextDescription", String.Format("This is a 'For Sale' sign. It says to contact a certain %s, I could send them a telegram...", carfaxSeller));
        addPlannedTelegram(carfaxSeller, "Carfax,Seller", String.Format("Edward %s, in Norwich", carfaxSeller), "Interested in buying Carfax property in Purfleet STOP Please confirm conditions");
        cHorse1.Say("NEIGH!");
        Wait(40);
        cCabby.Say("Oh my...");
        break;     
      default:
        debugDisplay(String.Format("Cutscene %d is supposed to start but it is not handled by the 'triggerCutscene' function", index));
        break;
    }
  }
  else
  {
    switch(index) // things to do if the cutscene is skipped
    {
      case beginQuest:
        setStoryBeat(startYourDay);
        setCurrentZone(JonathanApt);
        setupTravelDestinations();
        lastMealTime = translateTimeToMinutes(translateTimeToHHMMAM(8, 0, "AM")) + (currentDay * 24 * 60);
        addTravelDestination(HawkinsOffices);
        player.x = 158;
        player.y = 169;
        cHarkersBeard.x = player.x;
        cHarkersBeard.y = player.y;
        player.Transparency = 0;
        cHarkersBeard.Transparency = 85;        
        break;
      default:
        break;
    }
  }
}

function btnNewGame_OnClick(GUIControl *control, MouseButton button)
{
  playConfirm();
  FadeOut(10);
  close_gui(gStartHelp);
  Wait(20);
  gQuickInventory.Visible = true;
  gStatusline.Visible = true;
  player.ChangeRoom(1);
  Wait(10);
  
}

//##### IN-GAME INTERACTIONS ######

function cHarker_UseInv()
{
  int shavingGlassObjectIndex = findRoomObjectIndexByName("shaving glass");
  
  //debugDisplay(String.Format("%s[%d", activeElementToUse_ElementType, activeElementToUse_Index));
  
  if(activeElementToUse_ElementType == "allInventoryItems" && activeElementToUse_Index == 3)//razor
  {
    if(cHarkersBeard.Transparency == 100)
    {
      player.Think("I do not need to shave");
    } else if(shavingGlassObjectIndex == -1)
    {
      player.Think("I cannot shave here");
    } else if(!object[shavingGlassObjectIndex].Visible && player.HasInventory(iMirror))
    {
      player.Think("I need to install my shaving glass first");
      player.FaceObject(object[shavingGlassObjectIndex]);
      player.Think("There seems to be an appropriate surface over there");
    } else if(object[shavingGlassObjectIndex].Visible && !isCharacterNearObject(object[shavingGlassObjectIndex], reachDistance, player))
    {
      player.FaceObject(object[shavingGlassObjectIndex]);
      player.Think(String.Format("I need to get closer to the %s", object[shavingGlassObjectIndex].Name));
    } else
    {
      player.FaceObject(object[shavingGlassObjectIndex]);
      cHarkersBeard.Transparency = 100;
      player.Think("Ah, prefectly smooth");
      giveScoreOnce("perfect shave", 1);
    }
  }
}

function iLegalPapers_UseInv()
{
  //Rendu ici
}

function iFolder_UseInv()
{
  //do nothing
}

function iLedger_Interact()
{
  readThis(iLedger.GetTextProperty("ReadDisplay"), "¶");
}

function confirmSimpleTextbox()
{
  String textInput = tbSimpleTextbox.Text;
  
  close_gui(gSimpleTextbox);
  
  switch(lblSimpleTextbox.Text)
  {
    case "Seller's name":
      proposedSeller = textInput;
      CallRoomScript(3);
      break;
    case "Telegram recipient":
      handleTelegramRecipient(textInput);
      break;
    default:
      break;
  }
}

function tbSimpleTextbox_OnActivate(GUIControl *control)
{
  confirmSimpleTextbox();
}

String getBookPage(String noteContent, String breakageCharacter, String reunitingCharacter,  Label* thisLbl, Label* pageNumberLbl, int thePage, Button* btnBack, Button* btnNext)
{
  Dictionary* eachPage = Dictionary.Create(eSorted);
  Dictionary* eachWord = Dictionary.Create(eSorted);
  String eachWord_strings[];
  String eachPage_strings[];
  String workingString = noteContent;
  String currentWord;
  bool fullLbl = false;
  int i = 0;
  btnBack.Visible = false;
  btnNext.Visible = false;
  
  //debugDisplay(String.Format("noteContent : %s", noteContent));
  
  if(GetTextHeight(noteContent, eFontNormal, thisLbl.Width) <= thisLbl.Height)
  {
    pageNumberLbl.Text = "";
    return noteContent;
  } else
  {
    eachWord.Clear();
    //Separate into words
    while(workingString.IndexOf(breakageCharacter) != -1)
    {
      currentWord = workingString.Truncate(workingString.IndexOf(breakageCharacter));
      eachWord.Set(String.Format("%05d", i), currentWord.Replace(breakageCharacter, "", eCaseInsensitive));
      i++;
      workingString = removeOneStringInstance(workingString, currentWord);
      
      if(workingString.StartsWith(breakageCharacter)){
        workingString = removeOneStringInstance(workingString, breakageCharacter);
      }
    }
    eachWord.Set(String.Format("%05d", i), workingString);
    
    eachWord_strings = eachWord.GetValuesAsArray();
    
    //Add words until lbl is full
    workingString = "";
    for(i = 0 ; i < eachWord.ItemCount ; i++)
    {
      if(GetTextHeight(String.Format("%s %s", workingString, eachWord_strings[i]), eFontNormal, thisLbl.Width) > thisLbl.Height)
      {
        eachPage.Set(String.Format("%05d", i), workingString);
        workingString = eachWord_strings[i];
      } else
      {
        workingString = workingString.Append(reunitingCharacter);
        workingString = workingString.Append(eachWord_strings[i]);
      }
    }
    eachPage.Set(String.Format("%05d", i), workingString);
    
    //find correct page content
    eachPage_strings = eachPage.GetValuesAsArray();
    if(thePage > eachPage.ItemCount)
    {
      workingString = "";
    } else 
    {
      workingString = eachPage_strings[thePage - 1];
      if(workingString.StartsWith(reunitingCharacter))
      {
        workingString = removeOneStringInstance(workingString, reunitingCharacter);
      }
    }
    
    //page number
    pageNumberLbl.Text = String.Format("Page %d/%d", thePage, eachPage.ItemCount);
    
    //show arrows
    if(thePage > 1)
    {
      btnBack.Visible = true;
    } else
    {
      btnBack.Visible = false;
    }
    
    if(eachPage.ItemCount > thePage)
    {
      btnNext.Visible = true;
    } else
    {
      btnNext.Visible = false;
    }
    
    return workingString;
  }
}

function updateNotebook()
{
  lbNoteTitles.Clear();
  String notesToAdd[] = notes.GetKeysAsArray();
  int i;
  
  for(i = 0 ; i < notes.ItemCount ; i++)
  {
    lbNoteTitles.AddItem(notesToAdd[i]);
  }
  
  lbNoteTitles.SelectedIndex = 0;
  lblNoteDescription.Text = getBookPage(notes.Get(lbNoteTitles.Items[lbNoteTitles.SelectedIndex]), " ", " ", lblNoteDescription, lblNote_pgNb, 1, btnNotebook_prev, btnNotebook_next);
  btnDeleteNote.Enabled = (notes.ItemCount > 1); // must have at least 2 entries to remove one.  
}

function btnConfirmYes_OnClick(GUIControl *control, MouseButton button)
{
  playConfirm();
  if(gNotebook.Visible) // delete note
  {
    String noteTitle = lbNoteTitles.Items[lbNoteTitles.SelectedIndex];
    notes.Remove(noteTitle);
    lbNoteTitles.RemoveItem(lbNoteTitles.SelectedIndex);
    lbNoteTitles.SelectedIndex = 0;
    noteTitle = lbNoteTitles.Items[lbNoteTitles.SelectedIndex];
    lblNoteDescription.Text = getBookPage(notes.Get(noteTitle), " ", " ", lblNoteDescription, lblNote_pgNb, 1, btnNotebook_prev, btnNotebook_next);
    hasRead(noteTitle);
    btnDeleteNote.Enabled = (lbNoteTitles.ItemCount > 1); // must have at least 2 entries to remove one.
  }
  close_gui(gConfirm);
}

function btnNoteBook_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  updateNotebook();
  open_gui(gNotebook);
}

function btnResume_notebook_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  close_gui(gNotebook);
  closeNotebookThoughts();
}

int parseCurrentPage(Label* thisLabel)
{
  String workString = thisLabel.Text;
  workString = workString.Substring(workString.IndexOf(" "), workString.Length - workString.IndexOf("/"));
  
  return workString.AsInt;
}

int parseLastPage(Label* thisLabel)
{
  String workString = thisLabel.Text;
  workString = workString.Substring(workString.IndexOf("/") + 1, workString.Length - workString.IndexOf("/") + 1);
  
  return workString.AsInt;
}

function btnNotebook_next_OnClick(GUIControl *control, MouseButton button)
{
  int targetPage = parseCurrentPage(lblNote_pgNb) + 1;
  String selectedNoteTitle = lbNoteTitles.Items[lbNoteTitles.SelectedIndex];
  lblNoteDescription.Text = getBookPage(notes.Get(selectedNoteTitle), " ", " ", lblNoteDescription, lblNote_pgNb, targetPage, btnNotebook_prev, btnNotebook_next);
}

function btnNotebook_prev_OnClick(GUIControl *control, MouseButton button)
{
  int targetPage = parseCurrentPage(lblNote_pgNb) - 1;
  String selectedNoteTitle = lbNoteTitles.Items[lbNoteTitles.SelectedIndex];
  lblNoteDescription.Text = getBookPage(notes.Get(selectedNoteTitle), " ", " ", lblNoteDescription, lblNote_pgNb, targetPage, btnNotebook_prev, btnNotebook_next);
}

function lbNoteTitles_OnSelectionChanged(GUIControl *control)
{
  String noteTitle = lbNoteTitles.Items[lbNoteTitles.SelectedIndex];
  lblNoteDescription.Text = getBookPage(notes.Get(noteTitle), " ", " ", lblNoteDescription, lblNote_pgNb, 1, btnNotebook_prev, btnNotebook_next);
  hasRead(noteTitle);
}

function writeBookPages(String bookText, int leftPageNumber)
{
  LblBook_left.Text = getBookPage(bookText, "¶", "[", LblBook_left, lblBook_pgNbLeft, leftPageNumber, btnBookPrev, btnBookNext);
  if(parseLastPage(lblBook_pgNbLeft) + 1 > leftPageNumber)
  {
    LblBook_right.Text = getBookPage(bookText, "¶", "[", LblBook_right, lblBook_pgNbRight, leftPageNumber + 1, btnBookPrev, btnBookNext);
  } else
  {
    LblBook_right.Text = "";
  }
  
  if(leftPageNumber == 1)
  {
    btnBookPrev.Visible = false;
  } else
  {
    btnBookPrev.Visible = true;
  }
  if(parseLastPage(lblBook_pgNbLeft) == leftPageNumber + 1)
  {
    btnBookNext.Visible = false;
  } else
  {
    btnBookNext.Visible = true;
  }
}

function createBook(String bookTitle, String bookText, bool addToPlayerInventory)
{
  books_description.Set(bookTitle, bookText);
  if(addToPlayerInventory)
  {
    books_notes.Set(bookTitle, " ");
  } else
  {
    books_notes.Set(bookTitle, "Not in inventory");
  }
}

String findBookTextFromTitle(String bookTitle)
{
  if(books_description.Contains(bookTitle))
  {
    return books_description.Get(bookTitle);
  } else
  {
    debugDisplay(String.Format("%s is not in the book list", bookTitle));
  }
}

function show_book_gui(String bookTitle)
{
  writeBookPages(findBookTextFromTitle(bookTitle), 1);
  lblBookTitle.Text = bookTitle;
  open_gui(gBook);
}

function btnLedgerPrev_OnClick(GUIControl *control, MouseButton button)
{
  String bookTitle = lblBookTitle.Text;
  int leftPageNumber = parseCurrentPage(lblBook_pgNbLeft);
  if(leftPageNumber - 2 < 1)
  {
    writeBookPages(findBookTextFromTitle(bookTitle), 1);
  } else
  {
    writeBookPages(findBookTextFromTitle(bookTitle), leftPageNumber - 2);
  }
}

function btnLedgerNext_OnClick(GUIControl *control, MouseButton button)
{
  String bookTitle = lblBookTitle.Text;
  int rightPageNumber = parseCurrentPage(lblBook_pgNbRight);
  writeBookPages(findBookTextFromTitle(bookTitle), rightPageNumber + 1);
}

function highlightWord(String word, GUIControl *originalTextLabel, GUIControl *highlighterLbl, int startX,  int startY)
{
  highlighterLbl.Transparency = 100;
  highlighterLbl.Visible = true;
  highlighterLbl.ZOrder = originalTextLabel.ZOrder + 1;
 debugDisplay(word);
  if(startX == 0)
  {
    highlighterLbl.X = startX + originalTextLabel.X;// + originalTextLabel.OwningGUI.X;
  } else {
    highlighterLbl.X = startX + originalTextLabel.X + GetTextWidth(" ", eFontNormal);
  }
  highlighterLbl.Y = startY + originalTextLabel.Y;// + originalTextLabel.OwningGUI.Y;
  highlighterLbl.AsLabel.Text = word;
  highlighterLbl.Width = GetTextWidth(word, eFontNormal) * 2;
  highlighterLbl.Height = GetTextHeight(word, eFontNormal, highlighterLbl.Width);
  highlighterLbl.Transparency = 0;
  memorize(word);
}

String findThatWord(GUIControl* labelName, Label* highlightLbl, int clickX, int clickY)
{
  Dictionary* eachWord = Dictionary.Create(eSorted);
  int counter = 0;
  
  String FullText = labelName.AsLabel.Text;
  int lblWidth = labelName.AsLabel.Width;
  
  int spaceIndex = 1000;
  int alineaIndex = 1000;
  int nextCut = 1000;
  String nextCutChar = "";
  
  String thatString = FullText;
  String returnWord;
  
  while(FullText.IndexOf(" ") != -1 || FullText.IndexOf("[") != -1)
  {
    nextCut = 1000;
    nextCutChar = "";
    
    spaceIndex = FullText.IndexOf(" ");
    if(spaceIndex == -1) {
      spaceIndex = 1000;
    } else if (spaceIndex < nextCut) {
      nextCut = spaceIndex;
      nextCutChar = " ";
    }
    alineaIndex = FullText.IndexOf("[");
    if(alineaIndex == -1) {
      alineaIndex = 1000;
    } else if (alineaIndex < nextCut) {
      nextCut = alineaIndex;
      nextCutChar = "[";
    }     
    
    thatString = FullText.Truncate(nextCut);
    thatString = thatString.Replace(" ", "", eCaseInsensitive);
    thatString = thatString.Replace("[", "", eCaseInsensitive);
    eachWord.Set(String.Format("%05d", counter), thatString);
    FullText = removeOneStringInstance(FullText, thatString.Append(nextCutChar));
    counter++;
  }
  eachWord.Set(String.Format("%05d", counter), FullText);
  
  String eachWordArray[] = eachWord.GetValuesAsArray();
  
  thatString = eachWordArray[0];
  int startX = 0;
  int endX = GetTextWidth(thatString, eFontNormal);
  int startY = 0;
  int endY = GetTextHeight(thatString, eFontNormal, lblWidth);
  int newY = GetTextHeight(thatString, eFontNormal, lblWidth);
  int i = 0;
  
  while((i < eachWord.ItemCount - 1) &&
        ((clickX < startX ||
         clickX > endX) ||
        (clickY < startY ||
         clickY > endY)))
  {
    i++;
    thatString = thatString.Append(" ");
    thatString = thatString.Append(eachWordArray[i]);
    newY = GetTextHeight(thatString, eFontNormal, lblWidth);
    if(newY != endY)
    {
      startX = 0;
      endX = GetTextWidth(eachWordArray[i], eFontNormal);
      startY = endY;
      endY = newY;
    } else {
      startX = endX;
      endX = endX + GetTextWidth(eachWordArray[i], eFontNormal) + GetTextWidth(" ", eFontNormal);
    }    
  }
  
  if(i < eachWord.ItemCount) {
    returnWord = eachWordArray[i];
    if(labelName == lblNoteDescription)
    {
      highlightWord(eachWordArray[i], labelName, highlightLbl, startX, startY);
    }
  } else {
    returnWord = "";
  }
  
 debugDisplay(String.Format("ze word: %s", returnWord));
  
  return returnWord;
}

function clickALabel(GUI* thisParentGUI, Label* clickedLabel, Label* highlightLabel)
{
  playSelect();
  int clickX = mouse.x - thisParentGUI.X - clickedLabel.X;
  int clickY = mouse.y - thisParentGUI.Y - clickedLabel.Y;
  
  if(mouse.x > thisParentGUI.X + clickedLabel.X && 
     mouse.x < thisParentGUI.X + clickedLabel.X + clickedLabel.Width &&
     mouse.y > thisParentGUI.Y + clickedLabel.Y &&
     mouse.y < thisParentGUI.Y + clickedLabel.Y + clickedLabel.Height)
  {
    findThatWord(clickedLabel, highlightLabel, clickX, clickY);
  }
  
  /*playSelect();
  int clickX = mouse.x - gNotebook.X - lblNoteDescription.X;
  int clickY = mouse.y - gNotebook.Y - lblNoteDescription.Y;
  
  if(mouse.x > gNotebook.X + lblNoteDescription.X && 
     mouse.x < gNotebook.X + lblNoteDescription.X + lblNoteDescription.Width &&
     mouse.y > gNotebook.Y + lblNoteDescription.Y &&
     mouse.y < gNotebook.Y + lblNoteDescription.Y + lblNoteDescription.Height)
  {
    findThatWord(lblNoteDescription, clickX, clickY);
    //Display(String.Format("Clicked on the text at (%d, %d)", clickX, clickY));
  }*/
}

function btnNoteDescription_OnClick(GUIControl *control, MouseButton button)
{
  clickALabel(gNotebook, lblNoteDescription, lblNoteDescriptionHighlight);
}

function btnSimpeTextboxNotebook_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  open_gui(gNotebook);
}

int whatHourAfterThisPeriod(int nb, String timeType, int currentH, int currentM)
{
  switch(timeType) {
    case "Hours":
      currentH = currentH + nb;
      break;
    case "Minutes":
      currentM = currentM + nb;
      while(currentM >= 60)
      {
        currentM = currentM - 60;
        currentH++;
      }
      break;
    default:
      break;
  }
  while(currentH >= 24)
  {
    currentH = currentH - 24;
  }
  return currentH;
}

int minutesUntilTime(int targetH, String targetAMPM, int currentH, int currentM, String currentAMPM)
{
  if(targetAMPM == "PM") 
  {
    targetH = targetH + 12;
  }
  
  if(currentAMPM == "PM") 
  {
    currentH = currentH + 12;
  }
  
  if(targetH <= currentH)
  {
    targetH = targetH + 24;
  }
  
  targetH = targetH * 60;
  
  currentH = currentH * 60;
  currentH = currentH + currentM;
  
  return targetH - currentH;
}

function btnToggleForUntil_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  String currentBtnText = btnToggleForUntil.Text;
  int showHour = getCurrentHour();
  int showMinutes = getCurrentMinutes();
  String showAMPM = getAMPM();
  int textBoxContent;
  
  if(currentBtnText.EndsWith("for", eCaseInsensitive)) {
    btnToggleForUntil.Text = btnToggleForUntil.Text.Replace("for", "until", eCaseInsensitive);
    btnToggleMinHrs.Text = showAMPM;
  } else {
    btnToggleForUntil.Text = btnToggleForUntil.Text.Replace("until", "for", eCaseInsensitive);
    btnToggleMinHrs.Text = "Minutes";
  }
}

function btnToggleMinHrs_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  String ForUntilBtnText = btnToggleForUntil.Text;
  String MinHrBtnText = btnToggleMinHrs.Text;
  
  if(ForUntilBtnText.EndsWith("for", eCaseInsensitive)) {
    if(MinHrBtnText == "Minutes")
    {
      btnToggleMinHrs.Text = "Hours";
    } else  {
      btnToggleMinHrs.Text = "Minutes";
    }
  } else {
    if(MinHrBtnText == "AM")
    {
      btnToggleMinHrs.Text = "PM";
    } else  {
      btnToggleMinHrs.Text = "AM";
    }
  }
    
}

function applyWait(bool doTheFade)
{
  int showHour = getCurrentHour();
  int showMinutes = getCurrentMinutes();
  String showAMPM = getAMPM();
  String ForUntilBtnText = btnToggleForUntil.Text;
  String MinHrBtnText = btnToggleMinHrs.Text;
  int minutesToAdd;
  
  if(ForUntilBtnText.EndsWith("for"))
  {
    minutesToAdd = tbWaitAmount.Text.AsInt;
    if(MinHrBtnText == "Hours")
    {
      minutesToAdd = minutesToAdd * 60;
    }    
  } else {
    minutesToAdd = minutesUntilTime(tbWaitAmount.Text.AsInt, btnToggleMinHrs.Text, showHour, showMinutes, showAMPM);
  }
  close_gui(gWait);
  
  if(doTheFade)
  {
    FadeOut(3);
    addTime(0, minutesToAdd, 0, 0);
    Wait(40);
    FadeIn(3);
    player.Say(String.Format("Well, it is %s, now", whatTimeIsIt(true)));
  } else
  {
    addTime(0, minutesToAdd, 0, 0);
    Display("Time passes");
    Display(String.Format("It is now %s", whatTimeIsIt(false)));
  }
}

function btnConfirmWait_OnClick(GUIControl *control, MouseButton button)
{
  playConfirm();
  applyWait(Room.GetProperty("FadeForWait"));
}

function btnCancelWait_OnClick(GUIControl *control, MouseButton button)
{
  playCancel();
  close_gui(gWait);
}

function btnInvContext_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  String parentItemName = lbInventory.Items[lbInventory.SelectedIndex];
  close_gui(gInventory);
  openSubinventoryGUI(parentItemName);
}

function btnClassifyBackToInventory_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  close_gui(gClassify);
  show_inventory_window();
}

function lbClassifiable_OnSelectionChanged(GUIControl *control)
{
  playSelect();
  String parentItemName = lblClassifyTitle.Text;
  InventoryItem* parentItem = inventory[findInvItemIndexByName(parentItemName)];
  
  Dictionary* thisParentItemDictionary_desc = getDictionariesForParentItems(parentItem, subitemDescription);
  Dictionary* thisParentItemDictionary_note = getDictionariesForParentItems(parentItem, subitemNote);
  String descDisplayed = thisParentItemDictionary_desc.Get(lbClassifiable.Items[lbClassifiable.SelectedIndex]);
  descDisplayed = descDisplayed.Append("[");
  descDisplayed = descDisplayed.Append(thisParentItemDictionary_note.Get(lbClassifiable.Items[lbClassifiable.SelectedIndex]));
  
  lblClassifyDescription.Text = descDisplayed;
}

function updateDictionaryOrder(Dictionary* thisDict, ListBox* thisLB)
{
  Dictionary* tempDict = Dictionary.Create(eNonSorted);
  String thisDictKeys[];
  int i;
  thisDictKeys = thisDict.GetKeysAsArray();
  
  for(i = 0 ; i < thisDict.ItemCount ; i++)
  {
    tempDict.Set(thisDictKeys[i], thisDict.Get(thisDictKeys[i]));
  }
  
  thisDict.Clear();
  
  for(i = 0 ; i < thisLB.ItemCount ; i++)
  {
    thisDict.Set(thisLB.Items[i], tempDict.Get(thisLB.Items[i]));
  }
}

function changeListBoxOrder(ListBox* thisLB, bool UP, int currentIndex)
{
   String itemName;
   int indexMove = 1;
   if(UP)
   {
     indexMove = -1;     
   }
   
   if(UP && currentIndex > 0 || !UP && currentIndex < thisLB.ItemCount - 1) {
     itemName = thisLB.Items[currentIndex];
     thisLB.RemoveItem(currentIndex);
     thisLB.InsertItemAt(currentIndex + indexMove, itemName);
     thisLB.SelectedIndex = currentIndex + indexMove;
   }
}

function updateClassifyListOrder(bool UP)
{
  String parentItemName = lblClassifyTitle.Text;
  InventoryItem* parentItem = inventory[findInvItemIndexByName(parentItemName)];
  Dictionary* thisParentItemDictionary_desc = getDictionariesForParentItems(parentItem, subitemDescription);
  Dictionary* thisParentItemDictionary_notes = getDictionariesForParentItems(parentItem, subitemNote);
  
  int currentSelection = lbClassifiable.SelectedIndex;
  changeListBoxOrder(lbClassifiable, UP, currentSelection);
  
  updateDictionaryOrder(thisParentItemDictionary_desc, lbClassifiable);
  updateDictionaryOrder(thisParentItemDictionary_notes, lbClassifiable);
}

function btnClassifyUP_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  updateClassifyListOrder(true);
}

function btnClassifyDOWN_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  updateClassifyListOrder(false); 
}

function btnClassifyFILEIT_OnClick(GUIControl *control, MouseButton button)
{
  playConfirm();
  String parentItemName = lblClassifyTitle.Text;
  Set* solution = getClassifySolutionSet(parentItemName);
  InventoryItem* parentItem = inventory[findInvItemIndexByName(parentItemName)];
  ValidateFileIt(lbClassifiable, solution, parentItem, 124, parentItem.GetTextProperty("invContext_classifiedName"), 2);
}

function show_simpleTextBox(String thisTitle)
{
  lblSimpleTextbox.Text = thisTitle;
  tbSimpleTextbox.Text = "";
  open_gui(gSimpleTextbox);
}

function btnSimpleTBConfirm_OnClick(GUIControl *control, MouseButton button)
{
  playConfirm();
  confirmSimpleTextbox();
}

function btnStartGame_OnClick(GUIControl *control, MouseButton button)
{
  playConfirm();
  FadeOut(6);
  close_gui(gSplash);
  Wait(10);
  open_gui(gStartHelp);
  FadeIn(6);
}

function btnGameOver_quit_OnClick(GUIControl *control, MouseButton button)
{
  playConfirm();
  close_gui(gGameOver);
  open_gui(gExitGame);
}

function btnGameOver_restart_OnClick(GUIControl *control, MouseButton button)
{
  playConfirm();
  close_gui(gGameOver);
  open_gui(gRestart);
}

function btnGameOver_restore_OnClick(GUIControl *control, MouseButton button)
{
  playConfirm();
  close_gui(gGameOver);
  show_restore_game_dialog();
}

function lbTrainDepartures_OnSelectionChanged(GUIControl *control)
{
  playSelect();
  adjustTicketDescription(lbTrainDepartures.Items[lbTrainDepartures.SelectedIndex]);
}

function btnTrainTicketCancel_OnClick(GUIControl *control, MouseButton button)
{
  playCancel();
  close_gui(gTrainTickets);
}

function btnBuyTicket_OnClick(GUIControl *control, MouseButton button)
{
  playConfirm();
  String destination = lblTrainTicket_title.Text.Substring(lblTrainTicket_title.Text.IndexOf(" to ") + 4, lblTrainTicket_title.Text.Length - (lblTrainTicket_title.Text.IndexOf(" to ") + 4));
  String time = lbTrainDepartures.Items[lbTrainDepartures.SelectedIndex];
  close_gui(gTrainTickets);
  player.Say(String.Format("A ticket to %s on the %s train, please", destination, time));
  iTicketLondon.SetTextProperty("TextDescription", String.Format("My %s ticket to London", time));
  trainDepartureTime = time;
  player.AddInventory(iTicketLondon);  
}

function btnSubitem_inventory_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  close_gui(gSubitems);
  show_inventory_window();
}

function lbSubtiems_OnSelectionChanged(GUIControl *control)
{
  playSelect();
  String parentItemName = lblSubitem_titles.Text;
  InventoryItem* parentItem = inventory[findInvItemIndexByName(parentItemName)];
  Dictionary* thisParentItemDictionary_desc = getDictionariesForParentItems(parentItem, subitemDescription);
  Dictionary* thisParentItemDictionary_note = getDictionariesForParentItems(parentItem, subitemNote);
  String descDisplayed = thisParentItemDictionary_desc.Get(lbSubtiems.Items[lbSubtiems.SelectedIndex]);
  descDisplayed = descDisplayed.Append("[");
  descDisplayed = descDisplayed.Append(thisParentItemDictionary_note.Get(lbSubtiems.Items[lbSubtiems.SelectedIndex]));
  
  lblSubitemDescription.Text = descDisplayed;
}

bool globalHighjackIndexElementVerb(String stringIndex, String stringElement, String verb)
{
  bool skipRoomInteraction = false;
  int index = stringIndex.AsInt;
  elementType eT = stringToET(stringElement);
  
  if(eT == allInventoryItems && index == 2 && (verb == "read" || verb == "look"))//Ledger
  {
    show_book_gui("Hawkins Ledger");
    skipRoomInteraction = true;
  }
  
  return skipRoomInteraction;
}

String[] roomSpecificParse(String cmd) // function that is called by the room to handle the parsing of the command
{
  String elementName;
  String indexElement[] = new String[2];
  String indexElementVerbHandled[] = new String[4];
  int i;
  indexElementVerbHandled[0] = "Null";
  indexElementVerbHandled[1] = "Null";
  indexElementVerbHandled[2] = "Skip";
  indexElementVerbHandled[3] = "true";
  
  if(cmd.IndexOf("spot ") != -1) {                                                                                         // SPOT KEYWORD
    cmd = cmd.Replace("spot ", "", eCaseInsensitive);
    cmd = cmd.Replace("all ", "", eCaseInsensitive);
    cmd = cmd.Replace("any ", "", eCaseInsensitive);
    findElementContaining(cmd);
  } else if(cmd.LowerCase() == "stand" || cmd.IndexOf("stand ") != -1) {                                                    // STAND KEYWORD
    standUp(player, 1);
  } else if(cmdStartsWithUSEsynonym(cmd) != "Null") {                                                                       // USE KEYWORDS
    useInteraction(cmd);
  } else if(cmd.StartsWith("wait", eCaseInsensitive)) {                                                                     // WAIT KEYWORDS
    show_wait_GUI("wait");    
  } else if(cmd.StartsWith("smoke", eCaseInsensitive) || (cmd.StartsWith("light") && cmd.IndexOf("cigar") != -1)) {                                                                     // SMOKE KEYWORDS
    if(player.HasInventory(iCigars))
    {
      if(player.HasInventory(iMatches))
      {
        player.Think("I can take a few minutes for a cigar");
        FadeOut(5);
        if(player.GetProperty("sitting") == 4 && player.Room == 1) // sitting in sofa
        {
          giveScoreOnce("smoke confortably", 1);
        }
        addTime(0, 5+Random(10), 0, 0);
        FadeIn(5);
        player.Think("Ah, that was satisfying");
      } else{
        player.Think("I need matches to light the cigar");
      }
    } else
    {
      player.Think("I have some cigars at home...");
    }
  } else if(cmd.StartsWith("shave", eCaseInsensitive)) {                                                                    // SHAVE KEYWORD
    if(player.HasInventory(iRazor))
    {
      useInteraction("use razor on myself");
    } else {
      player.Think("I need to find my razor to shave");
    }
  } else if (cmd.StartsWith("Note ", eCaseInsensitive) || cmd.LowerCase() == "note" || cmd.LowerCase() == "take note") {    // NOTE KEYWORD
    takeNote();
  } else if (cmd.IndexOf("look ") != -1 && cmd.IndexOf(" room") != -1)
  {
    player.Think(Room.GetTextProperty("TextDescription"));
  } else if (cmd.IndexOf("What time is it") != -1)
  {
    if(player.HasInventory(iWatch))
    {
      player.Think(String.Format("It is %s", whatTimeIsIt(true)));
    } else {
      player.Think("I do not have my watch... I do not know what time it is...");
    }
  } else if (cmd.StartsWith("Eat") || cmd.StartsWith("Consume"))
  {
    cmd.Replace("Eat ", "", eCaseInsensitive);
    cmd.Replace("Consume ", "", eCaseInsensitive);
    eatFood(cmd);
  } else if ((cmd.StartsWith("Put") || cmd.StartsWith("Insert") || cmd.StartsWith("Move")) &&                                 //MOVE PHOTOS TO DOSSIER
             (cmd.IndexOf("Carfax") != -1 || cmd.IndexOf("Photo") != -1 || cmd.IndexOf("Picture") != -1) &&
             (cmd.IndexOf("Sale") != -1 || cmd.IndexOf("Dossier") != -1 || cmd.IndexOf("Contract") != -1))
  {
    if(player.HasInventory(iSalesDossier))
    {
      if(cmd.IndexOf("Dining") != -1)
      {
        if(playerHasSubitem("Carfax's Dining", iPhotos))
        {
          transfertSubitemFromOneParentToAnother(iPhotos, iSalesDossier, "Carfax's Dining", true);
          player.Say("I put the dining room picture in the sales dossier");
        } else
        {
          player.Say("I do not have a picture of the dining room");
        }
      } else if(cmd.IndexOf("Living") != -1)
      {
        if(playerHasSubitem("Carfax's Living", iPhotos))
        {
          transfertSubitemFromOneParentToAnother(iPhotos, iSalesDossier, "Carfax's Living", true);
          player.Say("I put the living room picture in the sales dossier");
        } else
        {
          player.Say("I do not have a picture of the living room");
        }
      } else if(cmd.IndexOf("Kitchen") != -1)
      {
        if(playerHasSubitem("Carfax's Kitchen", iPhotos))
        {
          transfertSubitemFromOneParentToAnother(iPhotos, iSalesDossier, "Carfax's Kitchen", true);
          player.Say("I put the kitchen picture in the sales dossier");
        } else
        {
          player.Say("I do not have a picture of the kitchen");
        }
      } else if(cmd.IndexOf("Bedroom") != -1)
      {
        if(playerHasSubitem("Carfax's Bedroom", iPhotos))
        {
          transfertSubitemFromOneParentToAnother(iPhotos, iSalesDossier, "Carfax's Bedroom", true);
          player.Say("I put the bedroom picture in the sales dossier");
        } else
        {
          player.Say("I do not have a picture of the bedroom");
        }
      } else
      {
        player.Say("I do not think this goes in the sales dossier");
      }
    } else
    {
      player.Say("I am not sure what to do");
    }
  } else if (cmd.StartsWith("debug") && debugTools) 
  {                                                                                                         //DEBUG
              if(cmd.IndexOf("Purfleet") != -1){//GO TO PURFLEET
                player.ChangeRoom(6, 116, 187);
              } else if (cmd.IndexOf("Waterloo") != -1)//GO TO WATERLOO
              {
                player.ChangeRoom(5, arrival_x[5], arrival_y[5]);
                setCurrentZone(LondonTrainStation);
                addTravelDestination(LondonHotel);
                player.AddInventory(iNotebook);
                player.AddInventory(iCamera);
                player.AddInventory(iPenInk);
                btnNoteBook.Visible = true;
                proposedSeller = "A";
              } else if (cmd.IndexOf("packyourthings") != -1)
              {
                CurrentStoryBeat = packYourThings;
                debugDisplay("Story beat set to packYourThings");
              } else if (cmd.IndexOf("getnotebook") != -1)
              {
                player.AddInventory(iNotebook);
                btnNoteBook.Visible = true;
                notableSay(player, "Long string", "DEBUT This is a very long string of text, This is a very long string of text. This is a very long string of text, This is a very long string of text. This is a very long string of text, This is a very long string of text. This is a very long string of text, This is a very long string of text. This is a very long string of text, This is a very long string of text. This is a very long string of text, This is a very long string of text. FIN boo", 0); 
              }
              for(i = 0 ; i < Game.InventoryItemCount ; i++)
              {
                if(cmd.IndexOf(inventory[i].Name) != -1 && !player.HasInventory(inventory[i]))
                {
                  player.AddInventory(inventory[i]);
                } 
              } 
              if(cmd.IndexOf("HawkinsKit") != -1) {
                player.AddInventory(iLegalPapers);
                player.AddInventory(iNotebook);
                player.ChangeRoom(2);
              }
  } else
  {
    indexElement = findElementIndexByName(cmd);
    
  
    
    indexElementVerbHandled[0] = indexElement[0];
    indexElementVerbHandled[1] = indexElement[1];
    if(indexElement[1] != "Null") {
      indexElementVerbHandled[2] = findVerbInDictionary(cmd);
    } else {
      indexElementVerbHandled[2] = "Null";
    }
  }
  
  if(globalHighjackIndexElementVerb(indexElementVerbHandled[0], indexElementVerbHandled[1], indexElementVerbHandled[2]))
  {
    indexElementVerbHandled[2] = "Skip";
  }
  
  return indexElementVerbHandled;
}

function btnCloseLedger_OnClick(GUIControl *control, MouseButton button)
{
  close_gui(gBook);
}
