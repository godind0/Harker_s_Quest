/*TO IMPLEMENT

- When a chair is "used" and the event is unhandled (function unhandled_event is called),  trigger the sit action
- Test get a file from drawer
- Code give file to Hawkins

*/

// main global script file
Dictionary* verbDictionary;
Dictionary* verbDescriptionDictionary;
Dictionary* notes;

Dictionary* hawkinsLedgerClientNames;
Dictionary* hawkinsLedgerCity;
Dictionary* hawkinsLedgerSector;
Dictionary* hawkinsLedgerPropertyAge;

Set* possibleClientNames;
float reachDistance = 40.0;
String lastCMD;
int nbFrameInSittingAnim;
int loopPerSecond;
int currentTimeIncrementPerLoop = 2;
float timeUITransparency;
float timeUIFadeSpeed = 0.1;

bool debugTools;
bool skipAllCutscene;

// set default game options
function set_default_options()
{
  System.Volume = 100;
  sldAudio.Value = System.Volume;
  sldSpeed.Value = 40;
  SetGameSpeed(40);
}

// initialize gPanel
function initialize_control_panel()
{
  set_default_options();
}

// hide the icon bar and show a GUI
function open_gui(GUI* gui_to_open)
{
  if (gui_to_open != gInventory)
  {
    lblOverHotspot.Visible = false;
  }

  //gIconbar.Visible = false;
  mouse.UseModeGraphic(eModePointer);
  gui_to_open.Visible = true;
}

// hide the GUI and show the icon bar
function close_gui(GUI* gui_to_close)
{
  gui_to_close.Visible = false;
  mouse.UseDefaultGraphic();
  lblOverHotspot.Visible = true;
  //gIconbar.Visible = true;
}

// hide a GUI, based on a GUI control
function close_owning_gui(GUIControl* control)
{
  close_gui(control.OwningGUI);
}

// hide a GUI directly from an OnClick event
function close_gui_onclick(GUIControl *control, MouseButton button)
{
  close_owning_gui(control);
}

// called when the game starts, before the first room is loaded
function game_start()
{
  // initialize gPanel controls
  initialize_control_panel();

  // set KeyboardMovement movement mode
  KeyboardMovement.Mode = eKeyboardMovementModeTapping;
  
  lastCMD = "";
  nbFrameInSittingAnim = 2;
  loopPerSecond = 40;
  
  player.Transparency = 100;
  
  currentTime = ((8 * 3600) + (0 * 60) + (0)) * loopPerSecond;
  timeUITransparency = 100.0;
  lblCurrentThought.Transparency = 100;
  
  //debug variables
  debugTools = true;
  skipAllCutscene = false;
  
  //Beard code
  cHarkersBeard.Transparency = 100;
  cHarkersBeard.ChangeRoom(cHarker.Room, cHarker.x, cHarker.y, eDirectionDown);
  cHarkersBeard.FollowCharacter(cHarker, FOLLOW_EXACTLY);
  
  hawkinsLedgerClientNames = Dictionary.Create(eSorted);
  hawkinsLedgerCity = Dictionary.Create(eSorted);
  hawkinsLedgerSector = Dictionary.Create(eSorted);
  hawkinsLedgerPropertyAge = Dictionary.Create(eSorted);
  
  notes = Dictionary.Create(eNonSorted);
  notes.Set("How to use", "When something notable is thought or said, you will see an asterisk (*) at the end of the sentence. Write the 'Note' command to add it to your notebook.");
  
  possibleClientNames = Set.Create(eSorted, eCaseInsensitive);
  possibleClientNames.Add("Acland");
  possibleClientNames.Add("Adams");
  possibleClientNames.Add("Adamson");
  possibleClientNames.Add("Aitken");
  possibleClientNames.Add("Alderdice");
  possibleClientNames.Add("Alexander");
  possibleClientNames.Add("Amery");
  possibleClientNames.Add("Armstrong");
  possibleClientNames.Add("Asghar");
  possibleClientNames.Add("Asquith");
  possibleClientNames.Add("Astor");
  possibleClientNames.Add("Atkins");
  possibleClientNames.Add("Attlee");
  possibleClientNames.Add("Bagshaw");
  possibleClientNames.Add("Baker");
  possibleClientNames.Add("Baldwin");
  possibleClientNames.Add("Ball");
  possibleClientNames.Add("Bankes");
  possibleClientNames.Add("Baring");
  possibleClientNames.Add("Basse");
  possibleClientNames.Add("Bathurst");
  possibleClientNames.Add("Beaumont");
  possibleClientNames.Add("Beggse");
  possibleClientNames.Add("Beith");
  possibleClientNames.Add("Benn");
  possibleClientNames.Add("Benyon");
  possibleClientNames.Add("Beresford");
  possibleClientNames.Add("Bergers");
  possibleClientNames.Add("Bernal");
  possibleClientNames.Add("Bevan");
  possibleClientNames.Add("Billingham");
  possibleClientNames.Add("Bilson");
  possibleClientNames.Add("Blackburne");
  possibleClientNames.Add("Blake");
  possibleClientNames.Add("Blennerhassett");
  possibleClientNames.Add("Blomfield");
  possibleClientNames.Add("Bole");
  possibleClientNames.Add("Borwick");
  possibleClientNames.Add("Boswell");
  possibleClientNames.Add("Bottomley");
  possibleClientNames.Add("Bowater");
  possibleClientNames.Add("Bradshaw");
  possibleClientNames.Add("BrightsCash");
  possibleClientNames.Add("Bromley");
  possibleClientNames.Add("Brookes");
  possibleClientNames.Add("Brown");
  possibleClientNames.Add("Brunner");
  possibleClientNames.Add("Bull");
  possibleClientNames.Add("Burgon");
  possibleClientNames.Add("Butler");
  possibleClientNames.Add("Byers");
  possibleClientNames.Add("Calcraft");
  possibleClientNames.Add("Callaghan");
  possibleClientNames.Add("Calvert");
  possibleClientNames.Add("Carters");
  possibleClientNames.Add("Cavendish");
  possibleClientNames.Add("Cawley");
  possibleClientNames.Add("Cecil");
  possibleClientNames.Add("Chamberlain");
  possibleClientNames.Add("Chaplin");
  possibleClientNames.Add("Chapman");
  possibleClientNames.Add("Chichester");
  possibleClientNames.Add("Churchill");
  possibleClientNames.Add("Clifton");
  possibleClientNames.Add("Cooper");
  possibleClientNames.Add("Cope");
  possibleClientNames.Add("Courts");
  possibleClientNames.Add("Cox");
  possibleClientNames.Add("Cromwell");
  possibleClientNames.Add("Cryer");
  possibleClientNames.Add("Dashwood");
  possibleClientNames.Add("Davidson");
  possibleClientNames.Add("Davies");
  possibleClientNames.Add("Davis");
  possibleClientNames.Add("Dawson");
  possibleClientNames.Add("Dickinson");
  possibleClientNames.Add("Dodds");
  possibleClientNames.Add("Doran");
  possibleClientNames.Add("Drake");
  possibleClientNames.Add("Dunnes");
  possibleClientNames.Add("Dunwoody");
  possibleClientNames.Add("Durkan");
  possibleClientNames.Add("Eccles");
  possibleClientNames.Add("Edward");
  possibleClientNames.Add("Egerton");
  possibleClientNames.Add("Ewing");
  possibleClientNames.Add("Ferguson");
  possibleClientNames.Add("Fielden");
  possibleClientNames.Add("Finnie");
  possibleClientNames.Add("Foley");
  possibleClientNames.Add("Ford");
  possibleClientNames.Add("Foster");
  possibleClientNames.Add("Galbraith");
  possibleClientNames.Add("Garnier");
  possibleClientNames.Add("Gibson");
  possibleClientNames.Add("Gilmorehill");
  possibleClientNames.Add("Gladstone");
  possibleClientNames.Add("Golding");
  possibleClientNames.Add("Goldsmith");
  possibleClientNames.Add("Goschen");
  possibleClientNames.Add("Grady");
  possibleClientNames.Add("Grant");
  possibleClientNames.Add("Grattan");
  possibleClientNames.Add("Greene");
  possibleClientNames.Add("Greenwood");
  possibleClientNames.Add("Grenville");
  possibleClientNames.Add("Grey");
  possibleClientNames.Add("Grieves");
  possibleClientNames.Add("Guest");
  possibleClientNames.Add("Guinness");
  possibleClientNames.Add("Harcourt");
  possibleClientNames.Add("Hardies");
  possibleClientNames.Add("Harding");
  possibleClientNames.Add("Healy");
  possibleClientNames.Add("Heathcote");
  possibleClientNames.Add("Henderson");
  possibleClientNames.Add("Hodges");
  possibleClientNames.Add("Hodgson");
  possibleClientNames.Add("Hoggs");
  possibleClientNames.Add("Holmes");
  possibleClientNames.Add("Hooson");
  possibleClientNames.Add("Hope");
  possibleClientNames.Add("Hopkinson");
  possibleClientNames.Add("Howarth");
  possibleClientNames.Add("Howes");
  possibleClientNames.Add("Hoyle");
  possibleClientNames.Add("Hubbard");
  possibleClientNames.Add("Hurd");
  possibleClientNames.Add("Hussey");
  possibleClientNames.Add("Jackson");
  possibleClientNames.Add("Janner");
  possibleClientNames.Add("Jay");
  possibleClientNames.Add("Jeger");
  possibleClientNames.Add("Jenkins");
  possibleClientNames.Add("Johnson");
  possibleClientNames.Add("Jones");
  possibleClientNames.Add("Keen");
  possibleClientNames.Add("Kennedy");
  possibleClientNames.Add("Kinnock");
  possibleClientNames.Add("Knollys");
  possibleClientNames.Add("Lamb");
  possibleClientNames.Add("Lancaster");
  possibleClientNames.Add("Laws");
  possibleClientNames.Add("Lechmere");
  possibleClientNames.Add("Lee");
  possibleClientNames.Add("Lefroy");
  possibleClientNames.Add("Lemon");
  possibleClientNames.Add("Lever");
  possibleClientNames.Add("Lewis");
  possibleClientNames.Add("Lindsay");
  possibleClientNames.Add("Lloyd");
  possibleClientNames.Add("Long");
  possibleClientNames.Add("Lowther");
  possibleClientNames.Add("Luce");
  possibleClientNames.Add("Luttrell");
  possibleClientNames.Add("Lyon");
  possibleClientNames.Add("Maberley");
  possibleClientNames.Add("MacDonald");
  possibleClientNames.Add("MacKay");
  possibleClientNames.Add("Macmillan");
  possibleClientNames.Add("Mahon");
  possibleClientNames.Add("Mallalieus");
  possibleClientNames.Add("Mancroft");
  possibleClientNames.Add("Mandelson");
  possibleClientNames.Add("Martin");
  possibleClientNames.Add("Maude");
  possibleClientNames.Add("Maxton");
  possibleClientNames.Add("McAteer");
  possibleClientNames.Add("McAvan");
  possibleClientNames.Add("McCarthy");
  possibleClientNames.Add("McCrea");
  possibleClientNames.Add("McGuinnesse");
  possibleClientNames.Add("McMahon");
  possibleClientNames.Add("McNair-Wilson");
  possibleClientNames.Add("Meacher");
  possibleClientNames.Add("Miles");
  possibleClientNames.Add("Miliband");
  possibleClientNames.Add("Millar");
  possibleClientNames.Add("Mitchell");
  possibleClientNames.Add("Montague");
  possibleClientNames.Add("Morgan");
  possibleClientNames.Add("Morley");
  possibleClientNames.Add("Morris");
  possibleClientNames.Add("Morrison");
  possibleClientNames.Add("Mosley");
  possibleClientNames.Add("Mundell");
  possibleClientNames.Add("Nairns");
  possibleClientNames.Add("Nandy");
  possibleClientNames.Add("Norman");
  possibleClientNames.Add("Nott");
  possibleClientNames.Add("Nuttall");
  possibleClientNames.Add("O'Connell");
  possibleClientNames.Add("Ormsby");
  possibleClientNames.Add("Overend");
  possibleClientNames.Add("Paget");
  possibleClientNames.Add("Paisley");
  possibleClientNames.Add("Paton");
  possibleClientNames.Add("Pawsey");
  possibleClientNames.Add("Pease");
  possibleClientNames.Add("Peel");
  possibleClientNames.Add("Pelham");
  possibleClientNames.Add("Percival");
  possibleClientNames.Add("Perkin");
  possibleClientNames.Add("Perry");
  possibleClientNames.Add("Philipse");
  possibleClientNames.Add("Pitt");
  possibleClientNames.Add("Plunkett");
  possibleClientNames.Add("Poots");
  possibleClientNames.Add("Prentice");
  possibleClientNames.Add("Price");
  possibleClientNames.Add("Redmond");
  possibleClientNames.Add("Rees");
  possibleClientNames.Add("Ridley");
  possibleClientNames.Add("Robinson");
  possibleClientNames.Add("Roe");
  possibleClientNames.Add("Rothschild");
  possibleClientNames.Add("Ruddock");
  possibleClientNames.Add("Runciman");
  possibleClientNames.Add("Russell");
  possibleClientNames.Add("Sainsbury");
  possibleClientNames.Add("Samuel");
  possibleClientNames.Add("Samuelson");
  possibleClientNames.Add("Sandy");
  possibleClientNames.Add("Seymour");
  possibleClientNames.Add("Sharples");
  possibleClientNames.Add("Shelley");
  possibleClientNames.Add("Shinwell");
  possibleClientNames.Add("Silkin");
  possibleClientNames.Add("Sillars");
  possibleClientNames.Add("Sinclair");
  possibleClientNames.Add("Skinner");
  possibleClientNames.Add("Smith");
  possibleClientNames.Add("Spencer");
  possibleClientNames.Add("Spring");
  possibleClientNames.Add("Stanley");
  possibleClientNames.Add("Sturgeon");
  possibleClientNames.Add("Swinson");
  possibleClientNames.Add("Tennyson");
  possibleClientNames.Add("Todd");
  possibleClientNames.Add("Tyrwhitt");
  possibleClientNames.Add("Villiers");
  possibleClientNames.Add("Vivian");
  possibleClientNames.Add("Wakefield");
  possibleClientNames.Add("Walker");
  possibleClientNames.Add("Ward");
  possibleClientNames.Add("Watkin");
  possibleClientNames.Add("Watts");
  possibleClientNames.Add("Wheatley");
  possibleClientNames.Add("Wiggins");
  possibleClientNames.Add("Wigrams");
  possibleClientNames.Add("Williams");
  possibleClientNames.Add("Winterton");
  possibleClientNames.Add("Wintringham");
  possibleClientNames.Add("Wolfson");
  possibleClientNames.Add("Wood");  
  
  verbDictionary = Dictionary.Create(eNonSorted, eCaseInsensitive);
  verbDictionary.Set("look", "look");
  verbDictionary.Set("use", "use");
  //verbDictionary.Set("eat", "eat");
  //verbDictionary.Set("give", "give");
  verbDictionary.Set("examine", "look");
  verbDictionary.Set("open", "open");
  verbDictionary.Set("close", "close");
  verbDictionary.Set("go to", "approach");
  verbDictionary.Set("approach", "approach");
  verbDictionary.Set("note", "note");
  verbDictionary.Set("talk", "talk");
  verbDictionary.Set("speak", "talk");
  verbDictionary.Set("take", "take");
  verbDictionary.Set("get", "take");
  verbDictionary.Set("pick up", "take");
  verbDictionary.Set("read", "read");
  verbDictionary.Set("sit", "sit");
  verbDictionary.Set("stand", "stand");
  
  verbDescriptionDictionary = Dictionary.Create(eSorted, eCaseInsensitive);
  verbDescriptionDictionary.Set("look", "Look at something or someone in the room (or at one of your inventory items.[[EXAMPLE: Look carpet");
  verbDescriptionDictionary.Set("use", "Use an item from your inventory or an object in the room near you. Sometimes, you must specify on what or on whom you use the object.[[EXAMPLE 1: Use sink[[EXAMPLE 2: Use razor on myself");
  //verbDescriptionDictionary.Set("eat", "Consume something.[[EXAMPLE: Eat chicken");
  //verbDescriptionDictionary.Set("give", "Give an intem from your inventory to someone else. You must specify to whom you wish to give the item.[[EXAMPLE: Give ring to Mina");
  verbDescriptionDictionary.Set("open", "Open an object near you or an item from your inventory.[[EXAMPLE: Open front door");
  verbDescriptionDictionary.Set("close", "Close an object near you or an item from your inventory.[[EXAMPLE: Close bedroom door");
  verbDescriptionDictionary.Set("*approach", "Have Jonathan walk over to something or someone.[[Only works if 'Show hints' is chosen from the option panel.[[EXAMPLE: Approach dining table");
  verbDescriptionDictionary.Set("note", "Have Jonathan write down his notable information.[Only works when Jonathan has a notebook[[EXAMPLE: Note");
  verbDescriptionDictionary.Set("talk", "Talk to someone in the room.[Sometimes, you need to be near someone to talk to them.[[EXAMPLE: Talk to Count");
  verbDescriptionDictionary.Set("take", "Pick up an object and place it in your inventory.[[EXAMPLE: Take razor");
  verbDescriptionDictionary.Set("read", "Read an item from your inventory.[Not all items can be read.[[EXAMPLE: Read ledger");
  verbDescriptionDictionary.Set("sit", "Have Jonathan sit down in a nearby chair or appropriate surface.[Jonathan will not sit on any surface.[[EXAMPLE: Sit on bench");
  verbDescriptionDictionary.Set("spot", "Have Jonathan point out objects, people and inventory items that contain a certain word in its name.[[EXAMPLE: Spot door");
  verbDescriptionDictionary.Set("stand", "Have Jonathan stand up.[[EXAMPLE: Stand up");
  
  int i;
  String myVerbs[] = verbDescriptionDictionary.GetKeysAsArray();
  
  for(i = 0; i < verbDescriptionDictionary.ItemCount; i++)
  {
    lbVerbs.AddItem(myVerbs[i]);
  }
  lblHelpVerbDesc.Text = verbDescriptionDictionary.Get(lbVerbs.Items[lbVerbs.TopItem]);
  
}

// Called when a dialog script line "run-script" is processed
function dialog_request(int param)
{
  switch(param)
  {
    case dLedger.ID:
      GiveScore(1);
      break;
    default:
      break;
  }
  
}

function show_save_game_dialog()
{
  // get the list of save games
  lstSaveGamesList.FillSaveGameList();

  if (lstSaveGamesList.ItemCount > 0)
  {
    // if there is at least one, set the default text
    // to be the first game's name
    txtNewSaveName.Text = lstSaveGamesList.Items[0];
  }
  else
  {
    // no save games yet, so default to empty text
    txtNewSaveName.Text = "";
  }

  open_gui(gSaveGame);
}

function show_restore_game_dialog()
{
  lstRestoreGamesList.FillSaveGameList();
  open_gui(gRestoreGame);
}

//################## DEBUG DISPLAY FUNCTION ####################################

function debugDisplay(String message) // Display used for debug so we can turn them off safely for the release candidate
{
  if(debugTools){
    Display(message);
  }
}

//################## STRING CUSTOM FUNCTIONS ####################################

String keycodeToString(char typeCharacter) // returns the symbol associated with the code (e.g.: 65 => A)
{
  return String.Format("%c",  typeCharacter);
}

String etToString(elementType eT) // changes the element type enum (roomObject,  AllInventoryItem,  roomHotspot and allCharacters) to a String
{
  switch(eT)
  {
    case roomObjects:
      return "roomObjects";
      break;
    case roomHotspots:
      return "roomHotspots";
      break;
    case allCharacters:
      return "allCharacters";
      break;
    case allInventoryItems:
      return "allInventoryItems";
      break;
    default:
      //debugDisplay(String.Format("Fxn etToString received element type #%d, out of bounds.", eT));
      break;
  }
}

elementType stringToET(String eT) // changes the String to the element type enum spelled out (roomObject,  AllInventoryItem,  roomHotspot and allCharacters)
{
  switch(eT)
  {
    case "roomObjects":
      return roomObjects;
      break;
    case "roomHotspots":
      return roomHotspots;
      break;
    case "allCharacters":
      return allCharacters;
      break;
    case "allInventoryItems":
      return allInventoryItems;
      break;
    default:
      //debugDisplay(String.Format("Fxn stringToET received string %s, unknown.", eT));
      break;
  }
}

bool alphaOrder_isThisBeforeThat(String thisString, String thatString)
{
  Set* alphabetise = Set.Create(eSorted, eCaseInsensitive);
  alphabetise.Add(thisString);
  alphabetise.Add(thatString);
  String alphaArray[] = alphabetise.GetItemsAsArray();
  return (thisString == alphaArray[0]);
}

bool startsWithVowel(String word) // returns true if a String starts with a vowel (useful for distinction between the use of 'a' or 'an' as articles
{
  bool doesStartWithAVowel = false;
  if(word.StartsWith("A", eCaseInsensitive)){
    doesStartWithAVowel = true;
  } else if(word.StartsWith("E", eCaseInsensitive)){
    doesStartWithAVowel = true;
  } else if(word.StartsWith("I", eCaseInsensitive)){
    doesStartWithAVowel = true;
  } else if(word.StartsWith("O", eCaseInsensitive)){
    doesStartWithAVowel = true;
  } else if(word.StartsWith("U", eCaseInsensitive)){
    doesStartWithAVowel = true;
  } else if(word.StartsWith("Y", eCaseInsensitive)){
    doesStartWithAVowel = true;
  }
  return doesStartWithAVowel;
}

String removeOneStringInstance(String fullText, String stringToRemoveOnce) // basically the String.Replace function,  but only for the first occurrence (not all)
{
  int i;
  int finishAt = fullText.IndexOf(stringToRemoveOnce) + stringToRemoveOnce.Length;
  String finalReplacement = "";
  for(i = fullText.IndexOf(stringToRemoveOnce); i < finishAt; i++)
  {
    fullText = fullText.ReplaceCharAt(i, 95);
    finalReplacement = finalReplacement.Append("_");
  }
  fullText = fullText.Replace(finalReplacement, "", eCaseInsensitive);
  return fullText;
}

String[] split(String textToSplit, String separator) // Returns an array of string split by separators !! CAREFUL array[0] is the array's length,  not an item !!
{
  int i;
  String testString = textToSplit.Replace(separator, "", eCaseInsensitive);
  int nbStringItems = textToSplit.Length;
  nbStringItems = nbStringItems - testString.Length;
  
  String returnArray[] = new String[nbStringItems];
  returnArray[0] = String.Format("%d", nbStringItems);
  
  for(i = 1; i < nbStringItems; i++)
  {
    
    if(textToSplit.IndexOf(separator) != -1)
    {
      returnArray[i] = textToSplit.Substring(0, textToSplit.IndexOf(separator));
      textToSplit = removeOneStringInstance(textToSplit, returnArray[i].Append(separator));
    } else
    {
      returnArray[i] = textToSplit;
    }
  }
  
  return returnArray;
}

String cmdStartsWithUSEsynonym(String cmd) // Return on the the 'use synonyms' we chose (if found) or "Null" if not found
{
  Set* USEsynonyms = Set.Create();
  USEsynonyms.Add("use");
  USEsynonyms.Add("put");
  USEsynonyms.Add("insert");
  
  String synonymList[] = USEsynonyms.GetItemsAsArray();
  int i = USEsynonyms.ItemCount -1;
  String foundMatch = "Null";
  
  while(i >= 0 && foundMatch == "Null")
  {
    if(cmd.StartsWith(synonymList[i], eCaseInsensitive))
    {
      foundMatch = synonymList[i];
    } else {
      i--;
    }
  }
  
  return foundMatch;
}

String whichArticle(String listOfElementsMentionned, String newElementName) // retunrs the appropriate article for a list of things to list ('A'/'An', 'A second',  etc.)
{ 
  int counter = 1;
  while(listOfElementsMentionned.IndexOf(newElementName) != -1)
  {
    counter++;
    listOfElementsMentionned = removeOneStringInstance(listOfElementsMentionned, newElementName);
  }
  switch(counter)
  {
    case 0:
      if(startsWithVowel(newElementName))
      {
        return "An";
      } else
      {
        return "A";
      }
      break;
    case 1:
      if(startsWithVowel(newElementName))
      {
        return "An";
      } else
      {
        return "A";
      }
      break;
    case 2:
      return "A second";
      break;
    case 3:
      return "A third";
      break;
    case 4:
      return "A fourth";
      break;
    case 5:
      return "A fifth";
      break;
    default:
      return "Another";
      break;
  }
}


//################# INTERACTION AUTOMATION FUNCTIONS ###############################

//##### UTILITIES #####

int getObjectMidX(Object* Obj) {
  DynamicSprite* tempSprite = DynamicSprite.CreateFromExistingSprite(Obj.Graphic);
  int returnInt = tempSprite.Width / 2;
  tempSprite.Delete();
  
  returnInt = returnInt + Obj.X;
  
  return returnInt;
}

float calculateDistanceFromCharacter(int targetX, int targetY,  Character* who) // Return a float of the distance (in px) between a character and a target
{
  float deltaX = IntToFloat(targetX) - IntToFloat(who.x);
  float deltaY = IntToFloat(targetY) - IntToFloat(who.y);
  return Maths.Sqrt(Maths.RaiseToPower(deltaX, 2.0)+ Maths.RaiseToPower(deltaY, 2.0));  
}

bool isCharacterCloseEnough(int targetX, int targetY, float maxDistance,  Character* who) // Returns a bool describing if a character's distance from a target is lower than the indicated max
{
  float dist = calculateDistanceFromCharacter(targetX, targetY, who);
  return dist < maxDistance;
}

bool isCharacterNearHotspot(Hotspot* HS, float maxDistance,  Character* who) // Is the character close to the passed hotspot
{
  return isCharacterCloseEnough(HS.WalkToX, HS.WalkToY, maxDistance,  who);  
}

bool isCharacterNearObject(Object* Obj, float maxDistance,  Character* who) // Is the character close to the passed object
{
  //debugDisplay(String.Format("X: %d > %d[Y = %d > %d", player.x, getObjectMidX(Obj), player.y, Obj.Y));
  return isCharacterCloseEnough(getObjectMidX(Obj), Obj.Y, maxDistance,  who);  
}

bool isCharacterNearCharacter(Character* target, float maxDistance,  Character* who)  // Is the character close to the passed character
{
  return isCharacterCloseEnough(target.x, target.y, maxDistance,  who);  
}

bool isThisOpened(Object* Obj)
{
  bool returnBool = false;
  
  switch(Obj.GetProperty("Open_SpriteNumber"))
  {
    case -2:
      returnBool = !Obj.Visible;
      break;
    case -1:
      break;
    default:
      returnBool = (Obj.Visible && Obj.Graphic == Obj.GetProperty("Open_SpriteNumber"));
      break;
  }
  
  return returnBool;
}

String whatIsThis(elementType eT, int index) // return an element's name
{
  switch(eT)
  {
    case roomObjects:
      return object[index].Name;
      break;
    case roomHotspots:
      return hotspot[index].Name;
      break;
    case allCharacters:
      return character[index].Name;
      break;
    case allInventoryItems:
      return inventory[index].Name;
      break;
    default: 
      //debugDisplay(String.Format("whatIsThis fxn received element type #%d, out of bounds.", eT));
      return "Unknown";
      break;
  }
}

String[] findClosestElement(String elementType_index[], float dist[], int arraysLength) // Returns the closest element from indexed arrays
{
  String closestElementType_index = elementType_index[0];
  float closestDist = dist[0];
  String returnArray[] = new String[2];
  
  int i; 
  for(i = 1; i < arraysLength; i++)
  {
    if(dist[i] < closestDist) 
    {
      closestElementType_index = elementType_index[i];
      closestDist = dist[i];
    }
  }
  
  returnArray[0] = closestElementType_index.Truncate(closestElementType_index.IndexOf("_"));
  closestElementType_index = closestElementType_index.Replace(returnArray[0], "", eCaseInsensitive);
  closestElementType_index = closestElementType_index.Replace("_", "", eCaseInsensitive);
  returnArray[1] = closestElementType_index;
  
  return returnArray;
}

String isInteractionOnElement(String cmd) // returns true if the command has both a 'use synonym' and a 'on' synonym (e.g.: USE razor ON Jonathan // INSERT files IN folder)
{
  Set* OnSynonyms = Set.Create(eSorted);
  OnSynonyms.Add("in");
  OnSynonyms.Add("into");
  OnSynonyms.Add("onto");
  OnSynonyms.Add("on");
  OnSynonyms.Add("over");
  OnSynonyms.Add("with");
  OnSynonyms.Add("under");
  OnSynonyms.Add("to");
  
  String OnSynonymsArray[] = OnSynonyms.GetItemsAsArray();
  int i = OnSynonyms.ItemCount - 1;
  String foundMatch = "Null";
  
  while(i >= 0 && foundMatch == "Null")
  {
    if(cmd.IndexOf(OnSynonymsArray[i]) != -1)
    {
      foundMatch = OnSynonymsArray[i];
    } else {
      i--;
    }
  }
  
  return foundMatch;
}

function memorize(String thought) {
  lblCurrentThought.Text = thought;
  timeUITransparency = 0.0;
}

String getMemorisedThought()
{
  if(lblCurrentThought.Transparency < 100)
  {
    return lblCurrentThought.Text;
  } else {
    return "...I forget";
  }
}


//##### TIME FUNCTIONS #####

String whatTimeIsIt(bool showTimeInStatusLine)
{
  int timeInLoops = currentTime;
  String AmPm = "AM";
  
  int hour = timeInLoops / (loopPerSecond * 3600);
  timeInLoops = timeInLoops - (hour * 3600 * loopPerSecond);
  if(hour >= 12)
  {
    AmPm = "PM";
  }
  if(hour > 12)
  {
    hour = hour - 12;
  }
  
  int minutes = timeInLoops / (loopPerSecond * 60);
  
  if(showTimeInStatusLine)
  {
    memorize(String.Format("%d:%02d%s", hour, minutes, AmPm));
  }
  
  return String.Format("%d:%02d%s", hour, minutes, AmPm);
}

bool isItBeforeThisTime(int hour, int minutes, int seconds, bool PM, int day)
{
  //debugDisplay(String.Format("Max day: %d[Max time: %02d:%02d:%02d[PM: %d", day, hour, minutes, seconds, PM));
  if(PM && hour != 12)
  {
    hour = hour + 12;
  }
  int maxLoops = ((((((day * 24) + hour) * 60) + minutes) * 60) + seconds) * loopPerSecond;
  int currentAllTimeLoop = currentTime + ((currentDay * 86400) * loopPerSecond);
  return currentAllTimeLoop <= maxLoops;
}

String addTimeToDescription(String textDescription)
{
  String returnText = String.Format("%s[It is %s", textDescription, whatTimeIsIt(true));
  return returnText;
}

function setCurrentTime(int hour, int minutes, int seconds, bool PM,  int day)
{
  if(PM && (hour != 12))
  {
    hour = hour + 12;
  }
  currentTime = ((hour * 3600) + (minutes * 60) + seconds) * loopPerSecond;
  currentDay = day;
}

function addTime(int hour, int minutes, int seconds, int day)
{
  int loopsToAdd = ((hour * 3600) + (minutes * 60) + seconds) * loopPerSecond;
  currentTime = currentTime + loopsToAdd;
}

function setTimeIncrementPerLoop(int newIncrement)
{
  currentTimeIncrementPerLoop = newIncrement;
}

function resetTimeIncrementPerLoop()
{
  currentTimeIncrementPerLoop = 2;
}

//##### MAP-ROOM FUNCTIONS #####

function enterMap() // uses the gMapIndication GUI to add the name of all destinations (they must be objects in the 'Room' used for the map and be named)
{
  int i;  
  gMapIndications.Visible = true;
  for(i = 0 ; i < Room.ObjectCount ; i++)
  {
    gMapIndications.Controls[i].AsLabel.Text = object[i].Name;
    gMapIndications.Controls[i].AsLabel.Visible = true;
    gMapIndications.Controls[i].AsLabel.X = object[i].X - gMapIndications.Controls[i].AsLabel.Width;
    gMapIndications.Controls[i].AsLabel.Y = object[i].Y;
    gMapIndications.Controls[i].AsLabel.TextAlignment = eAlignRight;
  }
  setTimeIncrementPerLoop(4);
}

function exitMap() // clears all specifics from the gMapIndications GUI
{
  int i;
  for(i = 0 ; i < gMapIndications.ControlCount ; i++)
  {
    gMapIndications.Controls[i].AsLabel.Text = "";
    gMapIndications.Controls[i].AsLabel.Visible = false;
  }
  gMapIndications.Visible = false;
  resetTimeIncrementPerLoop();
}

//##### AUTOMATED ACTION FUNCTION #####

//##### HAWKINS LEDGER

String addFirstNameInitial (String lastName)
{
  return String.Format("%s, %c.", lastName, Random(25) + 65);
}

String getRandomSector()
{
  String sectors[] = new String[5];
  sectors[0] = "City center";
  sectors[1] = "North end";
  sectors[2] = "South end";
  sectors[3] = "East end";
  sectors[4] = "West end";
  return sectors[Random(4)];
}

String getClientName() // Get a client's name,  format: Lastname, F.
{
  int i = Random(possibleClientNames.ItemCount - 1);
  String clientNamesList[] = possibleClientNames.GetItemsAsArray();
  String clientName = clientNamesList[i];
  possibleClientNames.Remove(clientName);
  return addFirstNameInitial(clientName);
}

String generateHawkinsCode() // Generate a code,  format: A#####-###
{
  String code;
  do
  {
    code = String.Format("%s%05d-%03d", keycodeToString(65 + Random(90-65)), Random(99999), Random(999));
  } while(hawkinsLedgerClientNames.Get(code) != null);
  
  return code;
}

String justTheLastName(String nameWithInitial)
{
  String lastName;
  
  if(nameWithInitial.IndexOf(",") != -1)
  {
    lastName = nameWithInitial.Truncate(nameWithInitial.IndexOf(","));
    lastName = lastName.Replace(",", "", eCaseInsensitive);
  } else {
    lastName = nameWithInitial;
  }
  lastName = lastName.Replace(" ", "", eCaseInsensitive);
  
  return lastName;
}

String formatClientName(String providedName)
{
  String lastName = justTheLastName(providedName);
  String fullName;
  providedName = removeOneStringInstance(lastName, lastName);
  providedName = providedName.Replace(",", "", eCaseInsensitive);
  providedName = providedName.Replace(" ", "", eCaseInsensitive);
  providedName = providedName.Replace(".", "", eCaseInsensitive);
  if(providedName.Chars[0] < 65 || providedName.Chars[0] > 90)
  {
    fullName = addFirstNameInitial(lastName);
  } else {
    fullName = String.Format("%s, %c.", lastName, providedName.Chars[0]);
  }
  
  return fullName;
}

bool validatePossibleClientName(String thisName)
{
  bool validName = true;
  String lastName = justTheLastName(thisName);
  
  if(!possibleClientNames.Contains(lastName))
  {
    validName = false;
  }
  
  return validName;
}

bool validateHawkinsCode(String code)
{
  bool correct = true;
  int i = 0;
  while((i < code.Length) && (correct))
  {
    if(code.Length != 10)
    {
      correct = false;
    } else 
    {
      switch(i)
      {
        case 0:
          if(code.Chars[i] < 65 || code.Chars[i] > 90)
          {
            correct = false;
          }
          break;
        case 6:
          if(code.Chars[i] != '-')
          {
            correct = false;
          }
          break;
        default:
          if(code.Chars[i] < 48 || code.Chars[i] > 57)
          {
            correct = false;
          }
      }
    }
    i++;
  }
  
  return correct;
}

String findValidCodePart(String cmd)
{
  String analysedPart = "Null";
  int validCodeLength = 10;
  int i = 0;
  String foundCode = "Null";
  
  while(i + validCodeLength <= cmd.Length)
  {
    analysedPart = cmd.Substring(i, validCodeLength);
    if(validateHawkinsCode(analysedPart))
    {
      //debugDisplay(String.Format("This is valid: %s", analysedPart));
      foundCode = analysedPart;
    } else {
      analysedPart = "Null";
      i++;
    }
  }
  
  return analysedPart;
}

String findValidNamePart(String cmd)
{
  String thatWord;
  Set* words = Set.Create(eSorted);
  int SpaceIndex;
  int CommaIndex;
  int PeriodIndex;
  int nextCut;
  String nextCutChar;
  
  String wordsArray[];
  int i = 0;
  String foundMatch = "Null";
  
  do
  {
    nextCut = 1000;
    nextCutChar = "";
    
    SpaceIndex = cmd.IndexOf(" ");
    if(SpaceIndex == -1) {
      SpaceIndex = 1000;
    } else if(SpaceIndex < nextCut) {
      nextCut = SpaceIndex;
      nextCutChar = " ";
    }    
    CommaIndex = cmd.IndexOf(",");
    if(CommaIndex == -1) {
      CommaIndex = 1000;
    } else if(CommaIndex < nextCut) {
      nextCut = CommaIndex;
      nextCutChar = ",";
    }
    PeriodIndex = cmd.IndexOf(".");
    if(PeriodIndex == -1) {
      PeriodIndex = 1000;
    } else if (PeriodIndex < nextCut) {
      nextCut = PeriodIndex;
      nextCutChar = ".";
    }
    
    thatWord = cmd.Truncate(nextCut);
    thatWord = thatWord.Replace(" ", "", eCaseInsensitive);
    thatWord = thatWord.Replace(",", "", eCaseInsensitive);
    thatWord = thatWord.Replace(".", "", eCaseInsensitive);
    words.Add(thatWord);
    
    cmd = removeOneStringInstance(cmd, thatWord.Append(nextCutChar));
    
  } while((SpaceIndex + CommaIndex + PeriodIndex) < 3000);
  
  wordsArray = words.GetItemsAsArray();
  while(i < words.ItemCount && foundMatch == "Null")
  {
    if(validatePossibleClientName(wordsArray[i]))
    {
      if(wordsArray[i + 1].Length == 1)
      {
        wordsArray[i] = String.Format("%s, %s.", wordsArray[i], wordsArray[i+1]);
      }
      foundMatch = wordsArray[i];
    } else {
      i++;
    }
  }
  
  return foundMatch;
  
}

String generateHawkinsFile(String city, String sector, int ageMin, int ageMax,  String code, String name) // Code (returns this) and client name can be randomized,  not city or sector (age is always randomized)
{
  if(!validateHawkinsCode(code)){
    code = generateHawkinsCode();
  }
  if(name == "Null")
  {
    name = getClientName();
  }
  hawkinsLedgerCity.Set(code, city);
  hawkinsLedgerClientNames.Set(code, name);
  hawkinsLedgerPropertyAge.Set(code, String.Format("%d", ageMin + Random(ageMax)));
  hawkinsLedgerSector.Set(code, sector);
  
  return code;
}

String findCodeInCMD(String cmd, bool createIfValid) //<< This sends back the CMD if not found which is not intended ! HEREE
{
  String knownCodes[] = hawkinsLedgerClientNames.GetKeysAsArray();
  int i = 0;
  String foundMatch = "Null";
    
  String newClientName;
  String foundValidCode;
  
  while(foundMatch == "Null" && i < hawkinsLedgerClientNames.ItemCount) // Does it exist already?
  {
    if(cmd.IndexOf(knownCodes[i]) != -1)
    {
      foundMatch = knownCodes[i];
    } else {
      i++;
    }
  }
  
  if(createIfValid && foundMatch == "Null") // If we haven't found it in the current ledger (and we're allowed to create a file)
  {
    foundValidCode = findValidCodePart(cmd); // included an actual valid,  yet not created, code
    if(foundValidCode != "Null")
    {
      generateHawkinsFile("Exeter", getRandomSector(), 5, 1000, foundValidCode, "Null");
      foundMatch = foundValidCode;
    }
  }
  
  return foundMatch;
}

String findClientNameInCMD(String cmd, bool createIfValid)
{
  String knownNames[] = hawkinsLedgerClientNames.GetValuesAsArray();
  int i = 0;
  String foundMatch = "Null";
  
  String foundValidName;
  
  while(foundMatch == "Null" && i < hawkinsLedgerClientNames.ItemCount) // Does it exist already?
  {
    if(cmd.IndexOf(knownNames[i]) != -1)
    {
      foundMatch = knownNames[i];
    } else {
      i++;
    }
  }
  
  if(createIfValid && foundMatch == "Null") // If we haven't found it in the current ledger (and we're allowed to create a file)
  {
    foundValidName = findValidNamePart(cmd); // included an actual valid,  yet not created, client
    if(foundValidName != "Null")
    {
      generateHawkinsFile("Exeter", getRandomSector(), 5, 1000, "Null", formatClientName(foundValidName));
      foundMatch = foundValidName;
    }
  }
  
  return foundMatch;
}

String getCityPerCode(String code)
{
  String returnString = "Null";
  if(hawkinsLedgerCity.Get(code) != null)
  {
    returnString = hawkinsLedgerCity.Get(code);
  }
  return returnString;
}

String getSectorPerCode(String code)
{
  String returnString = "Null";
  if(hawkinsLedgerSector.Get(code) != null)
  {
    returnString = hawkinsLedgerSector.Get(code);
  }
  return returnString;
}

int getAgePerCode(String code)
{
  String tempString;
  int returnInt = -1;
  if(hawkinsLedgerPropertyAge.Get(code) != null)
  {
    tempString = hawkinsLedgerPropertyAge.Get(code);
    returnInt = tempString.AsInt;
  }
  return returnInt;
}

String getClientNameFromCode(String code, bool allowCreateNewOne) 
{
  String thisClientName = "Null";
  
  if(validateHawkinsCode(code)){
    thisClientName = hawkinsLedgerClientNames.Get(code);
    if(thisClientName == null && allowCreateNewOne) {
      generateHawkinsFile("Exeter", getRandomSector(), 5, 1000, code, "Null");
      thisClientName = hawkinsLedgerClientNames.Get(code);
    }
  }
  
  return thisClientName;
}

String getCodeFromClientName(String clientName, bool allowCreateNewOne)
{
  String thisCode = "Null";
  String registeredCodes[] = hawkinsLedgerClientNames.GetKeysAsArray();
  String registeredNames[] = hawkinsLedgerClientNames.GetValuesAsArray();
  int i = 0;
  
  while(i < hawkinsLedgerClientNames.ItemCount && thisCode == "Null")
  {
    if(clientName == registeredNames[i])
    {
      thisCode = registeredCodes[i];
    } else {
      i++;
    }
  }
  
  if(allowCreateNewOne && thisCode == "Null")
  {
    if(validatePossibleClientName(clientName))
    {
      thisCode = generateHawkinsFile("Exeter", getRandomSector(), 5, 1000, "Null", formatClientName(clientName));
    }
  }
  
  return thisCode;
}

String getSetofPropertiesByCitySector(String selectedCity, String selectedSector)
{
  String codes[] = hawkinsLedgerCity.GetKeysAsArray();
  String returnCodes = "";
  
  int i;
  
  for(i = 0 ; i < hawkinsLedgerCity.ItemCount ; i++)
  {
    if((hawkinsLedgerCity.Get(codes[i]) == selectedCity) && (hawkinsLedgerSector.Get(codes[i]) == selectedSector))
    {
      if(returnCodes == "")
      {
        returnCodes = codes[i];
      } else {
        returnCodes = returnCodes.Append(String.Format("[%s", codes[i]));
      }
    }
  }
  
  return returnCodes;
}

String readClientFile(String code)
{
  String fileInfo = "";
  fileInfo = fileInfo.Append(String.Format("# %s", code));
  fileInfo = fileInfo.Append(String.Format("[Name: %s", hawkinsLedgerClientNames.Get(code)));
  fileInfo = fileInfo.Append("[PROPERTY:");
  fileInfo = fileInfo.Append(String.Format("[ %s", hawkinsLedgerCity.Get(code)));
  fileInfo = fileInfo.Append(String.Format("[ %s", hawkinsLedgerSector.Get(code)));
  String ageString = hawkinsLedgerPropertyAge.Get(code);
  int ageInt = ageString.AsInt;
  fileInfo = fileInfo.Append(String.Format("[ %d (%d years old)", 1897 - ageInt, ageInt));
  return fileInfo;
}

//##### NOTEBOOK #####
String getNoteDescription(String key) // returns the description associated with the title for taken notes
{
  return notes.Get(key);
}

function takeNote() // adds a note in the notepad
{
  notes.Set(Notable_title, Notable_description);
  lbNoteTitles.AddItem(Notable_title);
  if (Game.DoOnceOnly(Notable_description)) {
    GiveScore(Notable_score);
  }
}

function makeNotable(String title, String description, int score) // overrides the last notable thing
{
  Notable_title = title;
  Notable_description = description;
  Notable_score = score;
}

function notableRead(String title, String description,  int score) // Displays something and make it notable (establish the added score if noted too)
{
  if(player.HasInventory(iNotebook))
  {
    makeNotable(title,  description,  score);
    Display(String.Format("%s*", description));
  } else {
    Display(description);
  }
}

function notableThought(String title, String description,  int score) // both make the player think something and make it notable (establish the added score if noted too)
{
  if(player.HasInventory(iNotebook))
  {
    makeNotable(title,  description,  score);
    player.Think(String.Format("%s*", description));
  } else {
    player.Think(description);
  }
}

function notableSay(Character* who, String title, String description,  int score) // both make a character say something and make it notable (establish the added score if noted too)
{
  if(player.HasInventory(iNotebook))
  {
    makeNotable(title,  description,  score);
    who.Say(String.Format("%s*", description));
  } else {
    who.Say(description);
  }
}

function sit(elementType eT, int index, Character* who, int sittingView, bool alreadySat) // make the character sit on an appropriately setup element
{
  String redir;
  
  switch(eT)
  {
    case roomObjects:
      if(who == player) {
        redir = object[index].GetTextProperty("sit_Direction");
        if(redir.StartsWith("redir", eCaseInsensitive))
        {
          redir = redir.Replace("redir", "", eCaseInsensitive);
          index = redir.AsInt;
        }
      }
      if(object[index].GetTextProperty("sit_Direction") == "Null")
      {
        who.Think("I cannot sit on this.");        
      } else if(!isCharacterNearObject(object[index], reachDistance, who))
      {
        who.Think(String.Format("I cannot reach the %s from here", object[index].Name.LowerCase()));
      } else
      {
        who.Move(object[index].X + object[index].GetProperty("sit_deltaX"), object[index].Y + object[index].GetProperty("sit_deltaY"), eBlock, eAnywhere);
        who.LockView(sittingView, eStopMoving);
        if(who == player) {
          cHarkersBeard.LockView(6, eKeepMoving);
        }
        who.SetProperty("sitting", index);
        
        if(!alreadySat)
        {
          switch(object[index].GetTextProperty("sit_Direction"))
          {
            case "down":
              who.Animate(0, 6, eOnce, eNoBlock, eForwards);
              break;
            case "left":
              who.Animate(1, 6, eOnce, eNoBlock, eForwards);
              break;
            case "right":
              who.Animate(2, 6, eOnce, eNoBlock, eForwards);
              break;
            case "down":
              who.Animate(3, 6, eOnce, eNoBlock, eForwards);
              break;
            default:
              //debugDisplay(String.Format("Tried to sit on object #%d, %s, 'sit_Direction' is wrong", index, object[index].Name));
              break;
          }
          if(who == player)
          {
            switch(object[index].GetTextProperty("sit_Direction"))
            {
              case "down":
                cHarkersBeard.Animate(0, 6, eOnce, eBlock, eForwards);
                break;
              case "left":
                cHarkersBeard.Animate(1, 6, eOnce, eBlock, eForwards);
                break;
              case "right":
                cHarkersBeard.Animate(2, 6, eOnce, eBlock, eForwards);
                break;
              case "down":
                cHarkersBeard.Animate(3, 6, eOnce, eBlock, eForwards);
                break;
              default:
                //debugDisplay(String.Format("Tried to sit on object #%d, %s, 'sit_Direction' is wrong", index, object[index].Name));
                break;
            }
          }
        } else {
          //debugDisplay(String.Format("%s is sitting[View = %d[Frame = %d", who.Name, sittingView, who.Frame));
          who.Frame = nbFrameInSittingAnim;
        }
        if(who == player)
        {
          mouse.Mode = eModePointer;
          KeyboardMovement.Mode = eKeyboardMovementModeNone;
        }
      }
      break;
    default:
      break;
  }
}

function standUp(Character* who,  int walkingView) // the player stands up
{
  if(who.GetProperty("sitting") > -1)
  {
    who.Animate(player.Loop, 6, eOnce, eNoBlock,  eBackwards);
    if(who == player)
    {
      cHarkersBeard.Animate(player.Loop, 6, eOnce, eBlock, eBackwards);
    }
    who.LockView(walkingView, eKeepMoving);
    if(who == player)
    {
      cHarkersBeard.LockView(5, eKeepMoving);
    }
    who.PlaceOnWalkableArea();
    who.SetProperty("sitting", -1);
    if(who == player)
    {
      mouse.Mode = eModeWalkto;
      KeyboardMovement.Mode = eKeyboardMovementModeTapping;
    }
  } else {
    who.Think("I am not sitting");
  }
}

//##### PARSE COMMAND REACTIONS FUNCTIONS #####
function unhandled_event(int what, int type) // called when a runInteraction is called on something without an appropriate event handler
{
  switch(what)
  {
    case 2: // room object
      switch(type)
      {
        case 1: // use/interact with object
          player.Think("I am not sure what to use this for");
          break;
        case 3: // use inventory item on object
          break;
        default:
          break;
      }
      break;
    case 1: // hotspot
      switch(type)
      {
        case 2: // use/interact with hotspot
          player.Think("I am not sure what to use this for");
          break;
        case 3: // use inventory item on hotspot
          break;
        default:
          break;
      }
      break;
    case 3: // character
      switch(type)
      {
        case 1: // use/interact character
          player.Think("I am not sure what to use them for");
          break;
        case 3: // use inventory item on character
          break;
        default:
          break;
      }
      break;
    case 5: // inventory item
      switch(type)
      {
        case 1: // use/interact with inventory item
          player.Think("I am not sure what to use this for");
          break;
        case 3: // use inventory item on inventory item
          break;
        default:
          break;
      }
      break;
    case 4: // nothing
      switch(type)
      {
        case 2: // use/interact with nothing
          player.Think("I am not sure what to use");
          break;
        case 3: // use inventory item on nothing
          break;
        default:
          break;
      }
      break;
    default:
      break;
  }
}

int findRoomObjectIndexByName(String objectName) // returns the object index of an object named
{
  int i = Room.ObjectCount - 1;
  int foundMatch = -1;
  
  while(i >= 0 && foundMatch == -1)
  {
    if(object[i].Name.LowerCase() == objectName.LowerCase())
    {
      foundMatch = i;
    } else {
      i--;
    }
  }
  
  return foundMatch;
}

String[] findElementIndexByName(String cmd) // returns anString array with array[0] being the index and array[1] being the element type,  both as Strings!!!
{
  int i;
  int y;
  String testedStrings[];
  String allPossibleNames;
  String finalIndex;
  String finalElementType;
  bool foundMatch;
  float distanceFromPlayer;
  String tempArray[];
  float tempArrayF[];
  String returnArray[] = new String[2];
  
  int nbObjects = Room.ObjectCount;
  int nbHotpots = 50;
  int nbCharacters = Game.CharacterCount;
  int nbInventoryItems = Game.InventoryItemCount;//don't forget the index start at one
  Dictionary* correspondingRoomElements = Dictionary.Create(eSorted, eCaseInsensitive);
  
  //OBJECTS
  for(i = 0; i < (nbObjects); i++)
  {
    allPossibleNames = object[i].Name.Append(", ");
    if(object[i].GetTextProperty("alternateNames") != "")
    {
      allPossibleNames = allPossibleNames.Append(object[i].GetTextProperty("alternateNames"));
      allPossibleNames = allPossibleNames.Append(", ");
    }
    //debugDisplay(allPossibleNames);
    testedStrings = split(allPossibleNames, ", ");
    int testedStringsLength = testedStrings[0].AsInt;
    y = 1;
    foundMatch = false;
    while(y < testedStringsLength && !foundMatch)
    {
      //debugDisplay(String.Format("Trying to find : %s[In : %s", testedStrings[y], cmd));
      if(object[i].Name != "" && testedStrings[y] != "" && cmd.IndexOf(testedStrings[y]) != -1)
      {
        //debugDisplay(String.Format("Found something![Name: %s[Visible: %d[IwI: %d", object[i].Name, object[i].Visible, object[i].GetProperty("InteractableWhenInvisible")));
        if(object[i].Visible || object[i].GetProperty("InteractableWhenInvisible"))
        {
          //debugDisplay("FOUND IT !!");
          foundMatch = true;
          distanceFromPlayer = calculateDistanceFromCharacter(getObjectMidX(object[i]), object[i].Y, player);
          correspondingRoomElements.Set(String.Format("%d_%s", i, etToString(roomObjects)), String.Format("%d", FloatToInt(distanceFromPlayer)));
        } else {
          //debugDisplay("Skipped on visibility !!");
          y++;
        }
      } else {
        y++;
      }
    }
  }
  
  //HOTSPOTS
  for(i = 0; i < (nbHotpots); i++)
  {
    allPossibleNames = hotspot[i].Name.Append(", ");
    allPossibleNames = allPossibleNames.Append(hotspot[i].GetTextProperty("alternateNames"));
    testedStrings = split(allPossibleNames, ", ");
    int testedStringsLength = testedStrings[0].AsInt;
    y = 1;
    foundMatch = false;
    while(y < testedStringsLength && !foundMatch)
    {
      if(hotspot[i].Name != "" && cmd.IndexOf(testedStrings[y]) != -1)
      {
        foundMatch = true;
        distanceFromPlayer = calculateDistanceFromCharacter(hotspot[i].WalkToX, hotspot[i].WalkToY, player);
        correspondingRoomElements.Set(String.Format("%d_%s", i, etToString(roomHotspots)), String.Format("%d", FloatToInt(distanceFromPlayer)));
      } else {
        y++;
      }
    }
  }
  
  //CHARACTERS
  for(i = 0; i < (nbCharacters); i++)
  {
    allPossibleNames = character[i].Name.Append(", ");
    allPossibleNames = allPossibleNames.Append(character[i].GetTextProperty("alternateNames"));
    testedStrings = split(allPossibleNames, ", ");
    int testedStringsLength = testedStrings[0].AsInt;
    y = 1;
    foundMatch = false;
    while(y < testedStringsLength && !foundMatch)
    {
      //debugDisplay(String.Format("testString: %s", testedStrings[y]));
      if(character[i].Room == player.Room && character[i].Name != "" && cmd.IndexOf(testedStrings[y]) != -1)
      {
        foundMatch = true;
        distanceFromPlayer = calculateDistanceFromCharacter(character[i].x, character[i].y,  player);
        correspondingRoomElements.Set(String.Format("%d_%s", i, etToString(allCharacters)), String.Format("%d", FloatToInt(distanceFromPlayer)));
      } else {
        y++;
      }
    }
  }
  
  //INVENTORY ITEMS
  for(i = 1; i <= (nbInventoryItems); i++)//inventory item index start at 1
  {
    allPossibleNames = inventory[i].Name.Append(", ");
    allPossibleNames = allPossibleNames.Append(inventory[i].GetTextProperty("alternateNames"));
    testedStrings = split(allPossibleNames, ", ");
    int testedStringsLength = testedStrings[0].AsInt;
    y = 1;
    foundMatch = false;
    
    while(y < testedStringsLength && !foundMatch)
    {
      if(player.HasInventory(inventory[i]) && inventory[i].Name != "" && cmd.IndexOf(testedStrings[y]) != -1)
      {
        foundMatch = true;
        if(cmd.IndexOf(" my ") != -1)
        {
          distanceFromPlayer = 0.0;
        } else {
          distanceFromPlayer = 400.0;
        }
        correspondingRoomElements.Set(String.Format("%d_%s", i, etToString(allInventoryItems)), String.Format("%d", FloatToInt(distanceFromPlayer)));
      } else {
        y++;
      }
    }
  }
    
  switch(correspondingRoomElements.ItemCount)
  {
    case 0:
      returnArray[0] = "-1";
      returnArray[1] = "Null";
      break;
    case 1:
      tempArray = correspondingRoomElements.GetKeysAsArray();
      finalIndex = tempArray[0].Truncate(tempArray[0].IndexOf("_"));
      finalElementType = tempArray[0].Replace(finalIndex, "", eCaseInsensitive);
      finalElementType = finalElementType.Replace("_", "", eCaseInsensitive);
      returnArray[0] = finalIndex;
      returnArray[1] = finalElementType;
      break;
    default:
      tempArray = correspondingRoomElements.GetValuesAsArray();
      tempArrayF = new float[correspondingRoomElements.ItemCount];
      for(i = 0; i < correspondingRoomElements.ItemCount; i++)
      {
        tempArrayF[i] = tempArray[i].AsFloat;
      }
      tempArray = correspondingRoomElements.GetKeysAsArray();
      returnArray = findClosestElement(tempArray, tempArrayF, correspondingRoomElements.ItemCount);
      break;
  }  
  
  return returnArray;
}

String findVerbInDictionary(String cmd) // finds the verb in the verbDictionary
{
  int i = verbDictionary.ItemCount -1;
  bool foundVerb = false;
  int stringPosition = -1;
  String verbs[] = verbDictionary.GetKeysAsArray();
   
  while(!foundVerb && i > -1){
    stringPosition = cmd.IndexOf(verbs[i]);
    if(stringPosition == -1) {
      i--;
    } else {
      foundVerb = true;
    }
  }
  
  if(i == -1) 
  {
    return "Null";
  } else {
    return verbDictionary.Get(verbs[i]);
  }
}

// this function allows 2 inventory items to be merged together (keeps one,  modifies its parameters and removes the other)
function fitInventoryItemsTogether(InventoryItem* keptItem, InventoryItem* fittedItem, String newKeptItemName, int newItemGraphic, bool ReplaceDesc_orAppend, String newItemDescription, int AddedScore)
{
  String oldDescription = keptItem.GetTextProperty("TextDescription");
  String oldName = keptItem.Name;
  
  keptItem.Name = newKeptItemName;
  if(ReplaceDesc_orAppend)
  {
    keptItem.SetTextProperty("TextDescription", newItemDescription);
  } else {
    keptItem.SetTextProperty("TextDescription", oldDescription.Append(String.Format(" %s", newItemDescription)));
  }
  keptItem.Graphic = newItemGraphic;
  player.LoseInventory(fittedItem);
  if(AddedScore > 0){
    if (Game.DoOnceOnly(String.Format("Fit %s in %s", fittedItem.Name, oldName))) {
      GiveScore(AddedScore);
    }
  }
}

Set* breakWrittenContentByPage(String fullMessage, String pageBreakSymbol)
{
    Set* returnSet = Set.Create(eSorted);
    String currentPage;
    int currentPageNumber = 1;
    
    while(fullMessage.IndexOf(pageBreakSymbol) != -1)
    {
      currentPage = fullMessage.Truncate(fullMessage.IndexOf(pageBreakSymbol));
      currentPage = currentPage.Replace(pageBreakSymbol, "", eCaseInsensitive);
      fullMessage = removeOneStringInstance(fullMessage, currentPage.Append(pageBreakSymbol));
      currentPage = String.Format("PAGE %d[%s", currentPageNumber, currentPage);
      returnSet.Add(currentPage);
      
      currentPageNumber++;
    }
    fullMessage = String.Format("PAGE %d[%s", currentPageNumber, fullMessage);
    returnSet.Add(fullMessage);
    
    return returnSet;
}

function readThis(String fullMessage, String pageSeparator)
{
  Set* readContent = breakWrittenContentByPage(fullMessage, pageSeparator);
  String readContentToDisplay[] = readContent.GetItemsAsArray();
  int i;
  for(i = 0 ; i < readContent.ItemCount ; i++)
  {
    Display(readContentToDisplay[i]);
  }
}

bool interact(String indexElementVerbHandled[]) // reacts appropriately based on the index,  element and verb passed (reactions detailed in this function's switch)
{
  int index = indexElementVerbHandled[0].AsInt;
  elementType eT = stringToET(indexElementVerbHandled[1]);
  String verb = indexElementVerbHandled[2];
  String lookDescription;
  int alternateSpriteNumber;
  int walkableAreaNumber;
  bool handledInteraction = true;
  
  Set* readContent;
  String readContentToDisplay[];
  int i;
  
  switch (verb)
  {
    case "look":
      switch (eT)
      {
        case roomObjects:
          if(object[index].Visible || object[index].GetProperty("InteractableWhenInvisible"))
          {
            lookDescription = object[index].GetTextProperty("TextDescription");
            if(object[index].GetProperty("tellsTime"))
            {
              lookDescription = addTimeToDescription(lookDescription);
            }
            player.FaceObject(object[index], eBlock);
            player.Say(lookDescription);
          } else {
            player.Say("I'm not sure what I'm looking at...");
          }
          break;
        case roomHotspots:
          lookDescription = hotspot[index].GetTextProperty("TextDescription");
          if(hotspot[index].GetProperty("tellsTime"))
            {
              lookDescription = addTimeToDescription(lookDescription);
            }
          player.FaceLocation(hotspot[index].WalkToX, hotspot[index].WalkToY, eBlock);
          player.Say(lookDescription);
          break;
        case allCharacters:
          if(character[index].Transparency < 100){
            lookDescription = character[index].GetTextProperty("TextDescription");
            player.FaceCharacter(character[index], eBlock);
            player.Say(lookDescription);
          } else {
            player.Say("I'm not sure what I'm looking at...");
          }
          break;
        case allInventoryItems:
          lookDescription = inventory[index].GetTextProperty("TextDescription");
          player.FaceDirection(eDirectionDown, eBlock);
          if(inventory[index].GetProperty("tellsTime"))
            {
              lookDescription = addTimeToDescription(lookDescription);
            }
          player.Say(lookDescription);
          break;
        default:
          player.Say("I'm not sure what I'm looking at...");
          break;
      }
      break;
    case "open":
      switch(eT)
      {
        case roomObjects:
          alternateSpriteNumber = object[index].GetProperty("Open_SpriteNumber");
          walkableAreaNumber = object[index].GetProperty("WalkableArea_opened");
          if(alternateSpriteNumber == -1)
          {
            player.Think("I cannot open this");
          } else if(isCharacterNearObject(object[index], reachDistance,  player))
          {
            if(alternateSpriteNumber == -2) {
              if(!object[index].Visible)
              {
                player.Think("It is already opened");
              } else {
                object[index].Visible = false;
              }
            } else if(object[index].Graphic == alternateSpriteNumber)
            {
              if(object[index].Visible)
              {
                player.Think("It is already opened");
              } else {
                object[index].Visible = true;
              }
            } else {
              object[index].Graphic = alternateSpriteNumber;
            }
            if(walkableAreaNumber != -1)
            {
              RestoreWalkableArea(walkableAreaNumber);
            }
          } else {
            player.Think("I can't reach from here");
          }
          break;
        case allInventoryItems:
          alternateSpriteNumber = inventory[index].GetProperty("Open_SpriteNumber");
          if(alternateSpriteNumber == -1)
          {
            player.Think("I cannot open this");
          } else if(inventory[index].Graphic == alternateSpriteNumber) 
          {
            player.Think("It is already opened");
          } else {
            inventory[index].Graphic = alternateSpriteNumber;
          }
          break;
        default:
          player.Think("I cannot open this");
          break;
      }
      break;
    case "close":
      switch(eT)
      {
        case roomObjects:
          alternateSpriteNumber = object[index].GetProperty("Close_SpriteNumber");
          walkableAreaNumber = object[index].GetProperty("WalkableArea_opened");
          if(alternateSpriteNumber == -1)
          {
            player.Think("I cannot close this");
          } else if(isCharacterNearObject(object[index], reachDistance,  player))
          {
            if(alternateSpriteNumber == -2) 
            {
              if(!object[index].Visible)
              {
                player.Think("It is already closed");
              } else {
                object[index].Visible = false;
              }
            } else if(object[index].Graphic == alternateSpriteNumber)
            {
              if(object[index].Visible)
              {
                player.Think("It is already closed");
              } else {
                object[index].Visible = false;
              }
            } else {
              object[index].Graphic = alternateSpriteNumber;
            }
            if(walkableAreaNumber != -1)
            {
              RemoveWalkableArea(walkableAreaNumber);
            } 
          } else {
            player.Think("I can't reach from here");
          }
          break;
        case allInventoryItems:
          alternateSpriteNumber = inventory[index].GetProperty("Close_SpriteNumber");
          if(alternateSpriteNumber == -1)
          {
            player.Think("I cannot close this");
          } else if(inventory[index].Graphic == alternateSpriteNumber) 
          {
            player.Think("It is already closed");
          } else {
            inventory[index].Graphic = alternateSpriteNumber;
          }
          break;
        default:
          player.Think("I cannot close this");
          break;
      }
      break;
    case "approach":
      if(!showHints){
        player.Think("I can walk there on my own");
      } else {
        switch(eT)
        {
          case roomObjects:
            player.Walk(object[index].X, object[index].Y, eNoBlock, eWalkableAreas);
            break;
          case roomHotspots:
            player.Walk(hotspot[index].WalkToX, hotspot[index].WalkToY, eNoBlock, eWalkableAreas);
            break;
          case allCharacters:
            player.Walk(character[index].x, character[index].y, eNoBlock, eWalkableAreas);
            break;
          default:
            player.Think("I am not not where to go");
            break;
        }
      }
      break;
    case "sit":
      sit(eT, index, player, 2,  false);
      break;
    case "take":
      if(eT == roomObjects)
      {
        if(object[index].GetProperty("takable") != -1)
        {
          if(isCharacterNearObject(object[index], reachDistance, player))
          {
            player.Think("This can be useful");
            player.AddInventory(inventory[object[index].GetProperty("takable")]);
            object[index].Visible = false;
            GiveScore(1);
          } else {
            player.Think("I need to go a little closer");
          }
        } else {
          player.Think("I would rather leave this where it is");
        }
      }
      break;
    case "talk":
      switch (eT)
      {
        case allCharacters:
          if(character[index].Room != player.Room)
          {
            player.Think("I am not sure whom to speak to");
          } else
          {
            if (character[index].GetProperty("dialogIndex") == -1)
            {
              player.FaceCharacter(character[index], eBlock);
              player.Think("I do not know what I should say.");
            } else 
            {
              if (character[index].GetProperty("dialogMaxDistance") > -1 && !isCharacterNearCharacter(character[index], IntToFloat(character[index].GetProperty("dialogMaxDistance")), player))
              {
                player.FaceCharacter(character[index], eBlock);
                player.Think(String.Format("%s will not hear me from this distance", character[index].Name));
              } else 
              {
                if (character[index].GetProperty("dialogWhileSitting") != -1 && (player.GetProperty("sitting") != character[index].GetProperty("dialogWhileSitting")))
                {
                player.FaceCharacter(character[index], eBlock);
                  player.Think(String.Format("Politeness dictates that I should sit in the %s before speaking to %s", object[character[index].GetProperty("dialogWhileSitting")].Name.LowerCase(), character[index].Name));
                } else
                {
                  dialog[character[index].GetProperty("dialogIndex")].Start();
                }
              }
            }
          }
          break;
        default:
          player.Think("I am not sure whom to speak to");
          break;
      }
      break;
    case "read":
      if(eT == allInventoryItems && inventory[index].GetTextProperty("ReadDisplay") != "Null")
      {
        readThis(inventory[index].GetTextProperty("ReadDisplay"), "¶");
      } else {
        player.Think("I cannot read this");
      }
      break;
    default:
      handledInteraction = false;
      break;
  }
  return handledInteraction;
}

function findElementContaining(String keyword) // makes a list of found things reacting to the 'find' keyword
{
  int i;
  bool intro = false;
  bool invIntro = false;
  String nameAndAKA;
  String article = "";
  String allElementsMentionned = "";
  
  //OBJECTS IN THE ROOM
  for(i = 0; i < Room.ObjectCount; i++) {
    nameAndAKA = object[i].Name;
    if(object[i].GetTextProperty("alternateNames") != "")
    {
      nameAndAKA = nameAndAKA.Append(", ");
      nameAndAKA = nameAndAKA.Append(object[i].GetTextProperty("alternateNames"));
    }
    if(nameAndAKA.IndexOf(keyword) != -1) {
      if(!intro)
      {
        player.Say("Looking around, I can spot...");
        intro = true;
      }
      player.FaceObject(object[i], eBlock);
      article = whichArticle(allElementsMentionned, object[i].Name);
      player.Say(String.Format("%s %s over there.", article,  object[i].Name));
      allElementsMentionned = allElementsMentionned.Append(String.Format("%s ", object[i].Name));
    }
  }
  //HOTSPOTS IN THE ROOM
  for(i = 0; i < 50; i++) {
    nameAndAKA = hotspot[i].Name;
    if(hotspot[i].GetTextProperty("alternateNames") != "")
    {
      nameAndAKA = nameAndAKA.Append(", ");
      nameAndAKA = nameAndAKA.Append(hotspot[i].GetTextProperty("alternateNames"));
    }
    if(nameAndAKA.IndexOf(keyword) != -1) {
      if(!intro)
      {
        player.Say("Looking around, I can spot...");
        intro = true;
      }
      player.FaceLocation(hotspot[i].WalkToX, hotspot[i].WalkToY, eBlock);
      article = whichArticle(allElementsMentionned, hotspot[i].Name);
      player.Say(String.Format("%s %s over there.", article,  hotspot[i].Name));
      allElementsMentionned = allElementsMentionned.Append(String.Format("%s ", hotspot[i].Name));
    }
  }
  //CHARACTERS IN THE ROOM
  for(i = 0; i < Game.CharacterCount; i++) {
    nameAndAKA = character[i].Name;
    if(character[i].GetTextProperty("alternateNames") != "")
    {
      nameAndAKA = nameAndAKA.Append(", ");
      nameAndAKA = nameAndAKA.Append(character[i].GetTextProperty("alternateNames"));
    }
    if(nameAndAKA.IndexOf(keyword) != -1 && player.Room == character[i].Room) {
      if(!intro)
      {
        player.Say("Looking around, I can spot...");
        intro = true;
      }
      player.FaceCharacter(character[i]);
      player.Say(String.Format("%s over there.", character[i].Name));
    }
  }
  //OWNED INVENTORY ITEMS
  for(i = 1; i <= Game.InventoryItemCount; i++) {
    nameAndAKA = inventory[i].Name;
    if(inventory[i].GetTextProperty("alternateNames") != "")
    {
      nameAndAKA = nameAndAKA.Append(", ");
      nameAndAKA = nameAndAKA.Append(inventory[i].GetTextProperty("alternateNames"));
    }
    if(nameAndAKA.IndexOf(keyword) != -1 && player.HasInventory(inventory[i])) {
      if(!invIntro)
      {
        if(intro)
        {
          player.Say("Also...");
        }
        player.Say("In my inventory, I can spot...");
        invIntro = true;
        intro = true;
      }
      player.FaceDirection(eDirectionDown);
      article = whichArticle(allElementsMentionned, inventory[i].Name);
      player.Say(String.Format("%s %s.", article, inventory[i].Name));
      allElementsMentionned = allElementsMentionned.Append(String.Format("%s ", inventory[i].Name));
    }
  }
}

function useInteraction(String cmd) // either 'interact' or 'UseInv' version of runInteraction is used
{
  String OnSynonym = isInteractionOnElement(cmd);
  String useSynonym = cmdStartsWithUSEsynonym(cmd);
  
  String cmdUsed;
  String cmdOn;
  
  String indexElementUsed[] = new String[2];
  elementType eTUsed;
  int indexUsed;
  bool canUse = true;
  
  String indexElementOn[] = new String[2];
  elementType eTOn;
  int indexOn;
  
  elementType eTTemp;
  int indexTemp;
  
  if(OnSynonym == "Null") // there is only one verb (use) and a target
  {
      cmd = removeOneStringInstance(cmd, useSynonym.Append(" ")); // HEREE
      indexElementUsed = findElementIndexByName(cmd);
      
      if(indexElementUsed[1] == "Null")
      {
        player.Think("I am not sure what to use");
      } else {
        eTUsed = stringToET(indexElementUsed[1]);
        indexUsed = indexElementUsed[0].AsInt;
        switch(eTUsed)
        {
          case roomObjects:
            if(isCharacterNearObject(object[indexUsed], reachDistance, player))
            {
              object[indexUsed].RunInteraction(eModeInteract);
            } else {
              player.Think(String.Format("I need to get closer to the %s to use it", object[indexUsed].Name.LowerCase()));
            }
            break;
          case roomHotspots:
            if(isCharacterNearHotspot(hotspot[indexUsed], reachDistance, player))
            {
              hotspot[indexUsed].RunInteraction(eModeInteract);
            } else {
              player.Think(String.Format("I need to get closer to the %s to use it", hotspot[indexUsed].Name.LowerCase()));
            }
            break;
          case allInventoryItems:
            if(player.HasInventory(inventory[indexUsed]))
            {
              inventory[indexUsed].RunInteraction(eModeInteract);
            } else {
              player.Think("I am not sure what you want me to use");
            }
            break;
          default:
            player.Think("I am not sure what you want me to use");
            break;
        }
      } 
  } else // The player wants to use something on/with something
  {
    cmd = removeOneStringInstance(cmd, useSynonym.Append(" "));
    cmdUsed = cmd.Truncate(cmd.IndexOf(OnSynonym));
    cmd = removeOneStringInstance(cmd, cmdUsed);
    cmdOn = removeOneStringInstance(cmd, OnSynonym);
    
    indexElementUsed = findElementIndexByName(cmdUsed);
    indexElementOn = findElementIndexByName(cmdOn);
    
    if(indexElementOn[1] == "Null" || indexElementUsed[1] == "Null")
    {
      player.Think("I am not sure what you want me to do");
    } else {
      eTUsed = stringToET(indexElementUsed[1]);
      indexUsed = indexElementUsed[0].AsInt;
      eTOn = stringToET(indexElementOn[1]);
      indexOn = indexElementOn[0].AsInt;
      
      if(eTOn == allInventoryItems && eTUsed != allInventoryItems) // if the 2nd is an item but not the first,  invert them
      {
        indexTemp = indexOn;
        eTTemp = eTOn;
        indexOn = indexUsed;
        eTOn = eTUsed;
        indexUsed = indexTemp;
        eTUsed = eTTemp;
      }
      if(eTUsed == allCharacters && eTOn != allCharacters) // if the 1st is a character but not the second,  invert them
      {
        indexTemp = indexOn;
        eTTemp = eTOn;
        indexOn = indexUsed;
        eTOn = eTUsed;
        indexUsed = indexTemp;
        eTUsed = eTTemp;
      }
      
      if(eTUsed == allInventoryItems)
      {
        if(!player.HasInventory(inventory[indexUsed]))
        {
          canUse = false;
        }
      } else if (eTUsed == allCharacters)
      {
        if(character[indexUsed].Room != player.Room)
        {
          canUse = false;
        }
      }
          
          
      if(canUse)
      {
        activeElementToUse_ElementType = etToString(eTUsed);
        activeElementToUse_Index = indexUsed;
        
        //debugDisplay(String.Format("%s[%d", activeElementToUse_ElementType, activeElementToUse_Index));
        
        switch(eTOn)
        {
          case roomObjects:
            if(isCharacterNearObject(object[indexOn], reachDistance, player))
            {
              object[indexOn].RunInteraction(eModeUseinv);
            } else {
              player.Think(String.Format("I need to get closer to the %s to use my %s on it", object[indexOn].Name.LowerCase(), inventory[indexUsed].Name.LowerCase()));
            }              
            break;
          case roomHotspots:
            if(isCharacterNearHotspot(hotspot[indexOn], reachDistance, player))
            {
              hotspot[indexOn].RunInteraction(eModeUseinv);
            } else {
              player.Think(String.Format("I need to get closer to the %s to use my %s on it", hotspot[indexOn].Name.LowerCase(), inventory[indexUsed].Name.LowerCase()));
            }
            break;
          case allCharacters:
            if(character[indexOn].Room == player.Room && isCharacterNearCharacter(character[indexOn], reachDistance, player))
            {
              character[indexOn].RunInteraction(eModeUseinv);
            } else {
              player.Think(String.Format("I need to get closer to %s to use my %s on them", hotspot[indexOn].Name.LowerCase(), inventory[indexUsed].Name.LowerCase()));
            }
            break;
          case allInventoryItems:
            if(player.HasInventory(inventory[indexOn]))
            {
              inventory[indexOn].RunInteraction(eModeUseinv);
            } else {
              player.Think("I am not sure what you want me to use");
            }
            break;
          default:
            break;
        }
      } else {
        player.Think("I am not sure what you want me to use");
      }
    }
  }
}

bool globalHighjackIndexElementVerb(String stringIndex, String stringElement, String verb)
{
  bool skipRoomInteraction = false;
  int index = stringIndex.AsInt;
  elementType eT = stringToET(stringElement);
  
  if(eT == allInventoryItems && index == 2 && verb == "read")
  {
    dLedger.Start();
    skipRoomInteraction = true;
  }
  
  return skipRoomInteraction;
}

String[] roomSpecificParse(String cmd) // function that is called by the room to handle the parsing of the command
{
  String elementName;
  String indexElement[] = new String[2];
  String indexElementVerbHandled[] = new String[4];
  indexElementVerbHandled[0] = "Null";
  indexElementVerbHandled[1] = "Null";
  indexElementVerbHandled[2] = "Skip";
  indexElementVerbHandled[3] = "true";
  
  if(cmd.IndexOf("spot ") != -1) {                                                                                         // SPOT KEYWORD
    cmd = cmd.Replace("spot ", "", eCaseInsensitive);
    cmd = cmd.Replace("all ", "", eCaseInsensitive);
    cmd = cmd.Replace("any ", "", eCaseInsensitive);
    findElementContaining(cmd);
  } else if(cmd.LowerCase() == "stand" || cmd.IndexOf("stand ") != -1) {                                                    // STAND KEYWORD
    standUp(player, 1);
  } else if(cmdStartsWithUSEsynonym(cmd) != "Null") {                                                                       // USE KEYWORDS
    useInteraction(cmd);
  } else if(cmd.StartsWith("shave", eCaseInsensitive)) {                                                                    // SHAVE KEYWORD
    if(player.HasInventory(iRazor))
    {
      useInteraction("use razor on myself");
    } else {
      player.Think("I need to find my razor to shave");
    }
  } else if (cmd.StartsWith("Note ", eCaseInsensitive) || cmd.LowerCase() == "note" || cmd.LowerCase() == "take note") {    // NOTE KEYWORD
    takeNote();
  } else if (cmd.IndexOf("look ") != -1 && cmd.IndexOf(" room") != -1)
  {
    player.Think(Room.GetTextProperty("TextDescription"));
  } else if (cmd.IndexOf("What time is it") != -1)
  {
    if(player.HasInventory(iWatch))
    {
      player.Think(String.Format("It is %s", whatTimeIsIt(true)));
    } else {
      player.Think("I do not have my watch... I do not know what time it is...");
    }
  }
  else
  {
    indexElement = findElementIndexByName(cmd);
    
    indexElementVerbHandled[0] = indexElement[0];
    indexElementVerbHandled[1] = indexElement[1];
    if(indexElement[1] != "Null") {
      indexElementVerbHandled[2] = findVerbInDictionary(cmd);
    } else {
      indexElementVerbHandled[2] = "Null";
    }
  }
  
  if(globalHighjackIndexElementVerb(indexElementVerbHandled[0], indexElementVerbHandled[1], indexElementVerbHandled[2]))
  {
    indexElementVerbHandled[2] = "Skip";
  }
  
  return indexElementVerbHandled;
}

//##### GAME INTERACTIONS ###########


// called on every game cycle, except when the game is blocked
function repeatedly_execute()
{
  currentTime = currentTime + currentTimeIncrementPerLoop;
  if(currentTime > (loopPerSecond*86400)) {
    currentTime = currentTime - (loopPerSecond*86400);
  }
  if(timeUITransparency < 100.0)
  {
    timeUITransparency = timeUITransparency + timeUIFadeSpeed;
    lblCurrentThought.Transparency = FloatToInt(timeUITransparency, eRoundDown);
    if(lblNoteDescriptionHighlight.Transparency < 100)
    {
      lblNoteDescriptionHighlight.Transparency = lblNoteDescriptionHighlight.Transparency + 1;
    }
  }
}

// called on every game cycle, even when the game is blocked
function repeatedly_execute_always()
{
  if(cHarkersBeard.Transparency < 100 && cHarker.GetProperty("sitting") == -1) // in REAlways,  becase we want it to continue even when a 'eBlock' animation is running
  {
    cHarkersBeard.FaceDirection(cHarker.Loop);
  }
}

function fillInventoryListBox ()
{
  int i;
  bool img = false;
  String itemDescription;
  lbInventory.Clear();
  
  for(i = Game.InventoryItemCount ; i > 0 ; i--) 
  {
    if(player.HasInventory(inventory[i]))
    {
      lbInventory.AddItem(inventory[i].Name);
      if(img == false) {
        imgSelectedInv.NormalGraphic = inventory[i].Graphic;
        itemDescription = inventory[i].GetTextProperty("TextDescription");
        if(inventory[i].GetProperty("tellsTime"))
            {
              itemDescription = addTimeToDescription(itemDescription);
            }
        lblDescriptionSelectedItem.Text = itemDescription;
        img = true;
      }
    }
  }
}

function show_inventory_window()
{
  fillInventoryListBox();
  open_gui(gInventory);
}

// called when a key is pressed
function on_key_press(eKeyCode keycode, int mod)
{
  // check for Escape first, so it can be used on GUIs that pause the game
  if (keycode == eKeyEscape)
  {
    if (gRestart.Visible)
    {
      // Escape will cancel a restart
      close_gui(gRestart);
    }
    else if (gPanel.Visible)
    {
      // Escape will turn the panel off
      close_gui(gPanel);
    }
    else if (gSaveGame.Visible)
    {
      // Escape will close the save game dialog
      close_gui(gSaveGame);
    }
    else if (gRestoreGame.Visible)
    {
      // Escape will close the restore game dialog
      close_gui(gRestoreGame);
    }
    else if (gInventory.Visible)
    {
      // Escape will close the restore game dialog
      close_gui(gInventory);
    }
    else if (gExitGame.Visible)
    {
      // Escape will cancel exiting the game
      close_gui(gExitGame);
    }
    else if (gParser.Visible) {
      // Escape will cancel the text parser
      close_gui(gParser);
    }
    else
    {
      // Escape will turn the panel on
      open_gui(gPanel);
    }
  }
  else if (keycode == eKeyF4)
  {
    if(lblCurrentThought.Transparency < 100)
    {
      if(gParser.Visible) {
        tbParser.Text = tbParser.Text.Append(lblCurrentThought.Text);
      } else if (gSimpleTextbox.Visible) {
        tbSimpleTextbox.Text = tbSimpleTextbox.Text.Append(lblCurrentThought.Text);
      }
    }
  }
  else if (IsGamePaused() || !IsInterfaceEnabled())
  {
    // game paused, so don't react to any keypresses
    keycode = 0;
  }
  else if (keycode == eKeyQ && (mod & eKeyModCtrl))
  {
    // Ctrl-Q will quit the game
    open_gui(gExitGame);
  }
  else if (keycode == eKeyF5)
  {
    // F5 will prompt to save a game
    show_save_game_dialog();
  }
  else if (keycode == eKeyF7)
  {
    // F7 will prompt to save a game
    show_restore_game_dialog();
  }
  else if (keycode == eKeyF9)
  {
    // F9 will prompt to restart the game
    open_gui(gRestart);
  }
  else if (keycode == eKeyF12)
  {
    // F12 will save a screenshot to the save game folder
    SaveScreenShot("screenshot.pcx");
  }
  else if (keycode >= 65 && keycode <= 90)
  {
    open_gui(gParser);
    //debugDisplay(String.Format("%d", keycode));
    tbParser.Text = keycodeToString(keycode);
  }
  else if (keycode == eKeyF3)
  {
    open_gui(gParser);
    //debugDisplay(keycodeToString(keycode));
    tbParser.Text = lastCMD;
  }
  else if (keycode == eKeyTab)
  {
    // Tab opens the inventory
    show_inventory_window();
  }
  else if (mod & eKeyModCtrl)
  {
    if (keycode == eKeyS)
    {
      // Ctrl-S will give the player all defined inventory items
      Debug(0, 0);
    }
    else if (keycode == eKeyV)
    {
      // Ctrl-V will show game engine version and build date
      Debug(1, 0);
    }
    else if (keycode == eKeyA)
    {
      // Ctrl-A will show walkable areas
      Debug(2, 3);
    }
    else if (keycode == eKeyX)
    {
      // Ctrl-X will let the player teleport to any room
      Debug(3, 0);
    }
  }
}

// called when a mouse button is clicked
function on_mouse_click(MouseButton button)
{
  // called when a mouse button is clicked. button is either LEFT or RIGHT
  if (IsGamePaused())
  {
    
    // game is paused, so do nothing (i.e. don't process mouse clicks)
  }
  else if (button == eMouseLeft)
  {
    // left-click, so try using the current mouse cursor mode at this position
    //Room.ProcessClick(mouse.x, mouse.y, mouse.Mode );
    if(player.GetProperty("sitting") == -1)
    {
      player.Walk(mouse.x, mouse.y, eNoBlock, eWalkableAreas);
    } else {
      int destX = mouse.x;
      int destY = mouse.y;
      standUp(player, 1);
      player.Walk(destX, destY, eNoBlock, eWalkableAreas);
    }
  }
}

// triggered when the Inventory button from the gQuickInventory is clicked
function btnIconInv_Click(GUIControl *control, MouseButton button)
{
  show_inventory_window();
}

//START OF CONTROL PANEL FUNCTIONS
function btnSave_OnClick(GUIControl *control, MouseButton button)
{
  close_owning_gui(control);
  show_save_game_dialog();
}

function btnAbout_OnClick(GUIControl *control, MouseButton button)
{
  Display("%s[AGS %s", Game.Name, System.Version);
}

function btnQuit_OnClick(GUIControl *control, MouseButton button)
{
  close_owning_gui(control);
  open_gui(gExitGame);
}

function btnLoad_OnClick(GUIControl *control, MouseButton button)
{
  close_owning_gui(control);
  show_restore_game_dialog();
}

function sldAudio_OnChange(GUIControl *control)
{
  System.Volume = sldAudio.Value;
}

function btnDefault_OnClick(GUIControl *control, MouseButton button)
{
  set_default_options();
}

function sldSpeed_OnChange(GUIControl *control)
{
  SetGameSpeed(sldSpeed.Value);
}

function btnRestart_OnClick(GUIControl *control, MouseButton button)
{
  close_owning_gui(control);
  open_gui(gRestart);
}

function btnRestartYes_OnClick(GUIControl *control, MouseButton button)
{
  RestartGame();
}

int find_save_slot(String name)
{
  bool slots[] = new bool[999];
  int i = 0;

  while (i < lstSaveGamesList.ItemCount)
  {
    if (lstSaveGamesList.Items[i] == name)
    {
      // found existing save with matching name
      return lstSaveGamesList.SaveGameSlots[i];
    }

    // remember which slots are already taken
    slots[lstSaveGamesList.SaveGameSlots[i]] = true;
    i ++;
  }

  // find first free save slot, starting with slot 1
  i = 1;

  while (i < 999)
  {
    if (!slots[i])
    {
      return i;
    }

    i ++;
  }

  // no free slots found
  return -1;
}

function btnSaveGame_OnClick(GUIControl *control, MouseButton button)
{
  int gameSlotToSaveInto = find_save_slot(txtNewSaveName.Text);

  if (gameSlotToSaveInto < 0)
  {
    Display("No more free save slots!");
  }
  else
  {
    SaveGameSlot(gameSlotToSaveInto, txtNewSaveName.Text);
    close_owning_gui(control);
  }
}

function btnRestoreGame_OnClick(GUIControl *control, MouseButton button)
{
  close_gui(gPanel);
  
  if (lstRestoreGamesList.SelectedIndex >= 0)
  {
    RestoreGameSlot(lstRestoreGamesList.SaveGameSlots[lstRestoreGamesList.SelectedIndex]);
  }
  
  close_owning_gui(control);
  
}

function lstSaveGamesList_OnSelectionCh(GUIControl *control)
{
  txtNewSaveName.Text = lstSaveGamesList.Items[lstSaveGamesList.SelectedIndex];
}

function txtNewSaveName_OnActivate(GUIControl *control)
{
  // pressing Return in the text box simulates clicking the save button
  btnSaveGame_OnClick(control, eMouseLeft);
}

function btnDeleteSave_OnClick(GUIControl *control, MouseButton button)
{
  if (lstSaveGamesList.SelectedIndex >= 0)
  {
    DeleteSaveSlot(lstSaveGamesList.SaveGameSlots[lstSaveGamesList.SelectedIndex]);
    lstSaveGamesList.FillSaveGameList();
  }
}

function btnConfirmedQuit_OnClick(GUIControl *control, MouseButton button)
{
  QuitGame(0);
}

function lbInventory_OnSelectionChanged(GUIControl *control)
{
  int i = Game.InventoryItemCount;
  String itemName = lbInventory.Items[lbInventory.SelectedIndex];
  bool foundMatch = false;
  
  while(i > 0 && !foundMatch) 
  {
    if(inventory[i].Name == itemName)
    {
      imgSelectedInv.NormalGraphic = inventory[i].Graphic;
      lblDescriptionSelectedItem.Text = inventory[i].GetTextProperty("TextDescription");
      foundMatch = true;
    } else {
      i--;
    }
  }
  
  
}

function btnToggleHints_OnClick(GUIControl *control, MouseButton button)
{
  if(showHints)
  {
    lblOverHotspot.Visible = false;
    lblOverHotspot.Text = "";
    btnToggleHints.Text = "Hints hidden";
    showHints = false;
  } else {
    lblOverHotspot.Text = "@OVERHOTSPOT@";
    lblOverHotspot.Visible = true;
    btnToggleHints.Text = "Hints shown";
    showHints = true;
  }
}

function tbParser_OnActivate(GUIControl *control) // function that calls the room function 'on call' with index '1' (to start the text parsing)
{
  //PRESS ENTER
  if(gParser.Visible) {
    String cmd = tbParser.Text;
    lastCMD = cmd;
    //debugDisplay(String.Format("lastCMD = %s", lastCMD));
    CallRoomScript (1);
  }
}

function lbVerbs_OnSelectionChanged(GUIControl *control)
{
  lblHelpVerbDesc.Text = verbDescriptionDictionary.Get(lbVerbs.Items[lbVerbs.SelectedIndex]);
}

function btnHelpPanel_OnClick(GUIControl *control, MouseButton button)
{
  open_gui(gHelp);
  close_gui(gPanel);
}

function btnHelpResume_OnClick(GUIControl *control, MouseButton button)
{
  close_gui(gHelp);
  open_gui(gPanel);
}

function btnConfirmCancel_OnClick(GUIControl *control, MouseButton button)
{
  close_gui(gConfirm);
}

function btnConfirmYes_OnClick(GUIControl *control, MouseButton button)
{
  if(gNotebook.Visible) // delete note
  {
    String noteTitle = lbNoteTitles.Items[lbNoteTitles.SelectedIndex];
    notes.Remove(noteTitle);
    lbNoteTitles.RemoveItem(lbNoteTitles.SelectedIndex);
    lbNoteTitles.SelectedIndex = 0;
    lblNoteDescription.Text = notes.Get(lbNoteTitles.Items[lbNoteTitles.SelectedIndex]);
    btnDeleteNote.Enabled = (lbNoteTitles.ItemCount > 1); // must have at least 2 entries to remove one.
  }
  close_gui(gConfirm);
}

function btnDelete_OnClick(GUIControl *control, MouseButton button)
{
  open_gui(gConfirm);
}

function updateNotebook()
{
  lbNoteTitles.Clear();
  String notesToAdd[] = notes.GetKeysAsArray();
  int i;
  
  for(i = 0 ; i < notes.ItemCount ; i++)
  {
    lbNoteTitles.AddItem(notesToAdd[i]);
  }
  
  lbNoteTitles.SelectedIndex = 0;
  lblNoteDescription.Text = notes.Get(lbNoteTitles.Items[lbNoteTitles.SelectedIndex]);
  btnDeleteNote.Enabled = (notes.ItemCount > 1); // must have at least 2 entries to remove one.  
}

function btnNoteBook_OnClick(GUIControl *control, MouseButton button)
{
  updateNotebook();
  open_gui(gNotebook);
}

function btnResume_notebook_OnClick(GUIControl *control, MouseButton button)
{
  close_gui(gNotebook);
}

function btnLoadAtStart_OnClick(GUIControl *control, MouseButton button)
{
  show_restore_game_dialog();
}

function btnToggleHintsTitleMenu_OnClick(GUIControl *control, MouseButton button)
{
  if(showHints)
  {
    lblOverHotspot.Visible = false;
    lblOverHotspot.Text = "";
    btnToggleHints.Text = "Hints hidden";
    btnToggleHintsTitleMenu.Text = "Hints hidden";
    showHints = false;
  } else {
    lblOverHotspot.Text = "@OVERHOTSPOT@";
    lblOverHotspot.Visible = true;
    btnToggleHints.Text = "Hints shown";
    btnToggleHintsTitleMenu.Text = "Hints shown";
    showHints = true;
  }
}

//##### SCRIPTED CUTSCENES #####

function triggerCutscene(cutsceneIndex index)
{
  if(!skipAllCutscene)
  {
    switch(index)
    {
      case beginQuest:
        object[10].Visible = false; // open bedroom door;
        player.Transparency = 50;
        cHarkersBeard.Transparency = 90;
        Wait(10);
        player.Transparency = 0;
        cHarkersBeard.Transparency = 85;
        player.Walk(54, 170, eBlock, eAnywhere);
        player.FaceDirection(eDirectionLeft, eBlock);
        Wait(5);
        object[10].Visible = true; // close bedroom door;
        Wait(5);
        player.FaceDirection(eDirectionRight, eBlock);
        player.Think("What a night...");
        player.Think("I must have worked on those contracts until 3 AM");
        player.Think("I hope Mr. Hawkins will be happy with them");
        player.Think("I guess I should hurry if I want to make it to work before 10 AM");
        player.Walk(158, 169, eBlock, eAnywhere);
        player.PlaceOnWalkableArea();
        player.FaceDirection(eDirectionDown);
        break;
      case getToWork:
        cHawkins.Say("Ah! Harker!");
        if(isItBeforeThisTime(10, 00, 00, false, 1))
        {
          cHawkins.Say("Good you are on time!");
          if (Game.DoOnceOnly("getToWorkOnTime")) {
              GiveScore(1);
          }
        } else {
          cHawkins.Say("%s![You are late, young man");
        }
        if(cHarkersBeard.Transparency == 100)
        {
          if (Game.DoOnceOnly("shavedHarker")) {
              GiveScore(1);
          }
        } else {
          cHawkins.Say("I would appreciate a clean shaven clerk");
          cHawkins.Say("You are not presentable");
          cHawkins.Say("Anyway.");
        }
        cHawkins.Say("I trust you brought back the contracts from last night");
        cHawkins.Say("Come to my office");
        cHawkins.Walk(object[43].X, object[43].Y, eBlock, eWalkableAreas);
        sit(roomObjects, 43, cHawkins, 4, false);
        break;
      default:
        debugDisplay(String.Format("Cutscene %d is supposed to start but it is not handled by the 'triggerCutscene' function", index));
        break;
    }
  }
  else
  {
    switch(index) // things to do if the cutscene is skipped
    {
      case beginQuest:
        player.x = 158;
        player.y = 169;
        cHarkersBeard.x = player.x;
        cHarkersBeard.y = player.y;
        player.Transparency = 0;
        cHarkersBeard.Transparency = 85;        
        break;
      default:
        break;
    }
  }
}

function btnNewGame_OnClick(GUIControl *control, MouseButton button)
{
  FadeOut(10);
  close_gui(gTitleScreen);
  Wait(20);
  FadeIn(10);
  Wait(40);
  triggerCutscene(beginQuest);
}

//##### IN-GAME INTERACTIONS ######

function cHarker_UseInv()
{
  int shavingGlassObjectIndex = findRoomObjectIndexByName("shaving glass");
  
  //debugDisplay(String.Format("%s[%d", activeElementToUse_ElementType, activeElementToUse_Index));
  
  if(activeElementToUse_ElementType == "allInventoryItems" && activeElementToUse_Index == 3)//razor
  {
    if(cHarkersBeard.Transparency == 100)
    {
      player.Think("I do not need to shave");
    } else if(shavingGlassObjectIndex == -1)
    {
      player.Think("I cannot shave here");
    } else if(!object[shavingGlassObjectIndex].Visible && player.HasInventory(iMirror))
    {
      player.Think("I need to install my shaving glass first");
      player.FaceObject(object[shavingGlassObjectIndex]);
      player.Think("There seems to be an appropriate surface over there");
    } else if(object[shavingGlassObjectIndex].Visible && !isCharacterNearObject(object[shavingGlassObjectIndex], reachDistance, player))
    {
      player.FaceObject(object[shavingGlassObjectIndex]);
      player.Think(String.Format("I need to get closer to the %s", object[shavingGlassObjectIndex].Name));
    } else {
      player.FaceObject(object[shavingGlassObjectIndex]);
      cHarkersBeard.Transparency = 100;
      player.Think("Ah, prefectly smooth");
      if (Game.DoOnceOnly("perfect shave")) {
        GiveScore(1);
      }
    }
  }
}

function iLegalPapers_UseInv()
{
  if(activeElementToUse_ElementType == "allInventoryItems" && activeElementToUse_Index == 7)//folder
  {
    fitInventoryItemsTogether(iLegalPapers, iFolder, "Legal dossier", 124, true, "A folder of contracts I need to bring to Mr. Hawkins.", 1);
    player.Think("Good idea. I will put the contracts in the folder for a neater look");
  }
}

function iFolder_UseInv()
{
  if(activeElementToUse_ElementType == "allInventoryItems" && activeElementToUse_Index == 6)//Legal papers
  {
    fitInventoryItemsTogether(iLegalPapers, iFolder, "Legal dossier", 124, true, "A folder of contracts I need to bring to Mr. Hawkins.", 1);
    player.Think("Good idea. I will put the contracts in the folder for a neater look");
  }
}

function iLedger_Interact()
{
  dLedger.Start();
}

function tbSimpleTextbox_OnActivate(GUIControl *control)
{
  String textInput = tbSimpleTextbox.Text;
  
  close_gui(gSimpleTextbox);
  
  switch(lblSimpleTextbox.Text)
  {
    case "File code":
      if(getClientNameFromCode(textInput, true) != "Null")
      {
        notableThought(String.Format("N. %s", textInput), String.Format("The code %s refers to a seller named: %s",  textInput, hawkinsLedgerClientNames.Get(textInput)), 0);
      } else {
        player.Think(String.Format("%s... %s... I do not think that this is a valid code", textInput, textInput));
      }
      break;
    case "Suggested property code":
      memorize(textInput);
      CallRoomScript(4);
      break;
    default:
      break;
  }
}

function lbNoteTitles_OnSelectionChanged(GUIControl *control)
{
  lblNoteDescription.Text = notes.Get(lbNoteTitles.Items[lbNoteTitles.SelectedIndex]);
}

function highlightWord(String word, GUIControl *originalTextLabel, GUIControl *highlighterLbl, int startX,  int startY)
{
  highlighterLbl.Transparency = 100;
  highlighterLbl.Visible = true;
  highlighterLbl.ZOrder = originalTextLabel.ZOrder + 1;
  //Display(String.Format("GUI: %d", originalTextLabel.OwningGUI.ID)); HEREE !!
  if(startX == 0)
  {
    highlighterLbl.X = startX + originalTextLabel.X;// + originalTextLabel.OwningGUI.X;
  } else {
    highlighterLbl.X = startX + originalTextLabel.X + GetTextWidth(" ", eFontNormal);
  }
  highlighterLbl.Y = startY + originalTextLabel.Y;// + originalTextLabel.OwningGUI.Y;
  highlighterLbl.AsLabel.Text = word;
  highlighterLbl.Width = GetTextWidth(word, eFontNormal) * 2;
  highlighterLbl.Height = GetTextHeight(word, eFontNormal, highlighterLbl.Width);
  highlighterLbl.Transparency = 0;
  memorize(word);
}

String findThatWord(GUIControl* labelName, int clickX, int clickY)
{
  Dictionary* eachWord = Dictionary.Create(eSorted);
  int counter = 0;
  
  String FullText = labelName.AsLabel.Text;
  int lblWidth = labelName.AsLabel.Width;
  
  int spaceIndex = 1000;
  int alineaIndex = 1000;
  int nextCut = 1000;
  String nextCutChar = "";
  
  String thatString = FullText;
  String returnWord;
  
  while(FullText.IndexOf(" ") != -1 || FullText.IndexOf("[") != -1)
  {
    nextCut = 1000;
    nextCutChar = "";
    
    spaceIndex = FullText.IndexOf(" ");
    if(spaceIndex == -1) {
      spaceIndex = 1000;
    } else if (spaceIndex < nextCut) {
      nextCut = spaceIndex;
      nextCutChar = " ";
    }
    alineaIndex = FullText.IndexOf("[");
    if(alineaIndex == -1) {
      alineaIndex = 1000;
    } else if (alineaIndex < nextCut) {
      nextCut = alineaIndex;
      nextCutChar = "[";
    }     
    
    thatString = FullText.Truncate(nextCut);
    thatString = thatString.Replace(" ", "", eCaseInsensitive);
    thatString = thatString.Replace("[", "", eCaseInsensitive);
    eachWord.Set(String.Format("%05d", counter), thatString);
    FullText = removeOneStringInstance(FullText, thatString.Append(nextCutChar));
    counter++;
  }
  eachWord.Set(String.Format("%05d", counter), FullText);
  
  String eachWordArray[] = eachWord.GetValuesAsArray();
  
  thatString = eachWordArray[0];
  int startX = 0;
  int endX = GetTextWidth(thatString, eFontNormal);
  int startY = 0;
  int endY = GetTextHeight(thatString, eFontNormal, lblWidth);
  int newY = GetTextHeight(thatString, eFontNormal, lblWidth);
  int i = 0;
  
  while((i < eachWord.ItemCount - 1) &&
        ((clickX < startX ||
         clickX > endX) ||
        (clickY < startY ||
         clickY > endY)))
  {
    i++;
    thatString = thatString.Append(" ");
    thatString = thatString.Append(eachWordArray[i]);
    newY = GetTextHeight(thatString, eFontNormal, lblWidth);
    if(newY != endY)
    {
      startX = 0;
      endX = GetTextWidth(eachWordArray[i], eFontNormal);
      startY = endY;
      endY = newY;
    } else {
      startX = endX;
      endX = endX + GetTextWidth(eachWordArray[i], eFontNormal) + GetTextWidth(" ", eFontNormal);
    }    
  }
  
  if(i < eachWord.ItemCount) {
    returnWord = eachWordArray[i];
    if(labelName == lblNoteDescription)
    {
      highlightWord(eachWordArray[i], labelName, lblNoteDescriptionHighlight, startX, startY);
    }
  } else {
    returnWord = "";
  }
  
  return returnWord;
}

function btnNoteDescription_OnClick(GUIControl *control, MouseButton button)
{
  int clickX = mouse.x - gNotebook.X - lblNoteDescription.X;
  int clickY = mouse.y - gNotebook.Y - lblNoteDescription.Y;
  
  if(mouse.x > gNotebook.X + lblNoteDescription.X && 
     mouse.x < gNotebook.X + lblNoteDescription.X + lblNoteDescription.Width &&
     mouse.y > gNotebook.Y + lblNoteDescription.Y &&
     mouse.y < gNotebook.Y + lblNoteDescription.Y + lblNoteDescription.Height)
  {
    findThatWord(lblNoteDescription, clickX, clickY);
    //Display(String.Format("Clicked on the text at (%d, %d)", clickX, clickY));
  }
  
}

function btnSimpeTextboxNotebook_OnClick(GUIControl *control, MouseButton button)
{
  open_gui(gNotebook);
}
