/*TO IMPLEMENT


*/

// main global script file
#define NUMBEROFROOMS 11
#define PROPERTIESPERSECTOR 3
#define STANDARDTIMEINCREMENT 2

#define SKIPCUTSCENES false
#define ACTIVATEDEBUGTOOL false


Dictionary* verbDictionary;
Dictionary* verbDescriptionDictionary;
Dictionary* notes;
Set* afterNotebookThoughts;

Dictionary* hawkinsLedgerCity;
Dictionary* hawkinsLedgerSector;
Dictionary* hawkinsLedgerPropertyAge;
Dictionary* hawkinsRequestCity;
Dictionary* hawkinsRequestSector;
Dictionary* hawkinsRequestPropertyAgeMin;
Dictionary* hawkinsRequestPropertyAgeMax;
Dictionary* hawkinsRequestMessage;
Set* hawkinsRequesters;
String proposedSeller;

Set* availableDestinations;
Dictionary* roomForEachTravelDestinations;
Dictionary* x_TravelDestinations;
Dictionary* y_TravelDestinations;
Dictionary* city_TravelDestinations;
int arrival_x[];
int arrival_y[];
CharacterDirection faceDirection[];
int exeterTravelDistanceMultiplier;
int londonTravelDistanceMultiplier;
zone currentZone;

Dictionary* legalPapers;
Set* legalPapers_solution;

Set* possibleClientNames;
float reachDistance = 40.0;
String lastCMD;
int nbFrameInSittingAnim;
int loopPerSecond;
int currentTimeIncrementPerLoop = STANDARDTIMEINCREMENT;
float timeUITransparency;
float timeUIFadeSpeed = 0.1;

bool debugTools;
bool skipAllCutscene;

int useIndex;
elementType useET;

// set default game options
function set_default_options()
{
  System.Volume = 100;
  sldAudio.Value = System.Volume;
  sldSpeed.Value = 40;
  SetGameSpeed(40);
}

// initialize gPanel
function initialize_control_panel()
{
  set_default_options();
}

// hide the icon bar and show a GUI
function open_gui(GUI* gui_to_open)
{
  if (gui_to_open != gInventory)
  {
    lblOverHotspot.Visible = false;
  }

  //gIconbar.Visible = false;
  mouse.UseModeGraphic(eModePointer);
  gui_to_open.Visible = true;
}

// hide the GUI and show the icon bar
function close_gui(GUI* gui_to_close)
{
  gui_to_close.Visible = false;
  mouse.UseDefaultGraphic();
  lblOverHotspot.Visible = true;
  //gIconbar.Visible = true;
}

// hide a GUI, based on a GUI control
function close_owning_gui(GUIControl* control)
{
  close_gui(control.OwningGUI);
}

// hide a GUI directly from an OnClick event
function close_gui_onclick(GUIControl *control, MouseButton button)
{
  close_owning_gui(control);
}

// called when the game starts, before the first room is loaded
function game_start()
{
  // initialize gPanel controls
  initialize_control_panel();

  // set KeyboardMovement movement mode
  KeyboardMovement.Mode = eKeyboardMovementModeTapping;
  
  lastCMD = "";
  nbFrameInSittingAnim = 2;
  loopPerSecond = 40;
  
  player.Transparency = 100;
  mouse.Mode = eModePointer;
  
  currentTime = ((8 * 3600) + (0 * 60) + (0)) * loopPerSecond;
  timeUITransparency = 100.0;
  lblCurrentThought.Transparency = 100;
  
  //debug variables
  debugTools = ACTIVATEDEBUGTOOL;
  skipAllCutscene = SKIPCUTSCENES;
  
  //Beard code
  cHarkersBeard.Transparency = 100;
  cHarkersBeard.ChangeRoom(cHarker.Room, cHarker.x, cHarker.y, eDirectionDown);
  cHarkersBeard.FollowCharacter(cHarker, FOLLOW_EXACTLY);
  
  availableDestinations = Set.Create(eSorted);
  roomForEachTravelDestinations = Dictionary.Create(eSorted);
  x_TravelDestinations = Dictionary.Create(eSorted);
  y_TravelDestinations = Dictionary.Create(eSorted);
  city_TravelDestinations = Dictionary.Create(eSorted);
  exeterTravelDistanceMultiplier = 8;
  londonTravelDistanceMultiplier = 16;
  arrival_x = new int[NUMBEROFROOMS+1];
  arrival_y = new int[NUMBEROFROOMS+1];
  faceDirection = new CharacterDirection[NUMBEROFROOMS+1];
  
  int roomIndex;
  
  roomIndex = 1; //Jonathan's apartment 
  arrival_x[roomIndex] = 185;
  arrival_y[roomIndex] = 147;
  faceDirection[roomIndex] = eDirectionDown;
  
  roomIndex = 2; //Hawkins Office
  arrival_x[roomIndex] = 159;
  arrival_y[roomIndex] = 182;
  faceDirection[roomIndex] = eDirectionUp;
  
  roomIndex = 3;
  arrival_x[roomIndex] = 0;
  arrival_y[roomIndex] = 0;
  faceDirection[roomIndex] = eDirectionDown;
  
  roomIndex = 4;
  arrival_x[roomIndex] = 0;
  arrival_y[roomIndex] = 0;
  faceDirection[roomIndex] = eDirectionDown;
  
  roomIndex = 5;
  arrival_x[roomIndex] = 0;
  arrival_y[roomIndex] = 0;
  faceDirection[roomIndex] = eDirectionDown;
  
  roomIndex = 6;
  arrival_x[roomIndex] = 0;
  arrival_y[roomIndex] = 0;
  faceDirection[roomIndex] = eDirectionDown;
  
  roomIndex = 7;
  arrival_x[roomIndex] = 0;
  arrival_y[roomIndex] = 0;
  faceDirection[roomIndex] = eDirectionDown;
  
  roomIndex = 8;
  arrival_x[roomIndex] = 0;
  arrival_y[roomIndex] = 0;
  faceDirection[roomIndex] = eDirectionDown;
  
  roomIndex = 9;
  arrival_x[roomIndex] = 0;
  arrival_y[roomIndex] = 0;
  faceDirection[roomIndex] = eDirectionDown;
  
  roomIndex = 10;
  arrival_x[roomIndex] = 0;
  arrival_y[roomIndex] = 0;
  faceDirection[roomIndex] = eDirectionDown;
  
  roomIndex = 11;
  arrival_x[roomIndex] = 0;
  arrival_y[roomIndex] = 0;
  faceDirection[roomIndex] = eDirectionDown;
  
  hawkinsLedgerCity = Dictionary.Create(eSorted);
  hawkinsLedgerSector = Dictionary.Create(eSorted);
  hawkinsLedgerPropertyAge = Dictionary.Create(eSorted);
  hawkinsRequestCity = Dictionary.Create(eSorted);
  hawkinsRequestSector = Dictionary.Create(eSorted);
  hawkinsRequestPropertyAgeMin = Dictionary.Create(eSorted);
  hawkinsRequestPropertyAgeMax = Dictionary.Create(eSorted);
  hawkinsRequestMessage = Dictionary.Create(eSorted);
  hawkinsRequesters = Set.Create(eSorted);
    
  notes = Dictionary.Create(eNonSorted);
  afterNotebookThoughts = Set.Create(eNonSorted);
  notes.Set("How to use", "When something notable is thought or said, you will see an asterisk (*) at the end of the sentence. Write the 'Note' command to add it to your notebook.");
  notes.Set("Mina - tea", "Meet Mina at Station café for tea at 11AM.");
  
  legalPapers = Dictionary.Create(eNonSorted);
  legalPapers_solution = Set.Create(eNonSorted);
  legalPapers_solution.Add("Title page");
  legalPapers_solution.Add("Articles");
  legalPapers_solution.Add("Signature");
  
  possibleClientNames = Set.Create(eSorted, eCaseInsensitive);
  possibleClientNames.Add("Acland");
  possibleClientNames.Add("Adams");
  possibleClientNames.Add("Adamson");
  possibleClientNames.Add("Aitken");
  possibleClientNames.Add("Alderdice");
  possibleClientNames.Add("Alexander");
  possibleClientNames.Add("Amery");
  possibleClientNames.Add("Armstrong");
  possibleClientNames.Add("Asghar");
  possibleClientNames.Add("Asquith");
  possibleClientNames.Add("Astor");
  possibleClientNames.Add("Atkins");
  possibleClientNames.Add("Attlee");
  possibleClientNames.Add("Bagshaw");
  possibleClientNames.Add("Baker");
  possibleClientNames.Add("Baldwin");
  possibleClientNames.Add("Ball");
  possibleClientNames.Add("Bankes");
  possibleClientNames.Add("Baring");
  possibleClientNames.Add("Basse");
  possibleClientNames.Add("Bathurst");
  possibleClientNames.Add("Beaumont");
  possibleClientNames.Add("Beggse");
  possibleClientNames.Add("Beith");
  possibleClientNames.Add("Benn");
  possibleClientNames.Add("Benyon");
  possibleClientNames.Add("Beresford");
  possibleClientNames.Add("Bergers");
  possibleClientNames.Add("Bernal");
  possibleClientNames.Add("Bevan");
  possibleClientNames.Add("Billingham");
  possibleClientNames.Add("Bilson");
  possibleClientNames.Add("Blackburne");
  possibleClientNames.Add("Blake");
  possibleClientNames.Add("Blennerhassett");
  possibleClientNames.Add("Blomfield");
  possibleClientNames.Add("Bole");
  possibleClientNames.Add("Borwick");
  possibleClientNames.Add("Boswell");
  possibleClientNames.Add("Bottomley");
  possibleClientNames.Add("Bowater");
  possibleClientNames.Add("Bradshaw");
  possibleClientNames.Add("BrightsCash");
  possibleClientNames.Add("Bromley");
  possibleClientNames.Add("Brookes");
  possibleClientNames.Add("Brown");
  possibleClientNames.Add("Brunner");
  possibleClientNames.Add("Bull");
  possibleClientNames.Add("Burgon");
  possibleClientNames.Add("Butler");
  possibleClientNames.Add("Byers");
  possibleClientNames.Add("Calcraft");
  possibleClientNames.Add("Callaghan");
  possibleClientNames.Add("Calvert");
  possibleClientNames.Add("Carters");
  possibleClientNames.Add("Cavendish");
  possibleClientNames.Add("Cawley");
  possibleClientNames.Add("Cecil");
  possibleClientNames.Add("Chamberlain");
  possibleClientNames.Add("Chaplin");
  possibleClientNames.Add("Chapman");
  possibleClientNames.Add("Chichester");
  possibleClientNames.Add("Churchill");
  possibleClientNames.Add("Clifton");
  possibleClientNames.Add("Cooper");
  possibleClientNames.Add("Cope");
  possibleClientNames.Add("Courts");
  possibleClientNames.Add("Cox");
  possibleClientNames.Add("Cromwell");
  possibleClientNames.Add("Cryer");
  possibleClientNames.Add("Dashwood");
  possibleClientNames.Add("Davidson");
  possibleClientNames.Add("Davies");
  possibleClientNames.Add("Davis");
  possibleClientNames.Add("Dawson");
  possibleClientNames.Add("Dickinson");
  possibleClientNames.Add("Dodds");
  possibleClientNames.Add("Doran");
  possibleClientNames.Add("Drake");
  possibleClientNames.Add("Dunnes");
  possibleClientNames.Add("Dunwoody");
  possibleClientNames.Add("Durkan");
  possibleClientNames.Add("Eccles");
  possibleClientNames.Add("Edward");
  possibleClientNames.Add("Egerton");
  possibleClientNames.Add("Ewing");
  possibleClientNames.Add("Ferguson");
  possibleClientNames.Add("Fielden");
  possibleClientNames.Add("Finnie");
  possibleClientNames.Add("Foley");
  possibleClientNames.Add("Ford");
  possibleClientNames.Add("Foster");
  possibleClientNames.Add("Galbraith");
  possibleClientNames.Add("Garnier");
  possibleClientNames.Add("Gibson");
  possibleClientNames.Add("Gilmorehill");
  possibleClientNames.Add("Gladstone");
  possibleClientNames.Add("Golding");
  possibleClientNames.Add("Goldsmith");
  possibleClientNames.Add("Goschen");
  possibleClientNames.Add("Grady");
  possibleClientNames.Add("Grant");
  possibleClientNames.Add("Grattan");
  possibleClientNames.Add("Greene");
  possibleClientNames.Add("Greenwood");
  possibleClientNames.Add("Grenville");
  possibleClientNames.Add("Grey");
  possibleClientNames.Add("Grieves");
  possibleClientNames.Add("Guest");
  possibleClientNames.Add("Guinness");
  possibleClientNames.Add("Harcourt");
  possibleClientNames.Add("Hardies");
  possibleClientNames.Add("Harding");
  possibleClientNames.Add("Healy");
  possibleClientNames.Add("Heathcote");
  possibleClientNames.Add("Henderson");
  possibleClientNames.Add("Hodges");
  possibleClientNames.Add("Hodgson");
  possibleClientNames.Add("Hoggs");
  possibleClientNames.Add("Holmes");
  possibleClientNames.Add("Hooson");
  possibleClientNames.Add("Hope");
  possibleClientNames.Add("Hopkinson");
  possibleClientNames.Add("Howarth");
  possibleClientNames.Add("Howes");
  possibleClientNames.Add("Hoyle");
  possibleClientNames.Add("Hubbard");
  possibleClientNames.Add("Hurd");
  possibleClientNames.Add("Hussey");
  possibleClientNames.Add("Jackson");
  possibleClientNames.Add("Janner");
  possibleClientNames.Add("Jay");
  possibleClientNames.Add("Jeger");
  possibleClientNames.Add("Jenkins");
  possibleClientNames.Add("Johnson");
  possibleClientNames.Add("Jones");
  possibleClientNames.Add("Keen");
  possibleClientNames.Add("Kennedy");
  possibleClientNames.Add("Kinnock");
  possibleClientNames.Add("Knollys");
  possibleClientNames.Add("Lamb");
  possibleClientNames.Add("Lancaster");
  possibleClientNames.Add("Laws");
  possibleClientNames.Add("Lechmere");
  possibleClientNames.Add("Lee");
  possibleClientNames.Add("Lefroy");
  possibleClientNames.Add("Lemon");
  possibleClientNames.Add("Lever");
  possibleClientNames.Add("Lewis");
  possibleClientNames.Add("Lindsay");
  possibleClientNames.Add("Lloyd");
  possibleClientNames.Add("Long");
  possibleClientNames.Add("Lowther");
  possibleClientNames.Add("Luce");
  possibleClientNames.Add("Luttrell");
  possibleClientNames.Add("Lyon");
  possibleClientNames.Add("Maberley");
  possibleClientNames.Add("MacDonald");
  possibleClientNames.Add("MacKay");
  possibleClientNames.Add("Macmillan");
  possibleClientNames.Add("Mahon");
  possibleClientNames.Add("Mallalieus");
  possibleClientNames.Add("Mancroft");
  possibleClientNames.Add("Mandelson");
  possibleClientNames.Add("Martin");
  possibleClientNames.Add("Maude");
  possibleClientNames.Add("Maxton");
  possibleClientNames.Add("McAteer");
  possibleClientNames.Add("McAvan");
  possibleClientNames.Add("McCarthy");
  possibleClientNames.Add("McCrea");
  possibleClientNames.Add("McGuinnesse");
  possibleClientNames.Add("McMahon");
  possibleClientNames.Add("McNair-Wilson");
  possibleClientNames.Add("Meacher");
  possibleClientNames.Add("Miles");
  possibleClientNames.Add("Miliband");
  possibleClientNames.Add("Millar");
  possibleClientNames.Add("Mitchell");
  possibleClientNames.Add("Montague");
  possibleClientNames.Add("Morgan");
  possibleClientNames.Add("Morley");
  possibleClientNames.Add("Morris");
  possibleClientNames.Add("Morrison");
  possibleClientNames.Add("Mosley");
  possibleClientNames.Add("Mundell");
  possibleClientNames.Add("Nairns");
  possibleClientNames.Add("Nandy");
  possibleClientNames.Add("Norman");
  possibleClientNames.Add("Nott");
  possibleClientNames.Add("Nuttall");
  possibleClientNames.Add("O'Connell");
  possibleClientNames.Add("Ormsby");
  possibleClientNames.Add("Overend");
  possibleClientNames.Add("Paget");
  possibleClientNames.Add("Paisley");
  possibleClientNames.Add("Paton");
  possibleClientNames.Add("Pawsey");
  possibleClientNames.Add("Pease");
  possibleClientNames.Add("Peel");
  possibleClientNames.Add("Pelham");
  possibleClientNames.Add("Percival");
  possibleClientNames.Add("Perkin");
  possibleClientNames.Add("Perry");
  possibleClientNames.Add("Philipse");
  possibleClientNames.Add("Pitt");
  possibleClientNames.Add("Plunkett");
  possibleClientNames.Add("Poots");
  possibleClientNames.Add("Prentice");
  possibleClientNames.Add("Price");
  possibleClientNames.Add("Redmond");
  possibleClientNames.Add("Rees");
  possibleClientNames.Add("Ridley");
  possibleClientNames.Add("Robinson");
  possibleClientNames.Add("Roe");
  possibleClientNames.Add("Rothschild");
  possibleClientNames.Add("Ruddock");
  possibleClientNames.Add("Runciman");
  possibleClientNames.Add("Russell");
  possibleClientNames.Add("Sainsbury");
  possibleClientNames.Add("Samuel");
  possibleClientNames.Add("Samuelson");
  possibleClientNames.Add("Sandy");
  possibleClientNames.Add("Seymour");
  possibleClientNames.Add("Sharples");
  possibleClientNames.Add("Shelley");
  possibleClientNames.Add("Shinwell");
  possibleClientNames.Add("Silkin");
  possibleClientNames.Add("Sillars");
  possibleClientNames.Add("Sinclair");
  possibleClientNames.Add("Skinner");
  possibleClientNames.Add("Smith");
  possibleClientNames.Add("Spencer");
  possibleClientNames.Add("Spring");
  possibleClientNames.Add("Stanley");
  possibleClientNames.Add("Sturgeon");
  possibleClientNames.Add("Swinson");
  possibleClientNames.Add("Tennyson");
  possibleClientNames.Add("Todd");
  possibleClientNames.Add("Tyrwhitt");
  possibleClientNames.Add("Villiers");
  possibleClientNames.Add("Vivian");
  possibleClientNames.Add("Wakefield");
  possibleClientNames.Add("Walker");
  possibleClientNames.Add("Ward");
  possibleClientNames.Add("Watkin");
  possibleClientNames.Add("Watts");
  possibleClientNames.Add("Wheatley");
  possibleClientNames.Add("Wiggins");
  possibleClientNames.Add("Wigrams");
  possibleClientNames.Add("Williams");
  possibleClientNames.Add("Winterton");
  possibleClientNames.Add("Wintringham");
  possibleClientNames.Add("Wolfson");
  possibleClientNames.Add("Wood");  
  
  verbDictionary = Dictionary.Create(eNonSorted, eCaseInsensitive);
  verbDictionary.Set("look", "look");
  verbDictionary.Set("use", "use");
  //verbDictionary.Set("eat", "eat");
  //verbDictionary.Set("give", "give");
  verbDictionary.Set("examine", "look");
  verbDictionary.Set("open", "open");
  verbDictionary.Set("close", "close");
  verbDictionary.Set("go to", "approach");
  verbDictionary.Set("approach", "approach");
  verbDictionary.Set("note", "note");
  verbDictionary.Set("talk", "talk");
  verbDictionary.Set("speak", "talk");
  verbDictionary.Set("take", "take");
  verbDictionary.Set("get", "take");
  verbDictionary.Set("pick up", "take");
  verbDictionary.Set("read", "read");
  verbDictionary.Set("sit", "sit");
  verbDictionary.Set("stand", "stand");
  verbDictionary.Set("organize", "organize");
  verbDictionary.Set("classify", "organize");
  
  verbDictionary.Set("debugadditem", "debugadditem");
  
  verbDescriptionDictionary = Dictionary.Create(eSorted, eCaseInsensitive);
  verbDescriptionDictionary.Set("look", "Look at something or someone in the room (or at one of your inventory items.[[EXAMPLE: Look carpet");
  verbDescriptionDictionary.Set("use", "Use an item from your inventory or an object in the room near you. Sometimes, you must specify on what or on whom you use the object.[[EXAMPLE 1: Use sink[[EXAMPLE 2: Use razor on myself");
  //verbDescriptionDictionary.Set("eat", "Consume something.[[EXAMPLE: Eat chicken");
  //verbDescriptionDictionary.Set("give", "Give an intem from your inventory to someone else. You must specify to whom you wish to give the item.[[EXAMPLE: Give ring to Mina");
  verbDescriptionDictionary.Set("open", "Open an object near you or an item from your inventory.[[EXAMPLE: Open front door");
  verbDescriptionDictionary.Set("close", "Close an object near you or an item from your inventory.[[EXAMPLE: Close bedroom door");
  verbDescriptionDictionary.Set("*approach", "Have Jonathan walk over to something or someone.[[Only works if 'Show hints' is chosen from the option panel.[[EXAMPLE: Approach dining table");
  verbDescriptionDictionary.Set("note", "Have Jonathan write down his notable information.[Only works when Jonathan has a notebook[[EXAMPLE: Note");
  verbDescriptionDictionary.Set("talk", "Talk to someone in the room.[Sometimes, you need to be near someone to talk to them.[[EXAMPLE: Talk to Count");
  verbDescriptionDictionary.Set("take", "Pick up an object and place it in your inventory.[[EXAMPLE: Take razor");
  verbDescriptionDictionary.Set("read", "Read an item from your inventory.[Not all items can be read.[[EXAMPLE: Read ledger");
  verbDescriptionDictionary.Set("sit", "Have Jonathan sit down in a nearby chair or appropriate surface.[Jonathan will not sit on any surface.[[EXAMPLE: Sit on bench");
  verbDescriptionDictionary.Set("spot", "Have Jonathan point out objects, people and inventory items that contain a certain word in its name.[[EXAMPLE: Spot door");
  verbDescriptionDictionary.Set("stand", "Have Jonathan stand up.[[EXAMPLE: Stand up");
  verbDescriptionDictionary.Set("organize", "Have Jonathan organize items.[Only classifiable items can be organized.[[EXAMPLE: Organize legal papers");
  
  int i;
  String myVerbs[] = verbDescriptionDictionary.GetKeysAsArray();
  
  for(i = 0; i < verbDescriptionDictionary.ItemCount; i++)
  {
    lbVerbs.AddItem(myVerbs[i]);
  }
  lblHelpVerbDesc.Text = verbDescriptionDictionary.Get(lbVerbs.Items[lbVerbs.TopItem]);
  
}

// Called when a dialog script line "run-script" is processed
function dialog_request(int param)
{
  switch(param)
  {
    default:
      break;
  }
  
}

function show_save_game_dialog()
{
  // get the list of save games
  lstSaveGamesList.FillSaveGameList();

  if (lstSaveGamesList.ItemCount > 0)
  {
    // if there is at least one, set the default text
    // to be the first game's name
    txtNewSaveName.Text = lstSaveGamesList.Items[0];
  }
  else
  {
    // no save games yet, so default to empty text
    txtNewSaveName.Text = "";
  }

  open_gui(gSaveGame);
}

function show_restore_game_dialog()
{
  lstRestoreGamesList.FillSaveGameList();
  open_gui(gRestoreGame);
}

//################## DEBUG DISPLAY FUNCTION ####################################

function debugDisplay(String message) // Display used for debug so we can turn them off safely for the release candidate
{
  if(debugTools){
    Display(message);
  }
}

//################## STRING CUSTOM FUNCTIONS ####################################

String keycodeToString(char typeCharacter) // returns the symbol associated with the code (e.g.: 65 => A)
{
  return String.Format("%c",  typeCharacter);
}

String etToString(elementType eT) // changes the element type enum (roomObject,  AllInventoryItem,  roomHotspot and allCharacters) to a String
{
  switch(eT)
  {
    case roomObjects:
      return "roomObjects";
      break;
    case roomHotspots:
      return "roomHotspots";
      break;
    case allCharacters:
      return "allCharacters";
      break;
    case allInventoryItems:
      return "allInventoryItems";
      break;
    default:
      //debugDisplay(String.Format("Fxn etToString received element type #%d, out of bounds.", eT));
      break;
  }
}

elementType stringToET(String eT) // changes the String to the element type enum spelled out (roomObject,  AllInventoryItem,  roomHotspot and allCharacters)
{
  switch(eT)
  {
    case "roomObjects":
      return roomObjects;
      break;
    case "roomHotspots":
      return roomHotspots;
      break;
    case "allCharacters":
      return allCharacters;
      break;
    case "allInventoryItems":
      return allInventoryItems;
      break;
    default:
      //debugDisplay(String.Format("Fxn stringToET received string %s, unknown.", eT));
      break;
  }
}

bool alphaOrder_isThisBeforeThat(String thisString, String thatString)
{
  Set* alphabetise = Set.Create(eSorted, eCaseInsensitive);
  alphabetise.Add(thisString);
  alphabetise.Add(thatString);
  String alphaArray[] = alphabetise.GetItemsAsArray();
  return (thisString == alphaArray[0]);
}

bool startsWithVowel(String word) // returns true if a String starts with a vowel (useful for distinction between the use of 'a' or 'an' as articles
{
  bool doesStartWithAVowel = false;
  if(word.StartsWith("A", eCaseInsensitive)){
    doesStartWithAVowel = true;
  } else if(word.StartsWith("E", eCaseInsensitive)){
    doesStartWithAVowel = true;
  } else if(word.StartsWith("I", eCaseInsensitive)){
    doesStartWithAVowel = true;
  } else if(word.StartsWith("O", eCaseInsensitive)){
    doesStartWithAVowel = true;
  } else if(word.StartsWith("U", eCaseInsensitive)){
    doesStartWithAVowel = true;
  } else if(word.StartsWith("Y", eCaseInsensitive)){
    doesStartWithAVowel = true;
  }
  return doesStartWithAVowel;
}

String removeOneStringInstance(String fullText, String stringToRemoveOnce) // basically the String.Replace function,  but only for the first occurrence (not all)
{
  int i;
  int finishAt = fullText.IndexOf(stringToRemoveOnce) + stringToRemoveOnce.Length;
  String finalReplacement = "";
  for(i = fullText.IndexOf(stringToRemoveOnce); i < finishAt; i++)
  {
    fullText = fullText.ReplaceCharAt(i, 95);
    finalReplacement = finalReplacement.Append("_");
  }
  fullText = fullText.Replace(finalReplacement, "", eCaseInsensitive);
  return fullText;
}

String[] split(String textToSplit, String separator) // Returns an array of string split by separators !! CAREFUL array[0] is the array's length,  not an item !!
{
  int i;
  String testString = textToSplit.Replace(separator, "", eCaseInsensitive);
  int nbStringItems = textToSplit.Length;
  nbStringItems = nbStringItems - testString.Length;
  
  String returnArray[] = new String[nbStringItems];
  returnArray[0] = String.Format("%d", nbStringItems);
  
  for(i = 1; i < nbStringItems; i++)
  {
    
    if(textToSplit.IndexOf(separator) != -1)
    {
      returnArray[i] = textToSplit.Substring(0, textToSplit.IndexOf(separator));
      textToSplit = removeOneStringInstance(textToSplit, returnArray[i].Append(separator));
    } else
    {
      returnArray[i] = textToSplit;
    }
  }
  
  return returnArray;
}

String cmdStartsWithUSEsynonym(String cmd) // Return on the the 'use synonyms' we chose (if found) or "Null" if not found
{
  Set* USEsynonyms = Set.Create();
  USEsynonyms.Add("use");
  USEsynonyms.Add("put");
  USEsynonyms.Add("insert");
  
  String synonymList[] = USEsynonyms.GetItemsAsArray();
  int i = USEsynonyms.ItemCount -1;
  String foundMatch = "Null";
  
  while(i >= 0 && foundMatch == "Null")
  {
    if(cmd.StartsWith(synonymList[i], eCaseInsensitive))
    {
      foundMatch = synonymList[i];
    } else {
      i--;
    }
  }
  
  return foundMatch;
}

String whichArticle(String listOfElementsMentionned, String newElementName) // retunrs the appropriate article for a list of things to list ('A'/'An', 'A second',  etc.)
{ 
  int counter = 1;
  while(listOfElementsMentionned.IndexOf(newElementName) != -1)
  {
    counter++;
    listOfElementsMentionned = removeOneStringInstance(listOfElementsMentionned, newElementName);
  }
  switch(counter)
  {
    case 0:
      if(startsWithVowel(newElementName))
      {
        return "An";
      } else
      {
        return "A";
      }
      break;
    case 1:
      if(startsWithVowel(newElementName))
      {
        return "An";
      } else
      {
        return "A";
      }
      break;
    case 2:
      return "A second";
      break;
    case 3:
      return "A third";
      break;
    case 4:
      return "A fourth";
      break;
    case 5:
      return "A fifth";
      break;
    default:
      return "Another";
      break;
  }
}


//################# INTERACTION AUTOMATION FUNCTIONS ###############################

//##### UTILITIES #####

int getObjectMidX(Object* Obj) {
  DynamicSprite* tempSprite = DynamicSprite.CreateFromExistingSprite(Obj.Graphic);
  int returnInt = tempSprite.Width / 2;
  tempSprite.Delete();
  
  returnInt = returnInt + Obj.X;
  
  return returnInt;
}

float calculateDistanceFromCharacter(int targetX, int targetY,  Character* who) // Return a float of the distance (in px) between a character and a target
{
  float deltaX = IntToFloat(targetX) - IntToFloat(who.x);
  float deltaY = IntToFloat(targetY) - IntToFloat(who.y);
  return Maths.Sqrt(Maths.RaiseToPower(deltaX, 2.0)+ Maths.RaiseToPower(deltaY, 2.0));  
}

bool isCharacterCloseEnough(int targetX, int targetY, float maxDistance,  Character* who) // Returns a bool describing if a character's distance from a target is lower than the indicated max
{
  float dist = calculateDistanceFromCharacter(targetX, targetY, who);
  return dist < maxDistance;
}

bool isCharacterNearHotspot(Hotspot* HS, float maxDistance,  Character* who) // Is the character close to the passed hotspot
{
  return isCharacterCloseEnough(HS.WalkToX, HS.WalkToY, maxDistance,  who);  
}

bool isCharacterNearObject(Object* Obj, float maxDistance,  Character* who) // Is the character close to the passed object
{
  return isCharacterCloseEnough(getObjectMidX(Obj), Obj.Y, maxDistance,  who);  
}

bool isCharacterNearCharacter(Character* target, float maxDistance,  Character* who)  // Is the character close to the passed character
{
  return isCharacterCloseEnough(target.x, target.y, maxDistance,  who);  
}

bool isThisOpened(Object* Obj)
{
  bool returnBool = false;
  
  switch(Obj.GetProperty("Open_SpriteNumber"))
  {
    case -2:
      returnBool = !Obj.Visible;
      break;
    case -1:
      break;
    default:
      returnBool = (Obj.Visible && Obj.Graphic == Obj.GetProperty("Open_SpriteNumber"));
      break;
  }
  
  return returnBool;
}

String whatIsThis(elementType eT, int index) // return an element's name
{
  switch(eT)
  {
    case roomObjects:
      return object[index].Name;
      break;
    case roomHotspots:
      return hotspot[index].Name;
      break;
    case allCharacters:
      return character[index].Name;
      break;
    case allInventoryItems:
      return inventory[index].Name;
      break;
    default: 
      return "Unknown";
      break;
  }
}

String[] findClosestElement(String elementType_index[], float dist[], int arraysLength) // Returns the closest element from indexed arrays
{
  String closestElementType_index = elementType_index[0];
  float closestDist = dist[0];
  String returnArray[] = new String[2];
  
  int i; 
  for(i = 1; i < arraysLength; i++)
  {
    if(dist[i] < closestDist) 
    {
      closestElementType_index = elementType_index[i];
      closestDist = dist[i];
    }
  }
  
  returnArray[0] = closestElementType_index.Truncate(closestElementType_index.IndexOf("_"));
  closestElementType_index = closestElementType_index.Replace(returnArray[0], "", eCaseInsensitive);
  closestElementType_index = closestElementType_index.Replace("_", "", eCaseInsensitive);
  returnArray[1] = closestElementType_index;
  
  return returnArray;
}

String isInteractionOnElement(String cmd) // returns true if the command has both a 'use synonym' and a 'on' synonym (e.g.: USE razor ON Jonathan // INSERT files IN folder)
{
  Set* OnSynonyms = Set.Create(eSorted);
  OnSynonyms.Add("in");
  OnSynonyms.Add("into");
  OnSynonyms.Add("onto");
  OnSynonyms.Add("on");
  OnSynonyms.Add("over");
  OnSynonyms.Add("with");
  OnSynonyms.Add("under");
  OnSynonyms.Add("to");
  
  String OnSynonymsArray[] = OnSynonyms.GetItemsAsArray();
  int i = OnSynonyms.ItemCount - 1;
  String foundMatch = "Null";
  
  while(i >= 0 && foundMatch == "Null")
  {
    if(cmd.IndexOf(OnSynonymsArray[i]) != -1)
    {
      foundMatch = OnSynonymsArray[i];
    } else {
      i--;
    }
  }
  
  return foundMatch;
}

function memorize(String thought) {
  lblCurrentThought.Text = thought;
  timeUITransparency = 0.0;
}

String getMemorisedThought()
{
  if(lblCurrentThought.Transparency < 100)
  {
    return lblCurrentThought.Text;
  } else {
    return "...I forget";
  }
}


//##### TIME FUNCTIONS #####

String whatTimeIsIt(bool showTimeInStatusLine)
{
  int timeInLoops = currentTime;
  String AmPm = "AM";
  
  int hour = timeInLoops / (loopPerSecond * 3600);
  timeInLoops = timeInLoops - (hour * 3600 * loopPerSecond);
  if(hour >= 12)
  {
    AmPm = "PM";
  }
  if(hour > 12)
  {
    hour = hour - 12;
  }
  
  int minutes = timeInLoops / (loopPerSecond * 60);
  
  if(showTimeInStatusLine)
  {
    memorize(String.Format("%d:%02d%s", hour, minutes, AmPm));
  }
  
  return String.Format("%d:%02d%s", hour, minutes, AmPm);
}

int getCurrentHour()
{
  String currentHourS = whatTimeIsIt(false);
  currentHourS = currentHourS.Truncate(currentHourS.IndexOf(":")-1);
  return currentHourS.AsInt;
}

int getCurrentMinutes()
{
  String currentMinutesS = whatTimeIsIt(false);
  
  if(currentMinutesS.EndsWith("AM")) {
    currentMinutesS = currentMinutesS.Truncate(currentMinutesS.IndexOf("AM")-1);
  } else {
    currentMinutesS = currentMinutesS.Truncate(currentMinutesS.IndexOf("PM")-1);
  }
  currentMinutesS = currentMinutesS.Substring(currentMinutesS.IndexOf(":")+1, 2);
  return currentMinutesS.AsInt;
}

String getAMPM()
{
  String currentAMPM = whatTimeIsIt(false);
  if(currentAMPM.EndsWith("AM")){
    return "AM";
  } else {
    return "PM";
  }
}

bool isItBeforeThisTime(int hour, int minutes, int seconds, bool PM, int day)
{
  if(PM && hour != 12)
  {
    hour = hour + 12;
  }
  int maxLoops = ((((((day * 24) + hour) * 60) + minutes) * 60) + seconds) * loopPerSecond;
  int currentAllTimeLoop = currentTime + ((currentDay * 86400) * loopPerSecond);
  return currentAllTimeLoop <= maxLoops;
}

String addTimeToDescription(String textDescription)
{
  String returnText = String.Format("%s[It is %s", textDescription, whatTimeIsIt(true));
  return returnText;
}

function setCurrentTime(int hour, int minutes, int seconds, bool PM,  int day)
{
  if(PM && (hour != 12))
  {
    hour = hour + 12;
  }
  currentTime = ((hour * 3600) + (minutes * 60) + seconds) * loopPerSecond;
  currentDay = day;
}

function addTime(int hour, int minutes, int seconds, int day)
{
  int loopsToAdd = ((hour * 3600) + (minutes * 60) + seconds) * loopPerSecond;
  currentTime = currentTime + loopsToAdd;
}

function setTimeIncrementPerLoop(int newIncrement)
{
  currentTimeIncrementPerLoop = newIncrement;
}

function resetTimeIncrementPerLoop()
{
  currentTimeIncrementPerLoop = STANDARDTIMEINCREMENT;
}

function openWaitGUI(String passtimeVerb)
{
  if(player.HasInventory(iWatch)){
    lblWaitUI.Text = String.Format("It is %s[Howlong should I wait?", whatTimeIsIt(false));
  } else {
    lblWaitUI.Text = String.Format("Howlong should I wait?");
  }
  passtimeVerb = passtimeVerb.LowerCase();
  lblWaitUI.Text = lblWaitUI.Text.Replace("wait", passtimeVerb);
  btnConfirmWait.Text = btnConfirmWait.Text.Replace("wait", passtimeVerb);
  String firstLetter = passtimeVerb.Truncate(1);
  firstLetter = firstLetter.UpperCase();
  passtimeVerb = firstLetter.Append(passtimeVerb.Substring(2, passtimeVerb.Length-1));
  btnToggleForUntil.Text = btnToggleForUntil.Text.Replace("wait", passtimeVerb);
  tbWaitAmount.Text = "15";
  open_gui(gWait);
}

//##### MAP-ROOM FUNCTIONS #####

function enterMap() // uses the gMapIndication GUI to add the name of all destinations (they must be objects in the 'Room' used for the map and be named)
{
  int i;  
  gMapIndications.Visible = true;
  for(i = 0 ; i < Room.ObjectCount ; i++)
  {
    gMapIndications.Controls[i].AsLabel.Text = object[i].Name;
    gMapIndications.Controls[i].AsLabel.Visible = true;
    gMapIndications.Controls[i].AsLabel.X = object[i].X - gMapIndications.Controls[i].AsLabel.Width;
    gMapIndications.Controls[i].AsLabel.Y = object[i].Y;
    gMapIndications.Controls[i].AsLabel.TextAlignment = eAlignRight;
  }
  setTimeIncrementPerLoop(4);
}

function exitMap() // clears all specifics from the gMapIndications GUI
{
  int i;
  for(i = 0 ; i < gMapIndications.ControlCount ; i++)
  {
    gMapIndications.Controls[i].AsLabel.Text = "";
    gMapIndications.Controls[i].AsLabel.Visible = false;
  }
  gMapIndications.Visible = false;
  resetTimeIncrementPerLoop();
}

//##### AUTOMATED ACTION FUNCTION #####

//##### HAWKINS FILES ##################################################################
//Players need to get the requirements (city,  sector,  age), consult the map (city+sector), get the names, use ledger to get the drawer number,  get file by name, validate the age,  bring it back to Hawkins
String generateClientName ()
{
  String clientName;
  String possibleClientNamesArray[];
  possibleClientNamesArray = possibleClientNames.GetItemsAsArray();
  clientName = possibleClientNamesArray[Random(possibleClientNames.ItemCount - 1)];
  possibleClientNames.Remove(clientName);
  return clientName;
}

function createHawkinsPropertyFile (String clientName, String cityName, String sector, int age)
{
  if(clientName == "Random")
  {
    clientName = generateClientName();
  }
  
  hawkinsLedgerCity.Set(clientName, cityName);
  hawkinsLedgerSector.Set(clientName, sector);
  hawkinsLedgerPropertyAge.Set(clientName, String.Format("%d", age));
}

function createHawkinsRequestFile (String clientName, String cityName, String sector, int ageMin,  int ageMax,  String clientMessage,  bool addToRequesters)
{
  if(clientName == "Random")
  {
    clientName = generateClientName();
  }
  
  if(clientMessage == "Auto")
  {
    clientMessage = String.Format("They want a property in %s's %s sector, aged between %d and %d years old", cityName, sector, ageMin, ageMax);
  }
  
  hawkinsRequestCity.Set(clientName, cityName);
  hawkinsRequestSector.Set(clientName, sector);
  hawkinsRequestPropertyAgeMin.Set(clientName, String.Format("%d", ageMin));
  hawkinsRequestPropertyAgeMax.Set(clientName, String.Format("%d", ageMax));
  hawkinsRequestMessage.Set(clientName, clientMessage);
  
  if(addToRequesters)
  {
    hawkinsRequesters.Add(clientName);
  }
}

String getClientListPerCitySector(String city, String sector)
{
  int i;
  String clientFiles[];
  clientFiles = hawkinsLedgerCity.GetKeysAsArray();
  String returnString = "";
  for(i = 0 ; i < hawkinsLedgerCity.ItemCount ; i++)
  {
    if(hawkinsLedgerCity.Get(clientFiles[i]) == city && hawkinsLedgerSector.Get(clientFiles[i]) == sector)
    {
      if(returnString == "")
      {
        returnString = clientFiles[i];
      } else {
        returnString = returnString.Append(String.Format(" , %s", clientFiles[i]));
      }
    }
  }
  return returnString;
}

String generateReadHawkinsFileString(String clientName)
{
  String propAge = hawkinsLedgerPropertyAge.Get(clientName);
  String returnString = String.Format("Name: %s", clientName);
  returnString = returnString.Append(String.Format("[City: %s", hawkinsLedgerCity.Get(clientName)));
  returnString = returnString.Append(String.Format("[Sector: %s", hawkinsLedgerSector.Get(clientName)));
  returnString = returnString.Append(String.Format("[Construction: %d (%s y.o.)", 1893 - (propAge.AsInt), propAge));
  return returnString;
}

String getPropertyRequestMessage(String clientName)
{
  return hawkinsRequestMessage.Get(clientName);
}

Set* getHawkinsSellerList()
{
  Set* sellerList;
  sellerList = Set.Create(eSorted);
  String clientNames[];
  clientNames = hawkinsLedgerCity.GetKeysAsArray();
  int i;
  for(i = 0 ; i < hawkinsLedgerCity.ItemCount ; i++)
  {
    sellerList.Add(clientNames[i]);
  }
  return sellerList;
}

String getPropertyRequesterName()
{
  String returnName;
  String clientNames[];
  clientNames = hawkinsRequesters.GetItemsAsArray();
  returnName = clientNames[Random(hawkinsRequesters.ItemCount - 1)];
  hawkinsRequesters.Remove(returnName);
  return returnName;
}

String capitalizeName(String theName)
{
  String firstLetter = theName.Truncate(1);
  firstLetter = firstLetter.UpperCase();
  theName = String.Format("%s%s", firstLetter, theName.Substring(1, theName.Length-1));
  return theName;
}

String getProposedSeller()
{
  return proposedSeller;
}

bool validatePropertyProposition(String requesterName, String sellerName)
{
  bool validated = true;
  if(hawkinsLedgerCity.Contains(sellerName))
  {
    String propAge = hawkinsLedgerPropertyAge.Get(sellerName);
    String ageMin = hawkinsRequestPropertyAgeMax.Get(requesterName);
    String ageMax = hawkinsRequestPropertyAgeMin.Get(requesterName);
    if( hawkinsLedgerCity.Get(sellerName) != hawkinsRequestCity.Get(requesterName) ||
        hawkinsLedgerSector.Get(sellerName) != hawkinsRequestSector.Get(requesterName) ||
        propAge.AsInt <= ageMax.AsInt ||
        propAge.AsInt >= ageMin.AsInt)
    {
      validated = false;
    }
    sellerName = capitalizeName(sellerName);
    cHawkins.Say(String.Format("Oh yes, the %s's property!", sellerName));
  } else
  {
    sellerName = capitalizeName(sellerName);
    cHawkins.Say(String.Format("%s? I do not know this name. You made a mistake", sellerName));
    validated = false;
  }
  return validated;
}

function createMultipleHawkinsPropertyFile (String city, String sector, int ageMin, int ageMax,  int nbFiles)
{
  int propAge;
  while(nbFiles > 0)
  {
    propAge = ageMin + Random((ageMax - ageMin - 1));
    createHawkinsPropertyFile("Random", city, sector, propAge);
    nbFiles--;
  }
}

function createAllHawkinsFiles ()
{
  createHawkinsRequestFile("Random", "Exeter", "City center", 25, 75, "Auto", true);
  createHawkinsPropertyFile("Random", "Exeter", "City center", 37);
  createMultipleHawkinsPropertyFile("Exeter", "City center", 100, 500, PROPERTIESPERSECTOR - 1);
  
  createHawkinsRequestFile("Random", "Exeter", "North", 100, 200, "Auto", true);
  createHawkinsPropertyFile("Random", "Exeter", "North", 183);
  createMultipleHawkinsPropertyFile("Exeter", "North", 250, 600, PROPERTIESPERSECTOR - 1);
  
  createHawkinsRequestFile("Random", "Exeter", "West", 5, 25, "Auto", true);
  createHawkinsPropertyFile("Random", "Exeter", "West", 17);
  createMultipleHawkinsPropertyFile("Exeter", "West", 30, 200, PROPERTIESPERSECTOR - 1);
  
  createHawkinsRequestFile("Random", "Exeter", "South", 500, 850, "Auto", true);
  createHawkinsPropertyFile("Random", "Exeter", "South", 678);
  createMultipleHawkinsPropertyFile("Exeter", "South", 30, 400, PROPERTIESPERSECTOR - 1);
  
  createHawkinsRequestFile("Random", "Exeter", "East", 10, 40, "Auto", true);
  createHawkinsPropertyFile("Random", "Exeter", "East", 11);
  createMultipleHawkinsPropertyFile("Exeter", "East", 60, 400, PROPERTIESPERSECTOR - 1);
  
  createHawkinsRequestFile("Random", "London", "City center", 200, 300, "Auto", true);
  createHawkinsPropertyFile("Random", "London", "City center", 258);
  createMultipleHawkinsPropertyFile("London", "City center", 310, 750, PROPERTIESPERSECTOR - 1);
  
  createHawkinsRequestFile("Random", "London", "North", 100, 1000, "Auto", true);
  createHawkinsPropertyFile("Random", "London", "North", 852);
  createMultipleHawkinsPropertyFile("London", "North", 10, 80, PROPERTIESPERSECTOR - 1);
  
  createHawkinsRequestFile("Random", "London", "West", 20, 50, "Auto", true);
  createHawkinsPropertyFile("Random", "London", "West", 34);
  createMultipleHawkinsPropertyFile("London", "West", 90, 400, PROPERTIESPERSECTOR - 1);
  
  createHawkinsRequestFile("Random", "London", "South", 500, 850, "Auto", true);
  createHawkinsPropertyFile("Random", "London", "South", 678);
  createMultipleHawkinsPropertyFile("London", "South", 30, 400, PROPERTIESPERSECTOR - 1);
  
  createHawkinsRequestFile("Dracula", "London", "East", 500, 750, "This is a special one, recommanded by Robert Parton himself[Very old East London property, let's say over 500 years old", false);
  createHawkinsPropertyFile("Random", "London", "East", 698);
  createMultipleHawkinsPropertyFile("London", "East", 30, 400, PROPERTIESPERSECTOR - 1);  
}

//##### TRAVEL DESTINATIONS ######################################################################################
String zoneAsString(zone thisZone) 
{
  switch(thisZone)
  {
    case JonathanApt:
      return "Jonathan's Apartment";
      break;
    case HawkinsOffices:
      return "Hawkins Esq. Office";
      break;
    case ExeterTrainStation:
      return "Exeter Train Station";
      break;
    case StationCafe:
      return "Station Café";
      break;
    case LondonTrainStation:
      return "London Train Station";
      break;
    case Purfleet:
      return "Purfleet";
      break;
    case TelegramOffice:
      return "Telegram Office";
      break;
    case BritishMuseum:
      return "British Museum";
      break;
    case PhotographyShop:
      return "Photography shop";
      break;
    case LawSocietyOffices:
      return "Law Society Offices";
      break;
    case StayHere:
      return "Stay here";
      break;
    default:
      return "Null";
      break;
  }
}

zone stringAsZone(String thisZone) 
{
  switch(thisZone)
  {
    case "Jonathan's Apartment":
      return JonathanApt;
      break;
    case "Hawkins Esq. Office":
      return HawkinsOffices;
      break;
    case "Exeter Train Station":
      return ExeterTrainStation;
      break;
    case "Station Café":
      return StationCafe;
      break;
    case "London Train Station":
      return LondonTrainStation;
      break;
    case "Purfleet":
      return Purfleet;
      break;
    case "Telegram Office":
      return TelegramOffice;
      break;
    case "British Museum":
      return BritishMuseum;
      break;
    case "Photography shop":
      return PhotographyShop;
      break;
    case "Law Society Offices":
      return LawSocietyOffices;
      break;
    case "Stay here":
      return StayHere;
      break;
    default:
      return StayHere;
      break;
  }
}

function setupTravelDestinations()
{
  String thisZone;
  
  thisZone = zoneAsString(JonathanApt);
  roomForEachTravelDestinations.Set(thisZone, "1");
  x_TravelDestinations.Set(thisZone, "6");
  y_TravelDestinations.Set(thisZone, "2");
  city_TravelDestinations.Set(thisZone, "Exeter");
  
  thisZone = zoneAsString(HawkinsOffices);
  roomForEachTravelDestinations.Set(thisZone, "2");
  x_TravelDestinations.Set(thisZone, "3");
  y_TravelDestinations.Set(thisZone, "4");
  city_TravelDestinations.Set(thisZone, "Exeter");
  
  thisZone = zoneAsString(ExeterTrainStation);
  roomForEachTravelDestinations.Set(thisZone, "3");
  x_TravelDestinations.Set(thisZone, "3");
  y_TravelDestinations.Set(thisZone, "1");
  city_TravelDestinations.Set(thisZone, "Exeter");
  
  thisZone = zoneAsString(StationCafe);
  roomForEachTravelDestinations.Set(thisZone, "3");
  x_TravelDestinations.Set(thisZone, "3");
  y_TravelDestinations.Set(thisZone, "1");
  city_TravelDestinations.Set(thisZone, "Exeter");
  
  thisZone = zoneAsString(LondonTrainStation);
  roomForEachTravelDestinations.Set(thisZone, "5");
  x_TravelDestinations.Set(thisZone, "6");
  y_TravelDestinations.Set(thisZone, "4");
  city_TravelDestinations.Set(thisZone, "London");
  
  thisZone = zoneAsString(LondonHotel);
  roomForEachTravelDestinations.Set(thisZone, "5");
  x_TravelDestinations.Set(thisZone, "6");
  y_TravelDestinations.Set(thisZone, "4");
  city_TravelDestinations.Set(thisZone, "London");
  
  thisZone = zoneAsString(Purfleet);
  roomForEachTravelDestinations.Set(thisZone, "6");
  x_TravelDestinations.Set(thisZone, "11");
  y_TravelDestinations.Set(thisZone, "4");
  city_TravelDestinations.Set(thisZone, "London");
  
  thisZone = zoneAsString(TelegramOffice);
  roomForEachTravelDestinations.Set(thisZone, "8");
  x_TravelDestinations.Set(thisZone, "5");
  y_TravelDestinations.Set(thisZone, "3");
  city_TravelDestinations.Set(thisZone, "London");
  
  thisZone = zoneAsString(BritishMuseum);
  roomForEachTravelDestinations.Set(thisZone, "8");
  x_TravelDestinations.Set(thisZone, "5");
  y_TravelDestinations.Set(thisZone, "3");
  city_TravelDestinations.Set(thisZone, "London");
  
  thisZone = zoneAsString(PhotographyShop);
  roomForEachTravelDestinations.Set(thisZone, "10");
  x_TravelDestinations.Set(thisZone, "6");
  y_TravelDestinations.Set(thisZone, "3");
  city_TravelDestinations.Set(thisZone, "London");
  
  thisZone = zoneAsString(LawSocietyOffices);
  roomForEachTravelDestinations.Set(thisZone, "10");
  x_TravelDestinations.Set(thisZone, "6");
  y_TravelDestinations.Set(thisZone, "3");
  city_TravelDestinations.Set(thisZone, "London");
}

int travelDestinationTimeInMinutes(zone origin, zone destination)
{
  String tempString;
  if(destination == StayHere)
  {
    destination = origin;
  }
  
  tempString = x_TravelDestinations.Get(zoneAsString(origin));
  int x_origin = tempString.AsInt;
  
  tempString = y_TravelDestinations.Get(zoneAsString(origin));
  int y_origin = tempString.AsInt;
  
  tempString = x_TravelDestinations.Get(zoneAsString(destination));
  int x_dest = tempString.AsInt;
  
  tempString = y_TravelDestinations.Get(zoneAsString(destination));
  int y_dest = tempString.AsInt;
  
  float x_dist = IntToFloat(x_origin - x_dest);  
  float y_dist = IntToFloat(y_origin - y_dest);
  
  float dist = Maths.Sqrt(Maths.RaiseToPower(x_dist, 2.0) + Maths.RaiseToPower(y_dist, 2.0));
  
  bool inLondon;
  if(city_TravelDestinations.Get(zoneAsString(destination)) == "London")
  {
    inLondon = true;
  } else
  {
    inLondon = false;
  }
  
  if(inLondon)
  {
    return londonTravelDistanceMultiplier * FloatToInt(dist);
  } else
  {
    return exeterTravelDistanceMultiplier * FloatToInt(dist);
  }
}

function adjustTravelDestinations()
{
  String allDestination[];
  String currentCity = city_TravelDestinations.Get(zoneAsString(currentZone));
  allDestination = city_TravelDestinations.GetKeysAsArray();
  int i;
  
  for(i = 0 ; i < city_TravelDestinations.ItemCount ; i++)
  {
    if( city_TravelDestinations.Get(allDestination[i]) == currentCity &&
        availableDestinations.Contains(allDestination[i]) &&
        roomForEachTravelDestinations.Get(allDestination[i]) != String.Format("%d", player.Room))
    {
      dTravel.SetOptionState(stringAsZone(allDestination[i]), eOptionOn);
    } else
    {
      dTravel.SetOptionState(stringAsZone(allDestination[i]), eOptionOff);
    }
  }
  dTravel.SetOptionState(StayHere, eOptionOn);
}

function addTravelDestination(zone thisZone)
{
  if(!availableDestinations.Contains(zoneAsString(thisZone)))
  {
    availableDestinations.Add(zoneAsString(thisZone));
  }
}

function removeTravelDestination(zone thisZone)
{
  if(availableDestinations.Contains(zoneAsString(thisZone)))
  {
    availableDestinations.Remove(zoneAsString(thisZone));
  }
}

function setCurrentZone(zone thisZone)
{
  currentZone = thisZone;
}

function travel(zone destination)
{
  if(destination != StayHere)
  {
    int minutesOfTravel = travelDestinationTimeInMinutes(currentZone, destination);
    CharacterDirection arrivalDirection;
    String roomDestination = roomForEachTravelDestinations.Get(zoneAsString(destination));
    int futureRoom = roomDestination.AsInt;
    addTime(0, minutesOfTravel, 0, 0);
    player.ChangeRoom(futureRoom, arrival_x[futureRoom], arrival_y[futureRoom], faceDirection[futureRoom]);
    setCurrentZone(destination);
  } else {
    player.Walk(arrival_x[player.Room], arrival_y[player.Room], eBlock, eAnywhere);
    player.FaceDirection(faceDirection[player.Room]);
  }
}

//##### NOTEBOOK ###################################################################################################################
String getNoteDescription(String key) // returns the description associated with the title for taken notes
{
  return notes.Get(key);
}

function takeNote() // adds a note in the notepad
{
  notes.Set(Notable_title, Notable_description);
  lbNoteTitles.AddItem(Notable_title);
  if (Game.DoOnceOnly(Notable_description)) {
    GiveScore(Notable_score);
  }
}

function makeNotable(String title, String description, int score) // overrides the last notable thing
{
  Notable_title = title;
  Notable_description = description;
  Notable_score = score;
}

function notableRead(String title, String description,  int score) // Displays something and make it notable (establish the added score if noted too)
{
  if(player.HasInventory(iNotebook))
  {
    makeNotable(title,  description,  score);
    Display(String.Format("%s*", description));
  } else {
    Display(description);
  }
}

function notableThought(String title, String description,  int score) // both make the player think something and make it notable (establish the added score if noted too)
{
  if(player.HasInventory(iNotebook))
  {
    makeNotable(title,  description,  score);
    player.Think(String.Format("%s*", description));
  } else {
    player.Think(description);
  }
}

function notableSay(Character* who, String title, String description,  int score) // both make a character say something and make it notable (establish the added score if noted too)
{
  if(player.HasInventory(iNotebook))
  {
    makeNotable(title,  description,  score);
    who.Say(String.Format("%s*", description));
  } else {
    who.Say(description);
  }
}

function closeNotebookThoughts()
{
  String thoughts[];
  int i;
  if(afterNotebookThoughts.ItemCount > 0)
  {
    thoughts = afterNotebookThoughts.GetItemsAsArray();
    for(i = 0 ; i < afterNotebookThoughts.ItemCount ; i++)
    {
      player.Think(thoughts[i]);
    }
    afterNotebookThoughts.Clear();
  }
}

function hasRead(String noteTitle)
{
  switch(noteTitle)
  {
    case "Mina - tea":
      if(Game.DoOnceOnly("GetCamera")){
        GiveScore(1);
        if(isItBeforeThisTime(11, 0, 0, false, 1)){
          afterNotebookThoughts.Add("Mina and I have a tea rendezvous at 11 at the Station Café");
        } else
        {
          afterNotebookThoughts.Add("Oh no! I missed my tea rendezvous with Mina!");
        }
        addTravelDestination(StationCafe);
      }
      break;
    default:
      break;
  }
}



//##### INTERACTION FUNCTIONS #####

function sit(elementType eT, int index, Character* who, int sittingView, bool alreadySat) // make the character sit on an appropriately setup element
{
  String redir;
  
  switch(eT)
  {
    case roomObjects:
      if(who == player) {
        redir = object[index].GetTextProperty("sit_Direction");
        if(redir.StartsWith("redir", eCaseInsensitive))
        {
          redir = redir.Replace("redir", "", eCaseInsensitive);
          index = redir.AsInt;
        }
      }
      if(object[index].GetTextProperty("sit_Direction") == "Null")
      {
        who.Think("I cannot sit on this.");        
      } else if(!isCharacterNearObject(object[index], reachDistance, who))
      {
        who.Think(String.Format("I cannot reach the %s from here", object[index].Name.LowerCase()));
      } else
      {
        who.Walk(object[index].X + object[index].GetProperty("sit_deltaX"), object[index].Y + object[index].GetProperty("sit_deltaY"), eBlock, eWalkableAreas);
        who.Move(object[index].X + object[index].GetProperty("sit_deltaX"), object[index].Y + object[index].GetProperty("sit_deltaY"), eBlock, eAnywhere);
        who.LockView(sittingView, eStopMoving);
        if(who == player) {
          cHarkersBeard.LockView(6, eKeepMoving);
        }
        who.SetProperty("sitting", index);
        
        if(!alreadySat)
        {
          switch(object[index].GetTextProperty("sit_Direction"))
          {
            case "down":
              who.Animate(0, 6, eOnce, eNoBlock, eForwards);
              break;
            case "left":
              who.Animate(1, 6, eOnce, eNoBlock, eForwards);
              break;
            case "right":
              who.Animate(2, 6, eOnce, eNoBlock, eForwards);
              break;
            case "down":
              who.Animate(3, 6, eOnce, eNoBlock, eForwards);
              break;
            default:
              break;
          }
          if(who == player)
          {
            switch(object[index].GetTextProperty("sit_Direction"))
            {
              case "down":
                cHarkersBeard.Animate(0, 6, eOnce, eBlock, eForwards);
                break;
              case "left":
                cHarkersBeard.Animate(1, 6, eOnce, eBlock, eForwards);
                break;
              case "right":
                cHarkersBeard.Animate(2, 6, eOnce, eBlock, eForwards);
                break;
              case "down":
                cHarkersBeard.Animate(3, 6, eOnce, eBlock, eForwards);
                break;
              default:
                break;
            }
          }
        } else {
          who.Frame = nbFrameInSittingAnim;
        }
        if(who == player)
        {
          mouse.Mode = eModePointer;
          KeyboardMovement.Mode = eKeyboardMovementModeNone;
        }
      }
      break;
    default:
      break;
  }
}

function standUp(Character* who,  int walkingView) // the player stands up
{
  if(who.GetProperty("sitting") > -1)
  {
    who.Animate(player.Loop, 6, eOnce, eNoBlock,  eBackwards);
    if(who == player)
    {
      cHarkersBeard.Animate(player.Loop, 6, eOnce, eBlock, eBackwards);
    }
    who.LockView(walkingView, eKeepMoving);
    if(who == player)
    {
      cHarkersBeard.LockView(5, eKeepMoving);
    }
    who.PlaceOnWalkableArea();
    who.SetProperty("sitting", -1);
    if(who == player)
    {
      mouse.Mode = eModeWalkto;
      KeyboardMovement.Mode = eKeyboardMovementModeTapping;
    }
  } else {
    who.Think("I am not sitting");
  }
}

//##### PARSE COMMAND REACTIONS FUNCTIONS #####
bool sitHighjack()
{
  bool returnBool = false;
  if(useIndex != -1)
  {
      
    switch (useET)
    {
      case roomObjects:
        if(object[useIndex].GetTextProperty("sit_Direction") != "Null")
        {
          returnBool = true;
          sit(roomObjects, useIndex, player, 2, false);
          useIndex = -1;
        }
        break;
      case roomHotspots:
        if(hotspot[useIndex].GetTextProperty("sit_Direction") != "Null")
        {
          returnBool = true;
          sit(roomHotspots, useIndex, player, 2, false);
          useIndex = -1;
        }
        break;
      default:
        break;
    }
  }
  return returnBool;
}

function unhandled_event(int what, int type) // called when a runInteraction is called on something without an appropriate event handler
{
  switch(what)
  {
    case 2: // room object
      switch(type)
      {
        case 1: // use/interact with object
          if(!sitHighjack())
          {
            player.Think("I am not sure what to use this for");
          }
          break;
        case 3: // use inventory item on object
          break;
        default:
          break;
      }
      break;
    case 1: // hotspot
      switch(type)
      {
        case 2: // use/interact with hotspot
          if(!sitHighjack())
          {
            player.Think("I am not sure what to use this for");
          }
          break;
        case 3: // use inventory item on hotspot
          break;
        default:
          break;
      }
      break;
    case 3: // character
      switch(type)
      {
        case 1: // use/interact character
          player.Think("I am not sure what to use them for");
          break;
        case 3: // use inventory item on character
          break;
        default:
          break;
      }
      break;
    case 5: // inventory item
      switch(type)
      {
        case 1: // use/interact with inventory item
          player.Think("I am not sure what to use this for");
          break;
        case 3: // use inventory item on inventory item
          break;
        default:
          break;
      }
      break;
    case 4: // nothing
      switch(type)
      {
        case 2: // use/interact with nothing
          player.Think("I am not sure what to use");
          break;
        case 3: // use inventory item on nothing
          break;
        default:
          break;
      }
      break;
    default:
      break;
  }
}

int findRoomObjectIndexByName(String objectName) // returns the object index of an object named
{
  int i = Room.ObjectCount - 1;
  int foundMatch = -1;
  
  while(i >= 0 && foundMatch == -1)
  {
    if(object[i].Name.LowerCase() == objectName.LowerCase())
    {
      foundMatch = i;
    } else {
      i--;
    }
  }
  
  return foundMatch;
}

int findInvItemIndexByName(String itemName)
{
  int nbInventoryItems = Game.InventoryItemCount;//don't forget the index start at one
  int i = 0;
  int returnIndex = -1;
  bool foundit = false;
  while(i < nbInventoryItems && !foundit)
  {
    i++;
    if(inventory[i].Name == itemName) {
      returnIndex = i;
      foundit = true;
    }
  }
  return returnIndex;
}

String[] findElementIndexByName(String cmd) // returns a String array with array[0] being the index and array[1] being the element type,  both as Strings!!!
{
  int i;
  int y;
  String testedStrings[];
  String allPossibleNames;
  String finalIndex;
  String finalElementType;
  bool foundMatch;
  float distanceFromPlayer;
  String tempArray[];
  float tempArrayF[];
  String returnArray[] = new String[2];
  
  int nbObjects = Room.ObjectCount;
  int nbHotpots = 50;
  int nbCharacters = Game.CharacterCount;
  int nbInventoryItems = Game.InventoryItemCount;//don't forget the index start at one
  Dictionary* correspondingRoomElements = Dictionary.Create(eSorted, eCaseInsensitive);
  
  //OBJECTS
  for(i = 0; i < (nbObjects); i++)
  {
    allPossibleNames = object[i].Name.Append(", ");
    if(object[i].GetTextProperty("alternateNames") != "")
    {
      allPossibleNames = allPossibleNames.Append(object[i].GetTextProperty("alternateNames"));
      allPossibleNames = allPossibleNames.Append(", ");
    }
    //debugDisplay(allPossibleNames);
    testedStrings = split(allPossibleNames, ", ");
    int testedStringsLength = testedStrings[0].AsInt;
    y = 1;
    foundMatch = false;
    while(y < testedStringsLength && !foundMatch)
    {
      if(object[i].Name != "" && testedStrings[y] != "" && cmd.IndexOf(testedStrings[y]) != -1)
      {
        if(object[i].Visible || object[i].GetProperty("InteractableWhenInvisible"))
        {
          foundMatch = true;
          distanceFromPlayer = calculateDistanceFromCharacter(getObjectMidX(object[i]), object[i].Y, player);
          correspondingRoomElements.Set(String.Format("%d_%s", i, etToString(roomObjects)), String.Format("%d", FloatToInt(distanceFromPlayer)));
        } else {
          y++;
        }
      } else {
        y++;
      }
    }
  }
  
  //HOTSPOTS
  for(i = 0; i < (nbHotpots); i++)
  {
    allPossibleNames = hotspot[i].Name.Append(", ");
    allPossibleNames = allPossibleNames.Append(hotspot[i].GetTextProperty("alternateNames"));
    testedStrings = split(allPossibleNames, ", ");
    int testedStringsLength = testedStrings[0].AsInt;
    y = 1;
    foundMatch = false;
    while(y < testedStringsLength && !foundMatch)
    {
      if(hotspot[i].Name != "" && cmd.IndexOf(testedStrings[y]) != -1)
      {
        foundMatch = true;
        distanceFromPlayer = calculateDistanceFromCharacter(hotspot[i].WalkToX, hotspot[i].WalkToY, player);
        correspondingRoomElements.Set(String.Format("%d_%s", i, etToString(roomHotspots)), String.Format("%d", FloatToInt(distanceFromPlayer)));
      } else {
        y++;
      }
    }
  }
  
  //CHARACTERS
  for(i = 0; i < (nbCharacters); i++)
  {
    allPossibleNames = character[i].Name.Append(", ");
    allPossibleNames = allPossibleNames.Append(character[i].GetTextProperty("alternateNames"));
    testedStrings = split(allPossibleNames, ", ");
    int testedStringsLength = testedStrings[0].AsInt;
    y = 1;
    foundMatch = false;
    while(y < testedStringsLength && !foundMatch)
    {
      if(character[i].Room == player.Room && character[i].Name != "" && cmd.IndexOf(testedStrings[y]) != -1)
      {
        foundMatch = true;
        distanceFromPlayer = calculateDistanceFromCharacter(character[i].x, character[i].y,  player);
        correspondingRoomElements.Set(String.Format("%d_%s", i, etToString(allCharacters)), String.Format("%d", FloatToInt(distanceFromPlayer)));
      } else {
        y++;
      }
    }
  }
  
  //INVENTORY ITEMS
  for(i = 1; i <= (nbInventoryItems); i++)//inventory item index start at 1
  {
    allPossibleNames = inventory[i].Name.Append(", ");
    allPossibleNames = allPossibleNames.Append(inventory[i].GetTextProperty("alternateNames"));
    testedStrings = split(allPossibleNames, ", ");
    int testedStringsLength = testedStrings[0].AsInt;
    y = 1;
    foundMatch = false;
    
    while(y < testedStringsLength && !foundMatch)
    {
      if(player.HasInventory(inventory[i]) && inventory[i].Name != "" && cmd.IndexOf(testedStrings[y]) != -1)
      {
        foundMatch = true;
        if(cmd.IndexOf(" my ") != -1)
        {
          distanceFromPlayer = 0.0;
        } else {
          distanceFromPlayer = 400.0;
        }
        correspondingRoomElements.Set(String.Format("%d_%s", i, etToString(allInventoryItems)), String.Format("%d", FloatToInt(distanceFromPlayer)));
      } else {
        y++;
      }
    }
  }
    
  switch(correspondingRoomElements.ItemCount)
  {
    case 0:
      returnArray[0] = "-1";
      returnArray[1] = "Null";
      break;
    case 1:
      tempArray = correspondingRoomElements.GetKeysAsArray();
      finalIndex = tempArray[0].Truncate(tempArray[0].IndexOf("_"));
      finalElementType = tempArray[0].Replace(finalIndex, "", eCaseInsensitive);
      finalElementType = finalElementType.Replace("_", "", eCaseInsensitive);
      returnArray[0] = finalIndex;
      returnArray[1] = finalElementType;
      break;
    default:
      tempArray = correspondingRoomElements.GetValuesAsArray();
      tempArrayF = new float[correspondingRoomElements.ItemCount];
      for(i = 0; i < correspondingRoomElements.ItemCount; i++)
      {
        tempArrayF[i] = tempArray[i].AsFloat;
      }
      tempArray = correspondingRoomElements.GetKeysAsArray();
      returnArray = findClosestElement(tempArray, tempArrayF, correspondingRoomElements.ItemCount);
      break;
  }  
  
  return returnArray;
}

String findVerbInDictionary(String cmd) // finds the verb in the verbDictionary
{
  int i = verbDictionary.ItemCount -1;
  bool foundVerb = false;
  int stringPosition = -1;
  String verbs[] = verbDictionary.GetKeysAsArray();
   
  while(!foundVerb && i > -1){
    stringPosition = cmd.IndexOf(verbs[i]);
    if(stringPosition == -1) {
      i--;
    } else {
      foundVerb = true;
    }
  }
  
  if(i == -1) 
  {
    return "Null";
  } else {
    return verbDictionary.Get(verbs[i]);
  }
}

// this function allows 2 inventory items to be merged together (keeps one,  modifies its parameters and removes the other)
function fitInventoryItemsTogether(InventoryItem* keptItem, InventoryItem* fittedItem, String newKeptItemName, int newItemGraphic, bool ReplaceDesc_orAppend, String newItemDescription, int AddedScore)
{
  String oldDescription = keptItem.GetTextProperty("TextDescription");
  String oldName = keptItem.Name;
  
  keptItem.Name = newKeptItemName;
  if(ReplaceDesc_orAppend)
  {
    keptItem.SetTextProperty("TextDescription", newItemDescription);
  } else {
    keptItem.SetTextProperty("TextDescription", oldDescription.Append(String.Format(" %s", newItemDescription)));
  }
  keptItem.Graphic = newItemGraphic;
  player.LoseInventory(fittedItem);
  if(AddedScore > 0){
    if (Game.DoOnceOnly(String.Format("Fit %s in %s", fittedItem.Name, oldName))) {
      GiveScore(AddedScore);
    }
  }
}

//##### CLASSIFIABLE DOCUMENTS #####
function addClassifiableFile(String fileTitle, String fileDescription,  String fileFamily)
{
  int invItemAsFamily = findInvItemIndexByName(fileFamily);
  
  if(invItemAsFamily == -1)
  {
    debugDisplay("Trying to add a classifiable file to an unknown item");
  } else 
  {
    
    if(inventory[invItemAsFamily].GetTextProperty("InvContext") != "Classify")
    {
      debugDisplay(String.Format("Trying to add a file to %s, which does not have the Classify invContext property", inventory[invItemAsFamily].Name));
    } else 
    {
      if(inventory[invItemAsFamily].Name == "Legal papers")
      {
        legalPapers.Set(fileTitle, fileDescription);
        if(!player.HasInventory(inventory[invItemAsFamily]))
        {
          player.AddInventory(inventory[invItemAsFamily]);
        }
      }
    }
  }
}

function lbInventory_Selector_adapt(String itemName){
  int i = Game.InventoryItemCount;
  String allContexts = "Classify, Look inside";
  bool foundMatch = false;
  
  while(i > 0 && !foundMatch) 
  {
    if(inventory[i].Name == itemName)
    {
      //imgSelectedInv.NormalGraphic = inventory[i].Graphic;
      if(inventory[i].GetProperty("tellsTime"))
      {
        lblDescriptionSelectedItem.Text = String.Format("%s[It is %s, currently.", inventory[i].GetTextProperty("TextDescription"), whatTimeIsIt(true));
      } else {
        lblDescriptionSelectedItem.Text = String.Format("%s", inventory[i].GetTextProperty("TextDescription"));
      }
      
      if(inventory[i].GetTextProperty("invContext") == "Null")
      {
        btnInvContext.Visible = false;
      } else if (allContexts.IndexOf(inventory[i].GetTextProperty("invContext")) != -1)
      {
        btnInvContext.Text = String.Format("> %s", inventory[i].GetTextProperty("invContext"));
        btnInvContext.Visible = true;
      }
      foundMatch = true;
    } else {
      i--;
    }
  }
}

function fillInventoryListBox ()
{
  int i;
  bool firstItem = false;
  String itemDescription;
  lbInventory.Clear();
  
  for(i = Game.InventoryItemCount ; i > 0 ; i--) 
  {
    if(player.HasInventory(inventory[i]))
    {
      lbInventory.AddItem(inventory[i].Name);
      if(firstItem == false) {
        lbInventory_Selector_adapt(inventory[i].Name);
        firstItem = true;
      }
    }
  }
}

int findListBoxIndexbyName(ListBox* thisLB, String itemLookedFor)
{
  int selectedIndex = 0;
  int i = 0;
  bool foundit = false;
  while (i < thisLB.ItemCount && !foundit)
  {
    if(thisLB.Items[i] == itemLookedFor)
    {
      selectedIndex = i;
      foundit = true;
    }
    i++;
  }
  return selectedIndex;
}



function show_inventory_window()
{
  fillInventoryListBox();
  open_gui(gInventory);
}

function ValidateFileIt (ListBox* classifiedProposition, Set* classifiedSolution, InventoryItem* thisItem, int classifiedSpriteNumber,  String classifiedItemName, int addScoreAmount)
{
  bool allGood = true;
  int i = 0;
  String orderedSolution[];
  orderedSolution = classifiedSolution.GetItemsAsArray();
  
  close_gui(gClassify);
  if(classifiedSolution.ItemCount != classifiedProposition.ItemCount)
  {
    player.Think("Hmm... That's not right");
    player.Think("Something is missing");
  } else
  {
    while(i < classifiedSolution.ItemCount && allGood)
    {
      if(orderedSolution[i] != classifiedProposition.Items[i]) {
        allGood = false;
      }
      i++;
    }
    
    if(allGood)
    {
      player.Say("Hurray! Perfectly organized");
      thisItem.Graphic = classifiedSpriteNumber;
      if (Game.DoOnceOnly(thisItem.Name)) {
          GiveScore(addScoreAmount);
      }
      thisItem.Name = classifiedItemName;
      thisItem.SetTextProperty("invContext", "Null");
      fillInventoryListBox();
      lbInventory.SelectedIndex = findListBoxIndexbyName(lbInventory, thisItem.Name);
      lblDescriptionSelectedItem.Text = inventory[findInvItemIndexByName(lbInventory.Items[lbInventory.SelectedIndex])].GetTextProperty("TextDescription");
    } else {
      player.Think("Hmm... That's not right");
    }
  }
  open_gui(gInventory);  
}

Set* breakWrittenContentByPage(String fullMessage, String pageBreakSymbol)
{
    Set* returnSet = Set.Create(eSorted);
    String currentPage;
    int currentPageNumber = 1;
    
    while(fullMessage.IndexOf(pageBreakSymbol) != -1)
    {
      currentPage = fullMessage.Truncate(fullMessage.IndexOf(pageBreakSymbol));
      currentPage = currentPage.Replace(pageBreakSymbol, "", eCaseInsensitive);
      fullMessage = removeOneStringInstance(fullMessage, currentPage.Append(pageBreakSymbol));
      currentPage = String.Format("PAGE %d[%s", currentPageNumber, currentPage);
      returnSet.Add(currentPage);
      
      currentPageNumber++;
    }
    fullMessage = String.Format("PAGE %d[%s", currentPageNumber, fullMessage);
    returnSet.Add(fullMessage);
    
    return returnSet;
}

function readThis(String fullMessage, String pageSeparator)
{
  Set* readContent = breakWrittenContentByPage(fullMessage, pageSeparator);
  String readContentToDisplay[] = readContent.GetItemsAsArray();
  int i;
  for(i = 0 ; i < readContent.ItemCount ; i++)
  {
    Display(readContentToDisplay[i]);
  }
}

function fillLbclassifiable(Dictionary* Dict)
{
  int i;
  String dictKeys[] = Dict.GetKeysAsArray();
  lbClassifiable.Clear();
  for(i = 0 ; i < Dict.ItemCount ; i++) {
    lbClassifiable.AddItem(dictKeys[i]);
  }
  lbClassifiable.SelectedIndex = 0;
  lblClassifyDescription.Text = Dict.Get(lbClassifiable.Items[lbClassifiable.SelectedIndex]);
}

function openClassifyGUI(String fileFamily,  Dictionary* dict)
{
  lblClassifyTitle.Text = String.Format("Classify %s", fileFamily.LowerCase());
  fillLbclassifiable(dict);
  open_gui(gClassify);
}

bool interact(String indexElementVerbHandled[]) // reacts appropriately based on the index,  element and verb passed (reactions detailed in this function's switch)
{
  int index = indexElementVerbHandled[0].AsInt;
  elementType eT = stringToET(indexElementVerbHandled[1]);
  String verb = indexElementVerbHandled[2];
  String lookDescription;
  int alternateSpriteNumber;
  int walkableAreaNumber;
  bool handledInteraction = true;
  
  Set* readContent;
  String readContentToDisplay[];
  int i;
  
  switch (verb)
  {
    case "look":
      switch (eT)
      {
        case roomObjects:
          if(object[index].Visible || object[index].GetProperty("InteractableWhenInvisible"))
          {
            lookDescription = object[index].GetTextProperty("TextDescription");
            if(object[index].GetProperty("tellsTime"))
            {
              lookDescription = addTimeToDescription(lookDescription);
            }
            player.FaceObject(object[index], eBlock);
            player.Say(lookDescription);
          } else {
            player.Say("I'm not sure what I'm looking at...");
          }
          break;
        case roomHotspots:
          lookDescription = hotspot[index].GetTextProperty("TextDescription");
          if(hotspot[index].GetProperty("tellsTime"))
            {
              lookDescription = addTimeToDescription(lookDescription);
            }
          player.FaceLocation(hotspot[index].WalkToX, hotspot[index].WalkToY, eBlock);
          player.Say(lookDescription);
          break;
        case allCharacters:
          if(character[index].Transparency < 100){
            lookDescription = character[index].GetTextProperty("TextDescription");
            player.FaceCharacter(character[index], eBlock);
            player.Say(lookDescription);
          } else {
            player.Say("I'm not sure what I'm looking at...");
          }
          break;
        case allInventoryItems:
          lookDescription = inventory[index].GetTextProperty("TextDescription");
          player.FaceDirection(eDirectionDown, eBlock);
          if(inventory[index].GetProperty("tellsTime"))
            {
              lookDescription = addTimeToDescription(lookDescription);
            }
          player.Say(lookDescription);
          break;
        default:
          player.Say("I'm not sure what I'm looking at...");
          break;
      }
      break;
    case "open":
      switch(eT)
      {
        case roomObjects:
          alternateSpriteNumber = object[index].GetProperty("Open_SpriteNumber");
          walkableAreaNumber = object[index].GetProperty("WalkableArea_opened");
          if(alternateSpriteNumber == -1)
          {
            player.Think("I cannot open this");
          } else if(isCharacterNearObject(object[index], reachDistance,  player))
          {
            if(alternateSpriteNumber == -2) {
              if(!object[index].Visible)
              {
                player.Think("It is already opened");
              } else {
                object[index].Visible = false;
              }
            } else if(object[index].Graphic == alternateSpriteNumber)
            {
              if(object[index].Visible)
              {
                player.Think("It is already opened");
              } else {
                object[index].Visible = true;
              }
            } else {
              object[index].Graphic = alternateSpriteNumber;
            }
            if(walkableAreaNumber != -1)
            {
              RestoreWalkableArea(walkableAreaNumber);
            }
          } else {
            player.Think("I can't reach from here");
          }
          break;
        case allInventoryItems:
          alternateSpriteNumber = inventory[index].GetProperty("Open_SpriteNumber");
          if(alternateSpriteNumber == -1)
          {
            player.Think("I cannot open this");
          } else if(inventory[index].Graphic == alternateSpriteNumber) 
          {
            player.Think("It is already opened");
          } else {
            inventory[index].Graphic = alternateSpriteNumber;
          }
          break;
        default:
          player.Think("I cannot open this");
          break;
      }
      break;
    case "close":
      switch(eT)
      {
        case roomObjects:
          alternateSpriteNumber = object[index].GetProperty("Close_SpriteNumber");
          walkableAreaNumber = object[index].GetProperty("WalkableArea_opened");
          if(alternateSpriteNumber == -1)
          {
            player.Think("I cannot close this");
          } else if(isCharacterNearObject(object[index], reachDistance,  player))
          {
            if(alternateSpriteNumber == -2) 
            {
              if(!object[index].Visible)
              {
                player.Think("It is already closed");
              } else {
                object[index].Visible = false;
              }
            } else if(object[index].Graphic == alternateSpriteNumber)
            {
              if(object[index].Visible)
              {
                player.Think("It is already closed");
              } else {
                object[index].Visible = false;
              }
            } else {
              object[index].Graphic = alternateSpriteNumber;
            }
            if(walkableAreaNumber != -1)
            {
              RemoveWalkableArea(walkableAreaNumber);
            } 
          } else {
            player.Think("I can't reach from here");
          }
          break;
        case allInventoryItems:
          alternateSpriteNumber = inventory[index].GetProperty("Close_SpriteNumber");
          if(alternateSpriteNumber == -1)
          {
            player.Think("I cannot close this");
          } else if(inventory[index].Graphic == alternateSpriteNumber) 
          {
            player.Think("It is already closed");
          } else {
            inventory[index].Graphic = alternateSpriteNumber;
          }
          break;
        default:
          player.Think("I cannot close this");
          break;
      }
      break;
    case "approach":
      if(!showHints){
        player.Think("I can walk there on my own");
      } else {
        switch(eT)
        {
          case roomObjects:
            player.Walk(object[index].X, object[index].Y, eNoBlock, eWalkableAreas);
            break;
          case roomHotspots:
            player.Walk(hotspot[index].WalkToX, hotspot[index].WalkToY, eNoBlock, eWalkableAreas);
            break;
          case allCharacters:
            player.Walk(character[index].x, character[index].y, eNoBlock, eWalkableAreas);
            break;
          default:
            player.Think("I am not not where to go");
            break;
        }
      }
      break;
    case "sit":
      sit(eT, index, player, 2,  false);
      break;
    case "take":
      if(eT == roomObjects)
      {
        if(object[index].GetProperty("takable") != -1)
        {
          if(isCharacterNearObject(object[index], reachDistance, player))
          {
            player.Think("This can be useful");
            player.AddInventory(inventory[object[index].GetProperty("takable")]);
            object[index].Visible = false;
            GiveScore(1);
          } else {
            player.Think("I need to go a little closer");
          }
        } else {
          player.Think("I would rather leave this where it is");
        }
      }
      break;
    case "talk":
      switch (eT)
      {
        case allCharacters:
          if(character[index].Room != player.Room)
          {
            player.Think("I am not sure whom to speak to");
          } else
          {
            if (character[index].GetProperty("dialogIndex") == -1)
            {
              player.FaceCharacter(character[index], eBlock);
              player.Think("I do not know what I should say.");
            } else 
            {
              if (character[index].GetProperty("dialogMaxDistance") > -1 && !isCharacterNearCharacter(character[index], IntToFloat(character[index].GetProperty("dialogMaxDistance")), player))
              {
                player.FaceCharacter(character[index], eBlock);
                player.Think(String.Format("%s will not hear me from this distance", character[index].Name));
              } else 
              {
                if (character[index].GetProperty("dialogWhileSitting") != -1 && (player.GetProperty("sitting") != character[index].GetProperty("dialogWhileSitting")))
                {
                player.FaceCharacter(character[index], eBlock);
                  player.Think(String.Format("Politeness dictates that I should sit in the %s before speaking to %s", object[character[index].GetProperty("dialogWhileSitting")].Name.LowerCase(), character[index].Name));
                } else
                {
                  dialog[character[index].GetProperty("dialogIndex")].Start();
                }
              }
            }
          }
          break;
        default:
          player.Think("I am not sure whom to speak to");
          break;
      }
      break;
    case "read":
      if(eT == allInventoryItems && inventory[index].GetTextProperty("ReadDisplay") != "Null")
      {
        readThis(inventory[index].GetTextProperty("ReadDisplay"), "¶");
      } else {
        player.Think("I cannot read this");
      }
      break;
    case "organize":
      if(eT != allInventoryItems || inventory[index].GetTextProperty("invContext") != "Classify")
      {
        player.Think("I cannot classify this");
      } else{
        switch(inventory[index].Name)
        {
          case "Legal papers":
            openClassifyGUI("Legal papers", legalPapers);
            break;
          default:
            debugDisplay(String.Format("%s is not a defined fileFamily", inventory[index].Name));
            break;
        }
      }
      break;
    default:
      handledInteraction = false;
      break;
  }
  return handledInteraction;
}

function findElementContaining(String keyword) // makes a list of found things reacting to the 'find' keyword
{
  int i;
  bool intro = false;
  bool invIntro = false;
  String nameAndAKA;
  String article = "";
  String allElementsMentionned = "";
  
  //OBJECTS IN THE ROOM
  for(i = 0; i < Room.ObjectCount; i++) {
    nameAndAKA = object[i].Name;
    if(object[i].GetTextProperty("alternateNames") != "")
    {
      nameAndAKA = nameAndAKA.Append(", ");
      nameAndAKA = nameAndAKA.Append(object[i].GetTextProperty("alternateNames"));
    }
    if(nameAndAKA.IndexOf(keyword) != -1) {
      if(!intro)
      {
        player.Say("Looking around, I can spot...");
        intro = true;
      }
      player.FaceObject(object[i], eBlock);
      article = whichArticle(allElementsMentionned, object[i].Name);
      player.Say(String.Format("%s %s over there.", article,  object[i].Name));
      allElementsMentionned = allElementsMentionned.Append(String.Format("%s ", object[i].Name));
    }
  }
  //HOTSPOTS IN THE ROOM
  for(i = 0; i < 50; i++) {
    nameAndAKA = hotspot[i].Name;
    if(hotspot[i].GetTextProperty("alternateNames") != "")
    {
      nameAndAKA = nameAndAKA.Append(", ");
      nameAndAKA = nameAndAKA.Append(hotspot[i].GetTextProperty("alternateNames"));
    }
    if(nameAndAKA.IndexOf(keyword) != -1) {
      if(!intro)
      {
        player.Say("Looking around, I can spot...");
        intro = true;
      }
      player.FaceLocation(hotspot[i].WalkToX, hotspot[i].WalkToY, eBlock);
      article = whichArticle(allElementsMentionned, hotspot[i].Name);
      player.Say(String.Format("%s %s over there.", article,  hotspot[i].Name));
      allElementsMentionned = allElementsMentionned.Append(String.Format("%s ", hotspot[i].Name));
    }
  }
  //CHARACTERS IN THE ROOM
  for(i = 0; i < Game.CharacterCount; i++) {
    nameAndAKA = character[i].Name;
    if(character[i].GetTextProperty("alternateNames") != "")
    {
      nameAndAKA = nameAndAKA.Append(", ");
      nameAndAKA = nameAndAKA.Append(character[i].GetTextProperty("alternateNames"));
    }
    if(nameAndAKA.IndexOf(keyword) != -1 && player.Room == character[i].Room) {
      if(!intro)
      {
        player.Say("Looking around, I can spot...");
        intro = true;
      }
      player.FaceCharacter(character[i]);
      player.Say(String.Format("%s over there.", character[i].Name));
    }
  }
  //OWNED INVENTORY ITEMS
  for(i = 1; i <= Game.InventoryItemCount; i++) {
    nameAndAKA = inventory[i].Name;
    if(inventory[i].GetTextProperty("alternateNames") != "")
    {
      nameAndAKA = nameAndAKA.Append(", ");
      nameAndAKA = nameAndAKA.Append(inventory[i].GetTextProperty("alternateNames"));
    }
    if(nameAndAKA.IndexOf(keyword) != -1 && player.HasInventory(inventory[i])) {
      if(!invIntro)
      {
        if(intro)
        {
          player.Say("Also...");
        }
        player.Say("In my inventory, I can spot...");
        invIntro = true;
        intro = true;
      }
      player.FaceDirection(eDirectionDown);
      article = whichArticle(allElementsMentionned, inventory[i].Name);
      player.Say(String.Format("%s %s.", article, inventory[i].Name));
      allElementsMentionned = allElementsMentionned.Append(String.Format("%s ", inventory[i].Name));
    }
  }
}

function useInteraction(String cmd) // either 'interact' or 'UseInv' version of runInteraction is used
{
  String OnSynonym = isInteractionOnElement(cmd);
  String useSynonym = cmdStartsWithUSEsynonym(cmd);
  
  String cmdUsed;
  String cmdOn;
  
  String indexElementUsed[] = new String[2];
  elementType eTUsed;
  int indexUsed;
  bool canUse = true;
  
  String indexElementOn[] = new String[2];
  elementType eTOn;
  int indexOn;
  
  elementType eTTemp;
  int indexTemp;
  
  if(OnSynonym == "Null") // there is only one verb (use) and a target
  {
      cmd = removeOneStringInstance(cmd, useSynonym.Append(" "));
      indexElementUsed = findElementIndexByName(cmd);
      
      if(indexElementUsed[1] == "Null")
      {
        player.Think("I am not sure what to use");
      } else {
        eTUsed = stringToET(indexElementUsed[1]);
        indexUsed = indexElementUsed[0].AsInt;
        // to handled generic unhandled exception later
        useET = eTUsed;
        useIndex = indexUsed;
        switch(eTUsed)
        {
          case roomObjects:
            if(isCharacterNearObject(object[indexUsed], reachDistance, player))
            {
              object[indexUsed].RunInteraction(eModeInteract);
            } else {
              player.Think(String.Format("I need to get closer to the %s to use it", object[indexUsed].Name.LowerCase()));
            }
            break;
          case roomHotspots:
            if(isCharacterNearHotspot(hotspot[indexUsed], reachDistance, player))
            {
              hotspot[indexUsed].RunInteraction(eModeInteract);
            } else {
              player.Think(String.Format("I need to get closer to the %s to use it", hotspot[indexUsed].Name.LowerCase()));
            }
            break;
          case allInventoryItems:
            if(player.HasInventory(inventory[indexUsed]))
            {
              inventory[indexUsed].RunInteraction(eModeInteract);
            } else {
              player.Think("I am not sure what you want me to use");
            }
            break;
          default:
            player.Think("I am not sure what you want me to use");
            break;
        }
      } 
  } else // The player wants to use something on/with something
  {
    cmd = removeOneStringInstance(cmd, useSynonym.Append(" "));
    cmdUsed = cmd.Truncate(cmd.IndexOf(OnSynonym));
    cmd = removeOneStringInstance(cmd, cmdUsed);
    cmdOn = removeOneStringInstance(cmd, OnSynonym);
    
    indexElementUsed = findElementIndexByName(cmdUsed);
    indexElementOn = findElementIndexByName(cmdOn);
    
    if(indexElementOn[1] == "Null" || indexElementUsed[1] == "Null")
    {
      player.Think("I am not sure what you want me to do");
    } else {
      eTUsed = stringToET(indexElementUsed[1]);
      indexUsed = indexElementUsed[0].AsInt;
      eTOn = stringToET(indexElementOn[1]);
      indexOn = indexElementOn[0].AsInt;
      
      if(eTOn == allInventoryItems && eTUsed != allInventoryItems) // if the 2nd is an item but not the first,  invert them
      {
        indexTemp = indexOn;
        eTTemp = eTOn;
        indexOn = indexUsed;
        eTOn = eTUsed;
        indexUsed = indexTemp;
        eTUsed = eTTemp;
      }
      if(eTUsed == allCharacters && eTOn != allCharacters) // if the 1st is a character but not the second,  invert them
      {
        indexTemp = indexOn;
        eTTemp = eTOn;
        indexOn = indexUsed;
        eTOn = eTUsed;
        indexUsed = indexTemp;
        eTUsed = eTTemp;
      }
      
      if(eTUsed == allInventoryItems)
      {
        if(!player.HasInventory(inventory[indexUsed]))
        {
          canUse = false;
        }
      } else if (eTUsed == allCharacters)
      {
        if(character[indexUsed].Room != player.Room)
        {
          canUse = false;
        }
      }
          
          
      if(canUse)
      {
        activeElementToUse_ElementType = etToString(eTUsed);
        activeElementToUse_Index = indexUsed;

        switch(eTOn)
        {
          case roomObjects:
            if(isCharacterNearObject(object[indexOn], reachDistance, player))
            {
              object[indexOn].RunInteraction(eModeUseinv);
            } else {
              player.Think(String.Format("I need to get closer to the %s to use my %s on it", object[indexOn].Name.LowerCase(), inventory[indexUsed].Name.LowerCase()));
            }              
            break;
          case roomHotspots:
            if(isCharacterNearHotspot(hotspot[indexOn], reachDistance, player))
            {
              hotspot[indexOn].RunInteraction(eModeUseinv);
            } else {
              player.Think(String.Format("I need to get closer to the %s to use my %s on it", hotspot[indexOn].Name.LowerCase(), inventory[indexUsed].Name.LowerCase()));
            }
            break;
          case allCharacters:
            if(character[indexOn].Room == player.Room && isCharacterNearCharacter(character[indexOn], reachDistance, player))
            {
              character[indexOn].RunInteraction(eModeUseinv);
            } else {
              player.Think(String.Format("I need to get closer to %s to use my %s on them", hotspot[indexOn].Name.LowerCase(), inventory[indexUsed].Name.LowerCase()));
            }
            break;
          case allInventoryItems:
            if(player.HasInventory(inventory[indexOn]))
            {
              inventory[indexOn].RunInteraction(eModeUseinv);
            } else {
              player.Think("I am not sure what you want me to use");
            }
            break;
          default:
            break;
        }
      } else {
        player.Think("I am not sure what you want me to use");
      }
    }
  }
}

bool globalHighjackIndexElementVerb(String stringIndex, String stringElement, String verb)
{
  bool skipRoomInteraction = false;
  int index = stringIndex.AsInt;
  elementType eT = stringToET(stringElement);
  
  if(eT == allInventoryItems && index == 2 && verb == "read")
  {
    readThis(iLedger.GetTextProperty("ReadDisplay"), "¶");
    skipRoomInteraction = true;
  }
  
  return skipRoomInteraction;
}

String[] roomSpecificParse(String cmd) // function that is called by the room to handle the parsing of the command
{
  String elementName;
  String indexElement[] = new String[2];
  String indexElementVerbHandled[] = new String[4];
  int i;
  indexElementVerbHandled[0] = "Null";
  indexElementVerbHandled[1] = "Null";
  indexElementVerbHandled[2] = "Skip";
  indexElementVerbHandled[3] = "true";
  
  if(cmd.IndexOf("spot ") != -1) {                                                                                         // SPOT KEYWORD
    cmd = cmd.Replace("spot ", "", eCaseInsensitive);
    cmd = cmd.Replace("all ", "", eCaseInsensitive);
    cmd = cmd.Replace("any ", "", eCaseInsensitive);
    findElementContaining(cmd);
  } else if(cmd.LowerCase() == "stand" || cmd.IndexOf("stand ") != -1) {                                                    // STAND KEYWORD
    standUp(player, 1);
  } else if(cmdStartsWithUSEsynonym(cmd) != "Null") {                                                                       // USE KEYWORDS
    useInteraction(cmd);
  } else if(cmd.StartsWith("wait", eCaseInsensitive)) {                                                                     // WAIT KEYWORDS
    openWaitGUI("wait");    
  } else if(cmd.StartsWith("shave", eCaseInsensitive)) {                                                                    // SHAVE KEYWORD
    if(player.HasInventory(iRazor))
    {
      useInteraction("use razor on myself");
    } else {
      player.Think("I need to find my razor to shave");
    }
  } else if (cmd.StartsWith("Note ", eCaseInsensitive) || cmd.LowerCase() == "note" || cmd.LowerCase() == "take note") {    // NOTE KEYWORD
    takeNote();
  } else if (cmd.IndexOf("look ") != -1 && cmd.IndexOf(" room") != -1)
  {
    player.Think(Room.GetTextProperty("TextDescription"));
  } else if (cmd.IndexOf("What time is it") != -1)
  {
    if(player.HasInventory(iWatch))
    {
      player.Think(String.Format("It is %s", whatTimeIsIt(true)));
    } else {
      player.Think("I do not have my watch... I do not know what time it is...");
    }
  } else if (cmd.StartsWith("debugadditem") && debugTools) {
    for(i = 0 ; i < Game.InventoryItemCount ; i++)
    {
      if(cmd.IndexOf(inventory[i].Name) != -1 && !player.HasInventory(inventory[i]))
      {
        player.AddInventory(inventory[i]);
      } 
    } 
    if(cmd.IndexOf("HawkinsKit") != -1) {
      player.AddInventory(iLegalPapers);
      player.AddInventory(iNotebook);
      player.ChangeRoom(2);
    }
  } else
  {
    indexElement = findElementIndexByName(cmd);
    
    indexElementVerbHandled[0] = indexElement[0];
    indexElementVerbHandled[1] = indexElement[1];
    if(indexElement[1] != "Null") {
      indexElementVerbHandled[2] = findVerbInDictionary(cmd);
    } else {
      indexElementVerbHandled[2] = "Null";
    }
  }
  
  if(globalHighjackIndexElementVerb(indexElementVerbHandled[0], indexElementVerbHandled[1], indexElementVerbHandled[2]))
  {
    indexElementVerbHandled[2] = "Skip";
  }
  
  return indexElementVerbHandled;
}

//##### GAME INTERACTIONS ###########


// called on every game cycle, except when the game is blocked
function repeatedly_execute()
{
  currentTime = currentTime + currentTimeIncrementPerLoop;
  if(currentTime > (loopPerSecond*86400)) {
    currentTime = currentTime - (loopPerSecond*86400);
  }
  if(timeUITransparency < 100.0)
  {
    timeUITransparency = timeUITransparency + timeUIFadeSpeed;
    lblCurrentThought.Transparency = FloatToInt(timeUITransparency, eRoundDown);
    if(lblNoteDescriptionHighlight.Transparency < 100)
    {
      lblNoteDescriptionHighlight.Transparency = lblNoteDescriptionHighlight.Transparency + 1;
    }
  }
}

// called on every game cycle, even when the game is blocked
function repeatedly_execute_always()
{
  if(cHarkersBeard.Transparency < 100 && cHarker.GetProperty("sitting") == -1) // in REAlways,  becase we want it to continue even when a 'eBlock' animation is running
  {
    cHarkersBeard.FaceDirection(cHarker.Loop);
  }
}

// called when a key is pressed
function on_key_press(eKeyCode keycode, int mod)
{
  // check for Escape first, so it can be used on GUIs that pause the game
  if (keycode == eKeyEscape)
  {
    if (gRestart.Visible)
    {
      // Escape will cancel a restart
      close_gui(gRestart);
    }
    else if (gPanel.Visible)
    {
      // Escape will turn the panel off
      close_gui(gPanel);
    }
    else if (gSaveGame.Visible)
    {
      // Escape will close the save game dialog
      close_gui(gSaveGame);
    }
    else if (gRestoreGame.Visible)
    {
      // Escape will close the restore game dialog
      close_gui(gRestoreGame);
    }
    else if (gInventory.Visible)
    {
      // Escape will close the restore game dialog
      close_gui(gInventory);
    }
    else if (gExitGame.Visible)
    {
      // Escape will cancel exiting the game
      close_gui(gExitGame);
    }
    else if (gParser.Visible) {
      // Escape will cancel the text parser
      close_gui(gParser);
    }
    else if (gWait.Visible) {
      // Escape will close the GUI
      close_gui(gWait);
    }
    else if (gClassify.Visible) {
      // Escape will close the GUI
      close_gui(gClassify);
      show_inventory_window();
    }
    else if (gNotebook.Visible) {
      // Escape will close the GUI
      close_gui(gNotebook);
      closeNotebookThoughts();
    }
    else
    {
      // Escape will turn the panel on
      open_gui(gPanel);
    }
  }
  else if (keycode == eKeyF4)
  {
    if(lblCurrentThought.Transparency < 100)
    {
      if(gParser.Visible) {
        tbParser.Text = tbParser.Text.Append(lblCurrentThought.Text);
      } else if (gSimpleTextbox.Visible) {
        tbSimpleTextbox.Text = tbSimpleTextbox.Text.Append(lblCurrentThought.Text);
      }
    }
  }
  else if (IsGamePaused() || !IsInterfaceEnabled())
  {
    // game paused, so don't react to any keypresses
    keycode = 0;
  }
  else if (keycode == eKeyQ && (mod & eKeyModCtrl))
  {
    // Ctrl-Q will quit the game
    open_gui(gExitGame);
  }
  else if (keycode == eKeyF5)
  {
    // F5 will prompt to save a game
    show_save_game_dialog();
  }
  else if (keycode == eKeyF7)
  {
    // F7 will prompt to save a game
    show_restore_game_dialog();
  }
  else if (keycode == eKeyF9)
  {
    // F9 will prompt to restart the game
    open_gui(gRestart);
  }
  else if (keycode == eKeyF12)
  {
    // F12 will save a screenshot to the save game folder
    SaveScreenShot("screenshot.pcx");
  }
  else if (keycode >= 65 && keycode <= 90)
  {
    open_gui(gParser);
    //debugDisplay(String.Format("%d", keycode));
    tbParser.Text = keycodeToString(keycode);
  }
  else if (keycode == eKeyF3)
  {
    open_gui(gParser);
    //debugDisplay(keycodeToString(keycode));
    tbParser.Text = lastCMD;
  }
  else if (keycode == eKeyTab)
  {
    // Tab opens the inventory
    show_inventory_window();
  }
  else if (mod & eKeyModCtrl)
  {
    if (keycode == eKeyS)
    {
      // Ctrl-S will give the player all defined inventory items
      Debug(0, 0);
    }
    else if (keycode == eKeyV)
    {
      // Ctrl-V will show game engine version and build date
      Debug(1, 0);
    }
    else if (keycode == eKeyA)
    {
      // Ctrl-A will show walkable areas
      Debug(2, 3);
    }
    else if (keycode == eKeyX)
    {
      // Ctrl-X will let the player teleport to any room
      Debug(3, 0);
    }
  }
}



// called when a mouse button is clicked
function on_mouse_click(MouseButton button)
{
  // called when a mouse button is clicked. button is either LEFT or RIGHT
  if (IsGamePaused())
  {
    
    // game is paused, so do nothing (i.e. don't process mouse clicks)
  }
  else if (button == eMouseLeft)
  {
    // left-click, so try using the current mouse cursor mode at this position
    //Room.ProcessClick(mouse.x, mouse.y, mouse.Mode );
    if(player.GetProperty("sitting") == -1)
    {
      player.Walk(mouse.x, mouse.y, eNoBlock, eWalkableAreas);
    } else {
      int destX = mouse.x;
      int destY = mouse.y;
      standUp(player, 1);
      player.Walk(destX, destY, eNoBlock, eWalkableAreas);
    }
  }
}

// triggered when the Inventory button from the gQuickInventory is clicked
function btnIconInv_Click(GUIControl *control, MouseButton button)
{
  show_inventory_window();
}

//START OF CONTROL PANEL FUNCTIONS
function btnSave_OnClick(GUIControl *control, MouseButton button)
{
  close_owning_gui(control);
  show_save_game_dialog();
}

function btnAbout_OnClick(GUIControl *control, MouseButton button)
{
  Display("%s[AGS %s", Game.Name, System.Version);
}

function btnQuit_OnClick(GUIControl *control, MouseButton button)
{
  close_owning_gui(control);
  open_gui(gExitGame);
}

function btnLoad_OnClick(GUIControl *control, MouseButton button)
{
  close_owning_gui(control);
  show_restore_game_dialog();
}

function sldAudio_OnChange(GUIControl *control)
{
  System.Volume = sldAudio.Value;
}

function btnDefault_OnClick(GUIControl *control, MouseButton button)
{
  set_default_options();
}

function sldSpeed_OnChange(GUIControl *control)
{
  SetGameSpeed(sldSpeed.Value);
}

function btnRestart_OnClick(GUIControl *control, MouseButton button)
{
  close_owning_gui(control);
  open_gui(gRestart);
}

function btnRestartYes_OnClick(GUIControl *control, MouseButton button)
{
  RestartGame();
}

int find_save_slot(String name)
{
  bool slots[] = new bool[999];
  int i = 0;

  while (i < lstSaveGamesList.ItemCount)
  {
    if (lstSaveGamesList.Items[i] == name)
    {
      // found existing save with matching name
      return lstSaveGamesList.SaveGameSlots[i];
    }

    // remember which slots are already taken
    slots[lstSaveGamesList.SaveGameSlots[i]] = true;
    i ++;
  }

  // find first free save slot, starting with slot 1
  i = 1;

  while (i < 999)
  {
    if (!slots[i])
    {
      return i;
    }

    i ++;
  }

  // no free slots found
  return -1;
}

function btnSaveGame_OnClick(GUIControl *control, MouseButton button)
{
  int gameSlotToSaveInto = find_save_slot(txtNewSaveName.Text);

  if (gameSlotToSaveInto < 0)
  {
    Display("No more free save slots!");
  }
  else
  {
    SaveGameSlot(gameSlotToSaveInto, txtNewSaveName.Text);
    close_owning_gui(control);
  }
}

function btnRestoreGame_OnClick(GUIControl *control, MouseButton button)
{
  close_gui(gPanel);
  
  if (lstRestoreGamesList.SelectedIndex >= 0)
  {
    RestoreGameSlot(lstRestoreGamesList.SaveGameSlots[lstRestoreGamesList.SelectedIndex]);
  }
  
  close_owning_gui(control);
  
}

function lstSaveGamesList_OnSelectionCh(GUIControl *control)
{
  txtNewSaveName.Text = lstSaveGamesList.Items[lstSaveGamesList.SelectedIndex];
}

function txtNewSaveName_OnActivate(GUIControl *control)
{
  // pressing Return in the text box simulates clicking the save button
  btnSaveGame_OnClick(control, eMouseLeft);
}

function btnDeleteSave_OnClick(GUIControl *control, MouseButton button)
{
  if (lstSaveGamesList.SelectedIndex >= 0)
  {
    DeleteSaveSlot(lstSaveGamesList.SaveGameSlots[lstSaveGamesList.SelectedIndex]);
    lstSaveGamesList.FillSaveGameList();
  }
}

function btnConfirmedQuit_OnClick(GUIControl *control, MouseButton button)
{
  QuitGame(0);
}

function lbInventory_OnSelectionChanged(GUIControl *control)
{
  String itemName = lbInventory.Items[lbInventory.SelectedIndex];
  lbInventory_Selector_adapt(itemName);
}

function btnToggleHints_OnClick(GUIControl *control, MouseButton button)
{
  if(showHints)
  {
    lblOverHotspot.Visible = false;
    lblOverHotspot.Text = "";
    btnToggleHints.Text = "Hints hidden";
    showHints = false;
  } else {
    lblOverHotspot.Text = "@OVERHOTSPOT@";
    lblOverHotspot.Visible = true;
    btnToggleHints.Text = "Hints shown";
    showHints = true;
  }
}

function tbParser_OnActivate(GUIControl *control) // function that calls the room function 'on call' with index '1' (to start the text parsing)
{
  //PRESS ENTER
  if(gParser.Visible) {
    String cmd = tbParser.Text;
    lastCMD = cmd;
    //debugDisplay(String.Format("lastCMD = %s", lastCMD));
    CallRoomScript (1);
  }
}

function lbVerbs_OnSelectionChanged(GUIControl *control)
{
  lblHelpVerbDesc.Text = verbDescriptionDictionary.Get(lbVerbs.Items[lbVerbs.SelectedIndex]);
}

function btnHelpPanel_OnClick(GUIControl *control, MouseButton button)
{
  open_gui(gHelp);
  close_gui(gPanel);
}

function btnHelpResume_OnClick(GUIControl *control, MouseButton button)
{
  close_gui(gHelp);
  open_gui(gPanel);
}

function btnConfirmCancel_OnClick(GUIControl *control, MouseButton button)
{
  close_gui(gConfirm);
}

function btnConfirmYes_OnClick(GUIControl *control, MouseButton button)
{
  if(gNotebook.Visible) // delete note
  {
    String noteTitle = lbNoteTitles.Items[lbNoteTitles.SelectedIndex];
    notes.Remove(noteTitle);
    lbNoteTitles.RemoveItem(lbNoteTitles.SelectedIndex);
    lbNoteTitles.SelectedIndex = 0;
    lblNoteDescription.Text = notes.Get(lbNoteTitles.Items[lbNoteTitles.SelectedIndex]);
    btnDeleteNote.Enabled = (lbNoteTitles.ItemCount > 1); // must have at least 2 entries to remove one.
  }
  close_gui(gConfirm);
}

function btnDelete_OnClick(GUIControl *control, MouseButton button)
{
  open_gui(gConfirm);
}

function updateNotebook()
{
  lbNoteTitles.Clear();
  String notesToAdd[] = notes.GetKeysAsArray();
  int i;
  
  for(i = 0 ; i < notes.ItemCount ; i++)
  {
    lbNoteTitles.AddItem(notesToAdd[i]);
  }
  
  lbNoteTitles.SelectedIndex = 0;
  lblNoteDescription.Text = notes.Get(lbNoteTitles.Items[lbNoteTitles.SelectedIndex]);
  btnDeleteNote.Enabled = (notes.ItemCount > 1); // must have at least 2 entries to remove one.  
}

function btnNoteBook_OnClick(GUIControl *control, MouseButton button)
{
  updateNotebook();
  open_gui(gNotebook);
}

function btnResume_notebook_OnClick(GUIControl *control, MouseButton button)
{
  close_gui(gNotebook);
  closeNotebookThoughts();
}

function btnLoadAtStart_OnClick(GUIControl *control, MouseButton button)
{
  show_restore_game_dialog();
}

function btnToggleHintsTitleMenu_OnClick(GUIControl *control, MouseButton button)
{
  if(showHints)
  {
    lblOverHotspot.Visible = false;
    lblOverHotspot.Text = "";
    btnToggleHints.Text = "Hints hidden";
    btnToggleHintsTitleMenu.Text = "Hints hidden";
    showHints = false;
  } else {
    lblOverHotspot.Text = "@OVERHOTSPOT@";
    lblOverHotspot.Visible = true;
    btnToggleHints.Text = "Hints shown";
    btnToggleHintsTitleMenu.Text = "Hints shown";
    showHints = true;
  }
}

//##### SCRIPTED CUTSCENES #####
function setStoryBeat(storyBeat newStoryBeat)
{
  CurrentStoryBeat = newStoryBeat;
}

storyBeat getStoryBeat()
{
  return CurrentStoryBeat;
}

function triggerCutscene(cutsceneIndex index)
{
  if(!skipAllCutscene)
  {
    switch(index)
    {
      case beginQuest:
        setStoryBeat(startYourDay);
        setCurrentZone(JonathanApt);
        setupTravelDestinations();
        addTravelDestination(JonathanApt);
        addTravelDestination(HawkinsOffices);
        object[10].Visible = false; // open bedroom door;
        player.Transparency = 50;
        cHarkersBeard.Transparency = 90;
        Wait(10);
        player.Transparency = 0;
        cHarkersBeard.Transparency = 85;
        player.Walk(54, 170, eBlock, eAnywhere);
        player.FaceDirection(eDirectionLeft, eBlock);
        Wait(5);
        object[10].Visible = true; // close bedroom door;
        Wait(5);
        player.FaceDirection(eDirectionRight, eBlock);
        player.Think("What a night...");
        player.Think("I must have worked on those contracts until 3 AM");
        player.Think("I hope Mr. Hawkins will be happy with them");
        player.Think("I guess I should hurry if I want to make it to work before 10 AM");
        //player.Walk(158, 169, eBlock, eAnywhere);
        player.PlaceOnWalkableArea();
        player.FaceDirection(eDirectionDown);
        break;
      case getToWork:
        cHawkins.Say("Ah! Harker!");
        cHarker.FaceCharacter(cHawkins);
        if(isItBeforeThisTime(10, 00, 00, false, 1))
        {
          cHawkins.Say("Good you are on time!");
          if (Game.DoOnceOnly("getToWorkOnTime")) {
              GiveScore(1);
          }
        } else {
          cHawkins.Say("%s![You are late, young man");
        }
        if(cHarkersBeard.Transparency == 100)
        {
          if (Game.DoOnceOnly("shavedHarker")) {
              GiveScore(1);
          }
        } else {
          cHawkins.Say("I would appreciate a clean shaven clerk");
          cHawkins.Say("You are not presentable");
          cHawkins.Say("Anyway.");
        }
        cHawkins.Say("I trust you brought back the contracts from last night");
        cHawkins.Say("Come to my office");
        cHawkins.Walk(object[43].X, object[43].Y, eBlock, eWalkableAreas);
        sit(roomObjects, 43, cHawkins, 4, false);
        break;
      default:
        debugDisplay(String.Format("Cutscene %d is supposed to start but it is not handled by the 'triggerCutscene' function", index));
        break;
    }
  }
  else
  {
    switch(index) // things to do if the cutscene is skipped
    {
      case beginQuest:
        setStoryBeat(startYourDay);
        setCurrentZone(JonathanApt);
        setupTravelDestinations();
        addTravelDestination(HawkinsOffices);
        player.x = 158;
        player.y = 169;
        cHarkersBeard.x = player.x;
        cHarkersBeard.y = player.y;
        player.Transparency = 0;
        cHarkersBeard.Transparency = 85;        
        break;
      default:
        break;
    }
  }
}

function btnNewGame_OnClick(GUIControl *control, MouseButton button)
{
  FadeOut(10);
  close_gui(gStartHelp);
  Wait(20);
  gQuickInventory.Visible = true;
  gStatusline.Visible = true;
  player.ChangeRoom(1);
  Wait(10);
  
}

//##### IN-GAME INTERACTIONS ######

function cHarker_UseInv()
{
  int shavingGlassObjectIndex = findRoomObjectIndexByName("shaving glass");
  
  //debugDisplay(String.Format("%s[%d", activeElementToUse_ElementType, activeElementToUse_Index));
  
  if(activeElementToUse_ElementType == "allInventoryItems" && activeElementToUse_Index == 3)//razor
  {
    if(cHarkersBeard.Transparency == 100)
    {
      player.Think("I do not need to shave");
    } else if(shavingGlassObjectIndex == -1)
    {
      player.Think("I cannot shave here");
    } else if(!object[shavingGlassObjectIndex].Visible && player.HasInventory(iMirror))
    {
      player.Think("I need to install my shaving glass first");
      player.FaceObject(object[shavingGlassObjectIndex]);
      player.Think("There seems to be an appropriate surface over there");
    } else if(object[shavingGlassObjectIndex].Visible && !isCharacterNearObject(object[shavingGlassObjectIndex], reachDistance, player))
    {
      player.FaceObject(object[shavingGlassObjectIndex]);
      player.Think(String.Format("I need to get closer to the %s", object[shavingGlassObjectIndex].Name));
    } else {
      player.FaceObject(object[shavingGlassObjectIndex]);
      cHarkersBeard.Transparency = 100;
      player.Think("Ah, prefectly smooth");
      if (Game.DoOnceOnly("perfect shave")) {
        GiveScore(1);
      }
    }
  }
}

function iLegalPapers_UseInv()
{
  
}

function iFolder_UseInv()
{
  //do nothing
}

function iLedger_Interact()
{
  readThis(iLedger.GetTextProperty("ReadDisplay"), "¶");
}

function confirmSimpleTextbox()
{
  String textInput = tbSimpleTextbox.Text;
  
  close_gui(gSimpleTextbox);
  
  switch(lblSimpleTextbox.Text)
  {
    case "Seller's name":
      proposedSeller = textInput;
      CallRoomScript(3);
      break;
    default:
      break;
  }
}

function tbSimpleTextbox_OnActivate(GUIControl *control)
{
  confirmSimpleTextbox();
}

function lbNoteTitles_OnSelectionChanged(GUIControl *control)
{
  String noteTitle = lbNoteTitles.Items[lbNoteTitles.SelectedIndex];
  lblNoteDescription.Text = notes.Get(noteTitle);
  hasRead(noteTitle);
}

function highlightWord(String word, GUIControl *originalTextLabel, GUIControl *highlighterLbl, int startX,  int startY)
{
  highlighterLbl.Transparency = 100;
  highlighterLbl.Visible = true;
  highlighterLbl.ZOrder = originalTextLabel.ZOrder + 1;
  
  if(startX == 0)
  {
    highlighterLbl.X = startX + originalTextLabel.X;// + originalTextLabel.OwningGUI.X;
  } else {
    highlighterLbl.X = startX + originalTextLabel.X + GetTextWidth(" ", eFontNormal);
  }
  highlighterLbl.Y = startY + originalTextLabel.Y;// + originalTextLabel.OwningGUI.Y;
  highlighterLbl.AsLabel.Text = word;
  highlighterLbl.Width = GetTextWidth(word, eFontNormal) * 2;
  highlighterLbl.Height = GetTextHeight(word, eFontNormal, highlighterLbl.Width);
  highlighterLbl.Transparency = 0;
  memorize(word);
}

String findThatWord(GUIControl* labelName, int clickX, int clickY)
{
  Dictionary* eachWord = Dictionary.Create(eSorted);
  int counter = 0;
  
  String FullText = labelName.AsLabel.Text;
  int lblWidth = labelName.AsLabel.Width;
  
  int spaceIndex = 1000;
  int alineaIndex = 1000;
  int nextCut = 1000;
  String nextCutChar = "";
  
  String thatString = FullText;
  String returnWord;
  
  while(FullText.IndexOf(" ") != -1 || FullText.IndexOf("[") != -1)
  {
    nextCut = 1000;
    nextCutChar = "";
    
    spaceIndex = FullText.IndexOf(" ");
    if(spaceIndex == -1) {
      spaceIndex = 1000;
    } else if (spaceIndex < nextCut) {
      nextCut = spaceIndex;
      nextCutChar = " ";
    }
    alineaIndex = FullText.IndexOf("[");
    if(alineaIndex == -1) {
      alineaIndex = 1000;
    } else if (alineaIndex < nextCut) {
      nextCut = alineaIndex;
      nextCutChar = "[";
    }     
    
    thatString = FullText.Truncate(nextCut);
    thatString = thatString.Replace(" ", "", eCaseInsensitive);
    thatString = thatString.Replace("[", "", eCaseInsensitive);
    eachWord.Set(String.Format("%05d", counter), thatString);
    FullText = removeOneStringInstance(FullText, thatString.Append(nextCutChar));
    counter++;
  }
  eachWord.Set(String.Format("%05d", counter), FullText);
  
  String eachWordArray[] = eachWord.GetValuesAsArray();
  
  thatString = eachWordArray[0];
  int startX = 0;
  int endX = GetTextWidth(thatString, eFontNormal);
  int startY = 0;
  int endY = GetTextHeight(thatString, eFontNormal, lblWidth);
  int newY = GetTextHeight(thatString, eFontNormal, lblWidth);
  int i = 0;
  
  while((i < eachWord.ItemCount - 1) &&
        ((clickX < startX ||
         clickX > endX) ||
        (clickY < startY ||
         clickY > endY)))
  {
    i++;
    thatString = thatString.Append(" ");
    thatString = thatString.Append(eachWordArray[i]);
    newY = GetTextHeight(thatString, eFontNormal, lblWidth);
    if(newY != endY)
    {
      startX = 0;
      endX = GetTextWidth(eachWordArray[i], eFontNormal);
      startY = endY;
      endY = newY;
    } else {
      startX = endX;
      endX = endX + GetTextWidth(eachWordArray[i], eFontNormal) + GetTextWidth(" ", eFontNormal);
    }    
  }
  
  if(i < eachWord.ItemCount) {
    returnWord = eachWordArray[i];
    if(labelName == lblNoteDescription)
    {
      highlightWord(eachWordArray[i], labelName, lblNoteDescriptionHighlight, startX, startY);
    }
  } else {
    returnWord = "";
  }
  
  return returnWord;
}

function btnNoteDescription_OnClick(GUIControl *control, MouseButton button)
{
  int clickX = mouse.x - gNotebook.X - lblNoteDescription.X;
  int clickY = mouse.y - gNotebook.Y - lblNoteDescription.Y;
  
  if(mouse.x > gNotebook.X + lblNoteDescription.X && 
     mouse.x < gNotebook.X + lblNoteDescription.X + lblNoteDescription.Width &&
     mouse.y > gNotebook.Y + lblNoteDescription.Y &&
     mouse.y < gNotebook.Y + lblNoteDescription.Y + lblNoteDescription.Height)
  {
    findThatWord(lblNoteDescription, clickX, clickY);
    //Display(String.Format("Clicked on the text at (%d, %d)", clickX, clickY));
  }
  
}

function btnSimpeTextboxNotebook_OnClick(GUIControl *control, MouseButton button)
{
  open_gui(gNotebook);
}

int whatHourAfterThisPeriod(int nb, String timeType, int currentH, int currentM)
{
  switch(timeType) {
    case "Hours":
      currentH = currentH + nb;
      break;
    case "Minutes":
      currentM = currentM + nb;
      while(currentM >= 60)
      {
        currentM = currentM - 60;
        currentH++;
      }
      break;
    default:
      break;
  }
  while(currentH >= 24)
  {
    currentH = currentH - 24;
  }
  return currentH;
}

int minutesUntilTime(int targetH, String targetAMPM, int currentH, int currentM, String currentAMPM)
{
  if(targetAMPM == "PM") 
  {
    targetH = targetH + 12;
  }
  if(currentAMPM == "PM") {
    currentH = currentH + 12;
  }
  if(targetH <= currentH)
  {
    targetH = targetH + 24;
  }
  targetH = targetH * 60;
  currentH = currentH * 60;
  currentH = currentH + currentM;
  return targetH - currentH;
}

function btnToggleForUntil_OnClick(GUIControl *control, MouseButton button)
{
  String currentBtnText = btnToggleForUntil.Text;
  int showHour = getCurrentHour();
  int showMinutes = getCurrentMinutes();
  String showAMPM = getAMPM();
  int textBoxContent;
  
  if(currentBtnText.EndsWith("for", eCaseInsensitive)) {
    btnToggleForUntil.Text = btnToggleForUntil.Text.Replace("for", "until", eCaseInsensitive);
    btnToggleMinHrs.Text = showAMPM;
  } else {
    btnToggleForUntil.Text = btnToggleForUntil.Text.Replace("until", "for", eCaseInsensitive);
    btnToggleMinHrs.Text = "Minutes";
  }
}

function btnToggleMinHrs_OnClick(GUIControl *control, MouseButton button)
{
  String ForUntilBtnText = btnToggleForUntil.Text;
  String MinHrBtnText = btnToggleMinHrs.Text;
  
  if(ForUntilBtnText.EndsWith("for", eCaseInsensitive)) {
    if(MinHrBtnText == "Minutes")
    {
      btnToggleMinHrs.Text = "Hours";
    } else  {
      btnToggleMinHrs.Text = "Minutes";
    }
  } else {
    if(MinHrBtnText == "AM")
    {
      btnToggleMinHrs.Text = "PM";
    } else  {
      btnToggleMinHrs.Text = "AM";
    }
  }
    
}

function btnConfirmWait_OnClick(GUIControl *control, MouseButton button)
{
  int showHour = getCurrentHour();
  int showMinutes = getCurrentMinutes();
  String showAMPM = getAMPM();
  String ForUntilBtnText = btnToggleForUntil.Text;
  String MinHrBtnText = btnToggleMinHrs.Text;
  int minutesToAdd;
  
  if(ForUntilBtnText.EndsWith("for"))
  {
    minutesToAdd = tbWaitAmount.Text.AsInt;
    if(MinHrBtnText == "Hours")
    {
      minutesToAdd = minutesToAdd * 60;
    }    
  } else {
    minutesToAdd = minutesUntilTime(tbWaitAmount.Text.AsInt, btnToggleMinHrs.Text, showHour, showMinutes, showAMPM);
  }
  close_gui(gWait);
  FadeOut(3);
  addTime(0, minutesToAdd, 0, 0);
  Wait(40);
  FadeIn(3);
  player.Say(String.Format("Well, it is %s, now", whatTimeIsIt(true)));
}

function btnCancelWait_OnClick(GUIControl *control, MouseButton button)
{
  close_gui(gWait);
}

function btnInvContext_OnClick(GUIControl *control, MouseButton button)
{
  String fileFamily = lbInventory.Items[lbInventory.SelectedIndex];
  if(btnInvContext.Text == "> Classify")
  {
    close_gui(gInventory);
    switch(fileFamily)
    {
      case "Legal papers":
        openClassifyGUI(fileFamily, legalPapers);
        break;
      default:
        debugDisplay(String.Format("Trying to fill lbClassifiable, but %s is unrecognized", fileFamily));
        break;
    }    
    
  }
}

function btnClassifyBackToInventory_OnClick(GUIControl *control, MouseButton button)
{
  close_gui(gClassify);
  show_inventory_window();
}

function lbClassifiable_OnSelectionChanged(GUIControl *control)
{
  if(lblClassifyTitle.Text.IndexOf("Legal papers") != -1) {
    lblClassifyDescription.Text = legalPapers.Get(lbClassifiable.Items[lbClassifiable.SelectedIndex]);
  }
}

function updateDictionaryOrder(Dictionary* thisDict, ListBox* thisLB)
{
  Dictionary* tempDict = Dictionary.Create(eNonSorted);
  String thisDictKeys[];
  int i;
  thisDictKeys = thisDict.GetKeysAsArray();
  
  for(i = 0 ; i < thisDict.ItemCount ; i++)
  {
    tempDict.Set(thisDictKeys[i], thisDict.Get(thisDictKeys[i]));
  }
  
  thisDict.Clear();
  
  for(i = 0 ; i < thisLB.ItemCount ; i++)
  {
    thisDict.Set(thisLB.Items[i], tempDict.Get(thisLB.Items[i]));
  }
}

function changeListBoxOrder(ListBox* thisLB, bool UP, int currentIndex)
{
   String itemName;
   int indexMove = 1;
   if(UP)
   {
     indexMove = -1;     
   }
   
   if(UP && currentIndex > 0 || !UP && currentIndex < thisLB.ItemCount - 1) {
     itemName = thisLB.Items[currentIndex];
     thisLB.RemoveItem(currentIndex);
     thisLB.InsertItemAt(currentIndex + indexMove, itemName);
     thisLB.SelectedIndex = currentIndex + indexMove;
   }
}

function btnClassifyUP_OnClick(GUIControl *control, MouseButton button)
{
  int currentSelection = lbClassifiable.SelectedIndex;
  
  if(lblClassifyTitle.Text.IndexOf("Legal papers") != -1) {
    changeListBoxOrder(lbClassifiable, true, currentSelection);
    updateDictionaryOrder(legalPapers, lbClassifiable);
  }   
}

function btnClassifyDOWN_OnClick(GUIControl *control, MouseButton button)
{
  int currentSelection = lbClassifiable.SelectedIndex;
  
  if(lblClassifyTitle.Text.IndexOf("Legal papers") != -1) {
    changeListBoxOrder(lbClassifiable, false, currentSelection);
    updateDictionaryOrder(legalPapers, lbClassifiable);
  }  
}

function btnClassifyFILEIT_OnClick(GUIControl *control, MouseButton button)
{
  ValidateFileIt(lbClassifiable, legalPapers_solution, iLegalPapers, 124, "Legal dossier", 2);
}

function btnSimpleTBConfirm_OnClick(GUIControl *control, MouseButton button)
{
  confirmSimpleTextbox();
}

function btnStartGame_OnClick(GUIControl *control, MouseButton button)
{
  FadeOut(6);
  close_gui(gSplash);
  Wait(10);
  open_gui(gStartHelp);
  FadeIn(6);
}
