/*TO IMPLEMENT
Look at drawers
GUI Z-ORDER : 0 = gameplay (gDark) ; 1 = semi-gameplay (Status Line) ; 2 = main guis ; 3 = precise gui
*/

// main global script file
#define WALK_SPEED 5
#define NUMBEROFROOMS 17
#define PROPERTIESPERSECTOR 3
#define STANDARDTIMEINCREMENT 4
#define MAXNEGATIVE 10

#define FIRSTDAY_DAY 23
#define FIRSTDAY_MONTH 4
#define FIRSTDAY_YEAR 1893
#define MAX_CLOUDINESS 50

#define SKIPCUTSCENES false
#define ACTIVATEDEBUGTOOL true

AudioChannel* bgMusic;
int playingMusic = 0;

int cloudiness = 0;
bool adjustForDarkness = false;

Dictionary* verbDictionary;
Dictionary* verbDescriptionDictionary;
Dictionary* notes;
Set* afterNotebookThoughts;

Dictionary* timedEvents;
bool gottaSleep;
bool testingExpiration;
bool handlingTriggeredEvent;

Dictionary* telegramRecipient_alternateNames;
Dictionary* telegramRecipient_recipientDescription;
Dictionary* telegramRecipient_signOff;
Dictionary* telegramRecipient_messageParts_include;
Dictionary* telegramRecipient_messageParts;
Dictionary* telegramAnswer_messageParts_include;
Dictionary* telegramAnswer_messageParts;
Dictionary* telegram_description;
Dictionary* telegram_notes;
Dictionary* hotelPackages_description;
Dictionary* hotelPackages_notes;

Dictionary* commerce_openingTime;
Dictionary* commerce_closingTime;
Dictionary* commerce_rebuteWhenClosed;
Dictionary* zone_CommerceType;

Dictionary* hawkinsLedgerCity;
Dictionary* hawkinsLedgerSector;
Dictionary* hawkinsLedgerPropertyAge;
String ledgerReadText;
Dictionary* hawkinsRequestCity;
Dictionary* hawkinsRequestSector;
Dictionary* hawkinsRequestPropertyAgeMin;
Dictionary* hawkinsRequestPropertyAgeMax;
Dictionary* hawkinsRequestMessage;
Set* hawkinsRequesters;
String proposedSeller;
String carfaxSeller;
int nbNegatives;

Dictionary* exam_ActualAnswers;
Dictionary* exam_SubmittedAnswers;

Dictionary* trainTimeTableSorter;
Dictionary* trainTimetableOrigin;//key is departure time
Dictionary* trainTimetableDestination;//key is departure time
Dictionary* trainTimetableArrivalTimes;//key is departure time
bool trainScheduleCreated = false;
bool trainDepartureAnnounced = false;
Set* availableTrainDestination;
String trainDepartureTime;
String trainInStation;

Set* availableDestinations;
Dictionary* roomForEachTravelDestinations;
Dictionary* x_TravelDestinations;
Dictionary* y_TravelDestinations;
Dictionary* city_TravelDestinations;
Dictionary* cabSellMsg_TravelDestinations;
int arrival_x[];
int arrival_y[];
String interiorORexterior[];
CharacterDirection faceDirection[];
int exeterTravelDistanceMultiplier;
int londonTravelDistanceMultiplier;
String cabbyPropositions[];
zone currentZone;
commerce currentCommerceType;
zone wantedDestination;
zone realDestination;
bool travelling = false;

Dictionary* food_description;
Dictionary* food_notes;
Dictionary* food_spoilTime;
Dictionary* food_alternateNames;

Dictionary* books_description;
Dictionary* books_notes;
Dictionary* books_separator;
Dictionary* books_reunitor;

bool proposedArchiveBooks[];

Dictionary* film_description;
Dictionary* film_notes;
Dictionary* photo_description;
Dictionary* photo_notes;
Dictionary* saleDossier_description;
Dictionary* saleDossier_notes;
Set* saleDossier_solution;

Dictionary* legalPapers_description;
Dictionary* legalPapers_notes;
Set* legalPapers_solution;

Dictionary* britishMuseumBooks_author;
Dictionary* britishMuseumBooks_comment;
Dictionary* britishMuseumBooks_notes;

float reachDistance = 40.0;
String lastCMD;
int nbFrameInSittingAnim;
int loopPerSecond;
int currentTimeIncrementPerLoop = STANDARDTIMEINCREMENT;
float timeUITransparency;
float timeUIFadeSpeed = 0.1;

bool debugTools;
bool skipAllCutscene;

int useIndex;
elementType useET;

int lastMealTime;

// set default game options
function set_default_options()
{
  System.Volume = 100;
  sldAudio.Value = System.Volume;
  sldSpeed.Value = 40;
  SetGameSpeed(40);
}

// initialize gPanel
function initialize_control_panel()
{
  set_default_options();
}

// hide the icon bar and show a GUI
function open_gui(GUI* gui_to_open)
{
  if (gui_to_open != gInventory)
  {
    lblOverHotspot.Visible = false;
  }

  //gIconbar.Visible = false;
  mouse.UseModeGraphic(eModePointer);
  gui_to_open.Visible = true;
}

// hide the GUI and show the icon bar
function close_gui(GUI* gui_to_close)
{
  gui_to_close.Visible = false;
  mouse.UseDefaultGraphic();
  lblOverHotspot.Visible = true;
  //gIconbar.Visible = true;
}

// hide a GUI, based on a GUI control
function close_owning_gui(GUIControl* control)
{
  close_gui(control.OwningGUI);
}

// hide a GUI directly from an OnClick event
function close_gui_onclick(GUIControl *control, MouseButton button)
{
  close_owning_gui(control);
}

// called when the game starts, before the first room is loaded
function game_start()
{
  // initialize gPanel controls
  initialize_control_panel();

  // set KeyboardMovement movement mode
  KeyboardMovement.Mode = eKeyboardMovementModeTapping;
  
  lastCMD = "";
  nbFrameInSittingAnim = 2;
  loopPerSecond = 40;
  
  player.Transparency = 100;
  mouse.Mode = eModePointer;
  
  currentTime = ((9 * 3600) + (0 * 60) + (0)) * loopPerSecond;
  timeUITransparency = 200.0;
  lblCurrentThought.Transparency = 100;
  
  //debug variables
  debugTools = ACTIVATEDEBUGTOOL;
  skipAllCutscene = SKIPCUTSCENES;
  
  //Beard code
  cHarkersBeard.Transparency = 100;
  cHarkersBeard.ChangeRoom(cHarker.Room, cHarker.x, cHarker.y, eDirectionDown);
  cHarkersBeard.FollowCharacter(cHarker, FOLLOW_EXACTLY);
  
  availableDestinations = Set.Create(eSorted);
  roomForEachTravelDestinations = Dictionary.Create(eSorted);
  x_TravelDestinations = Dictionary.Create(eSorted);
  y_TravelDestinations = Dictionary.Create(eSorted);
  city_TravelDestinations = Dictionary.Create(eSorted);
  cabSellMsg_TravelDestinations = Dictionary.Create(eSorted);
  exeterTravelDistanceMultiplier = 8;
  londonTravelDistanceMultiplier = 16;
  arrival_x = new int[NUMBEROFROOMS+1];
  arrival_y = new int[NUMBEROFROOMS+1];  
  interiorORexterior = new String[NUMBEROFROOMS+1];
  faceDirection = new CharacterDirection[NUMBEROFROOMS+1];
  
  int roomIndex;
  
  roomIndex = 1; //Jonathan's apartment 
  arrival_x[roomIndex] = 185;
  arrival_y[roomIndex] = 147;
  interiorORexterior[roomIndex] = "interior";
  faceDirection[roomIndex] = eDirectionDown;
  
  roomIndex = 2; //Hawkins Office
  arrival_x[roomIndex] = 154;
  arrival_y[roomIndex] = 163;
  interiorORexterior[roomIndex] = "interior";
  faceDirection[roomIndex] = eDirectionUp;
  
  roomIndex = 3; // Train station and caf√© - Exeter
  arrival_x[roomIndex] = 345;
  arrival_y[roomIndex] = 185;
  interiorORexterior[roomIndex] = "exterior";
  faceDirection[roomIndex] = eDirectionDown;
  
  roomIndex = 4; // NA
  arrival_x[roomIndex] = 0;
  arrival_y[roomIndex] = 0;
  interiorORexterior[roomIndex] = "exterior";
  faceDirection[roomIndex] = eDirectionDown;
  
  roomIndex = 5; // Train station and cabby - London
  arrival_x[roomIndex] = 117;
  arrival_y[roomIndex] = 187;
  interiorORexterior[roomIndex] = "exterior";
  faceDirection[roomIndex] = eDirectionRight;
  
  roomIndex = 6;//Purfleet road
  arrival_x[roomIndex] = 171;
  arrival_y[roomIndex] = 183;
  interiorORexterior[roomIndex] = "exterior";
  faceDirection[roomIndex] = eDirectionDown;
  
  roomIndex = 7; // NA
  arrival_x[roomIndex] = 0;
  arrival_y[roomIndex] = 0;
  interiorORexterior[roomIndex] = "exterior";
  faceDirection[roomIndex] = eDirectionDown;
  
  roomIndex = 8; // telegram
  arrival_x[roomIndex] = 56;
  arrival_y[roomIndex] = 147;
  interiorORexterior[roomIndex] = "interior";
  faceDirection[roomIndex] = eDirectionDown;
  
  roomIndex = 9;//British museum _ collection
  arrival_x[roomIndex] = 200;
  arrival_y[roomIndex] = 167;
  interiorORexterior[roomIndex] = "interior";
  faceDirection[roomIndex] = eDirectionDown;
  
  roomIndex = 10; // Law Society
  arrival_x[roomIndex] = 265;
  arrival_y[roomIndex] = 151;
  interiorORexterior[roomIndex] = "interior";
  faceDirection[roomIndex] = eDirectionDown;
  
  roomIndex = 11; // NA
  arrival_x[roomIndex] = 0;
  arrival_y[roomIndex] = 0;
  interiorORexterior[roomIndex] = "exterior";
  faceDirection[roomIndex] = eDirectionDown;
  
  roomIndex = 12; // NA
  arrival_x[roomIndex] = 0;
  arrival_y[roomIndex] = 0;
  interiorORexterior[roomIndex] = "exterior";
  faceDirection[roomIndex] = eDirectionDown;
  
  roomIndex = 13; // NA
  arrival_x[roomIndex] = 0;
  arrival_y[roomIndex] = 0;
  interiorORexterior[roomIndex] = "interior";
  faceDirection[roomIndex] = eDirectionDown;
  
  roomIndex = 14; // Carfax front
  arrival_x[roomIndex] = 0;
  arrival_y[roomIndex] = 0;
  interiorORexterior[roomIndex] = "exterior";
  faceDirection[roomIndex] = eDirectionDown;
  
  roomIndex = 15; // Carfax side,  left
  arrival_x[roomIndex] = 0;
  arrival_y[roomIndex] = 0;
  interiorORexterior[roomIndex] = "exterior";
  faceDirection[roomIndex] = eDirectionDown;
  
  roomIndex = 16; // Carfax side,  right
  arrival_x[roomIndex] = 0;
  arrival_y[roomIndex] = 0;
  interiorORexterior[roomIndex] = "exterior";
  faceDirection[roomIndex] = eDirectionDown;
  
  roomIndex = 17; // British archive
  arrival_x[roomIndex] = 0;
  arrival_y[roomIndex] = 0;
  interiorORexterior[roomIndex] = "interior";
  faceDirection[roomIndex] = eDirectionDown;
  
  hawkinsLedgerCity = Dictionary.Create(eSorted);
  hawkinsLedgerSector = Dictionary.Create(eSorted);
  hawkinsLedgerPropertyAge = Dictionary.Create(eSorted);
  ledgerReadText = "";
  hawkinsRequestCity = Dictionary.Create(eSorted);
  hawkinsRequestSector = Dictionary.Create(eSorted);
  hawkinsRequestPropertyAgeMin = Dictionary.Create(eSorted);
  hawkinsRequestPropertyAgeMax = Dictionary.Create(eSorted);
  hawkinsRequestMessage = Dictionary.Create(eSorted);
  hawkinsRequesters = Set.Create(eSorted);
  nbNegatives = 10;
  
  exam_ActualAnswers = Dictionary.Create(eNonSorted);
  exam_SubmittedAnswers = Dictionary.Create(eNonSorted);
  
  timedEvents = Dictionary.Create(eSorted);
  testingExpiration = false;
  handlingTriggeredEvent = false;
    
  notes = Dictionary.Create(eNonSorted);
  afterNotebookThoughts = Set.Create(eNonSorted);
  notes.Set("How to use", "When something notable is thought or said, you will see an asterisk (*) at the end of the sentence. Write the 'Note' command to add it to your notebook.");
  notes.Set("Mina - tea", "Meet Mina at Station caf√© for tea at 11AM.");
  
  telegramRecipient_alternateNames = Dictionary.Create(eNonSorted);
  telegramRecipient_recipientDescription = Dictionary.Create(eNonSorted);
  telegramRecipient_signOff = Dictionary.Create(eNonSorted);
  telegramRecipient_messageParts = Dictionary.Create(eSorted);
  telegramRecipient_messageParts_include = Dictionary.Create(eSorted);
  telegramAnswer_messageParts_include = Dictionary.Create(eSorted);
  telegramAnswer_messageParts = Dictionary.Create(eSorted);
  telegram_description = Dictionary.Create(eNonSorted);
  telegram_notes = Dictionary.Create(eNonSorted);
  hotelPackages_description = Dictionary.Create(eNonSorted);
  hotelPackages_notes = Dictionary.Create(eNonSorted);
  
  commerce_openingTime = Dictionary.Create(eNonSorted);
  commerce_closingTime = Dictionary.Create(eNonSorted);
  commerce_rebuteWhenClosed = Dictionary.Create(eNonSorted);
  zone_CommerceType = Dictionary.Create(eNonSorted);
  
  food_description = Dictionary.Create(eSorted);
  food_notes = Dictionary.Create(eSorted);
  food_spoilTime = Dictionary.Create(eSorted);
  food_alternateNames = Dictionary.Create(eSorted);
  
  books_description = Dictionary.Create(eSorted);
  books_notes = Dictionary.Create(eSorted);
  books_reunitor = Dictionary.Create(eSorted);
  books_separator = Dictionary.Create(eSorted);
  
  proposedArchiveBooks = new bool[7];
  proposedArchiveBooks[0] = false;//dummy item,  dialog options start at 1
  proposedArchiveBooks[1] = false;
  proposedArchiveBooks[2] = false;
  proposedArchiveBooks[3] = false;
  proposedArchiveBooks[4] = false;
  proposedArchiveBooks[5] = false;
  proposedArchiveBooks[6] = false;
  
  britishMuseumBooks_author = Dictionary.Create(eSorted);
  britishMuseumBooks_comment = Dictionary.Create(eSorted);
  britishMuseumBooks_notes = Dictionary.Create(eSorted);
  
  legalPapers_description = Dictionary.Create(eNonSorted);
  legalPapers_notes = Dictionary.Create(eNonSorted);
  legalPapers_solution = Set.Create(eNonSorted);
  legalPapers_solution.Add("Title page");
  legalPapers_solution.Add("Articles");
  legalPapers_solution.Add("Signatures");
  
  photo_description = Dictionary.Create(eNonSorted);
  photo_notes = Dictionary.Create(eNonSorted);
  film_description = Dictionary.Create(eNonSorted);
  film_notes = Dictionary.Create(eNonSorted);
  saleDossier_description = Dictionary.Create(eNonSorted);
  saleDossier_notes = Dictionary.Create(eNonSorted);
  saleDossier_solution = Set.Create(eNonSorted);
  saleDossier_solution.Add("Title page");
  saleDossier_solution.Add("Conditions");
  saleDossier_solution.Add("Property deed");
  saleDossier_solution.Add("Carfax's Bedroom");
  saleDossier_solution.Add("Carfax's Dining");
  saleDossier_solution.Add("Carfax's Living");
  saleDossier_solution.Add("Carfax's Kitchen");
  saleDossier_solution.Add("Property survey");
  saleDossier_solution.Add("Sales and advertisement");
  saleDossier_solution.Add("Tenants and Leases");
  saleDossier_solution.Add("Labour book");
  saleDossier_solution.Add("Signatures");
  
  verbDictionary = Dictionary.Create(eNonSorted, eCaseInsensitive);
  verbDictionary.Set("look", "look");
  verbDictionary.Set("use", "use");
  verbDictionary.Set("photograph", "photograph");
  verbDictionary.Set("take picture", "photograph");
  verbDictionary.Set("take a picture", "photograph");
  verbDictionary.Set("take photo", "photograph");
  verbDictionary.Set("take a photo", "photograph");
  verbDictionary.Set("examine", "look");
  verbDictionary.Set("open", "open");
  verbDictionary.Set("close", "close");
  verbDictionary.Set("go to", "approach");
  verbDictionary.Set("approach", "approach");
  verbDictionary.Set("note", "note");
  verbDictionary.Set("talk", "talk");
  verbDictionary.Set("speak", "talk");
  verbDictionary.Set("take", "take");
  verbDictionary.Set("get", "take");
  verbDictionary.Set("pick up", "take");
  verbDictionary.Set("read", "read");
  verbDictionary.Set("sit", "sit");
  verbDictionary.Set("stand", "stand");
  verbDictionary.Set("organize", "organize");
  verbDictionary.Set("classify", "organize");
  verbDictionary.Set("eat", "eat");
  verbDictionary.Set("consume", "eat");
  
  verbDictionary.Set("debugadditem", "debugadditem");
  
  verbDescriptionDictionary = Dictionary.Create(eSorted, eCaseInsensitive);
  verbDescriptionDictionary.Set("look", "Look at something or someone in the room (or at one of your inventory items.[[EXAMPLE: Look carpet");
  verbDescriptionDictionary.Set("use", "Use an item from your inventory or an object in the room near you. Sometimes, you must specify on what or on whom you use the object.[[EXAMPLE 1: Use sink[[EXAMPLE 2: Use razor on myself");
  verbDescriptionDictionary.Set("photograph", "Take the picture of something.[Only usable when you have a camera.[[EXAMPLE: Photograph kitchen");
  //verbDescriptionDictionary.Set("give", "Give an intem from your inventory to someone else. You must specify to whom you wish to give the item.[[EXAMPLE: Give ring to Mina");
  verbDescriptionDictionary.Set("open", "Open an object near you or an item from your inventory.[[EXAMPLE: Open front door");
  verbDescriptionDictionary.Set("close", "Close an object near you or an item from your inventory.[[EXAMPLE: Close bedroom door");
  verbDescriptionDictionary.Set("*approach", "Have Jonathan walk over to something or someone.[[Only works if 'Show hints' is chosen from the option panel.[[EXAMPLE: Approach dining table");
  verbDescriptionDictionary.Set("note", "Have Jonathan write down his notable information.[Only works when Jonathan has a notebook[[EXAMPLE: Note");
  verbDescriptionDictionary.Set("talk", "Talk to someone in the room.[Sometimes, you need to be near someone to talk to them.[[EXAMPLE: Talk to Count");
  verbDescriptionDictionary.Set("take", "Pick up an object and place it in your inventory.[[EXAMPLE: Take razor");
  verbDescriptionDictionary.Set("read", "Read something.[Not all items can be read.[[EXAMPLE: Read ledger");
  verbDescriptionDictionary.Set("sit", "Have Jonathan sit down in a nearby chair or appropriate surface.[Jonathan will not sit on any surface.[[EXAMPLE: Sit on bench");
  verbDescriptionDictionary.Set("spot", "Have Jonathan point out objects, people and inventory items that contain a certain word in its name.[[EXAMPLE: Spot door");
  verbDescriptionDictionary.Set("stand", "Have Jonathan stand up.[[EXAMPLE: Stand up");
  verbDescriptionDictionary.Set("organize", "Have Jonathan organize items.[Only classifiable items can be organized.[[EXAMPLE: Organize legal papers");
  verbDescriptionDictionary.Set("eat", "Have Jonathan eat something.[Only food items can be eaten.[Pay attention to the freshness of food.[[EXAMPLE: Eat tea sandwich");
    
  int i;
  String myVerbs[] = verbDescriptionDictionary.GetKeysAsArray();
  
  for(i = 0; i < verbDescriptionDictionary.ItemCount; i++)
  {
    lbVerbs.AddItem(myVerbs[i]);
  }
  lblHelpVerbDesc.Text = verbDescriptionDictionary.Get(lbVerbs.Items[lbVerbs.TopItem]);
  
}

bool getSkipCutscene()
{
  return skipAllCutscene;
}

// Called when a dialog script line "run-script" is processed
function dialog_request(int param)
{
  switch(param)
  {
    default:
      break;
  }
  
}

function show_save_game_dialog()
{
  // get the list of save games
  lstSaveGamesList.FillSaveGameList();

  if (lstSaveGamesList.ItemCount > 0)
  {
    // if there is at least one, set the default text
    // to be the first game's name
    txtNewSaveName.Text = lstSaveGamesList.Items[0];
  }
  else
  {
    // no save games yet, so default to empty text
    txtNewSaveName.Text = "";
  }

  open_gui(gSaveGame);
}

function show_restore_game_dialog()
{
  lstRestoreGamesList.FillSaveGameList();
  open_gui(gRestoreGame);
}

//################## DEBUG DISPLAY FUNCTION ####################################

function debugDisplay(String message) // Display used for debug so we can turn them off safely for the release candidate
{
  if(debugTools){
    Display(message);
  }
}

function debugDisplayFromHere(String message)
{
  if(debugFromHere)
  {
    debugDisplay(message);
  }
}

//################## STRING CUSTOM FUNCTIONS ####################################

String keycodeToString(char typeCharacter) // returns the symbol associated with the code (e.g.: 65 => A)
{
  return String.Format("%c",  typeCharacter);
}

String etToString(elementType eT) // changes the element type enum (roomObject,  AllInventoryItem,  roomHotspot and allCharacters) to a String
{
  switch(eT)
  {
    case roomObjects:
      return "roomObjects";
      break;
    case roomHotspots:
      return "roomHotspots";
      break;
    case allCharacters:
      return "allCharacters";
      break;
    case allInventoryItems:
      return "allInventoryItems";
      break;
    default:
      //debugDisplay(String.Format("Fxn etToString received element type #%d, out of bounds.", eT));
      break;
  }
}

elementType stringToET(String eT) // changes the String to the element type enum spelled out (roomObject,  AllInventoryItem,  roomHotspot and allCharacters)
{
  switch(eT)
  {
    case "roomObjects":
      return roomObjects;
      break;
    case "roomHotspots":
      return roomHotspots;
      break;
    case "allCharacters":
      return allCharacters;
      break;
    case "allInventoryItems":
      return allInventoryItems;
      break;
    default:
      //debugDisplay(String.Format("Fxn stringToET received string %s, unknown.", eT));
      break;
  }
}

bool alphaOrder_isThisBeforeThat(String thisString, String thatString)
{
  Set* alphabetise = Set.Create(eSorted, eCaseInsensitive);
  alphabetise.Add(thisString);
  alphabetise.Add(thatString);
  String alphaArray[] = alphabetise.GetItemsAsArray();
  return (thisString == alphaArray[0]);
}

bool startsWithVowel(String word) // returns true if a String starts with a vowel (useful for distinction between the use of 'a' or 'an' as articles
{
  bool doesStartWithAVowel = false;
  if(word.StartsWith("A", eCaseInsensitive)){
    doesStartWithAVowel = true;
  } else if(word.StartsWith("E", eCaseInsensitive)){
    doesStartWithAVowel = true;
  } else if(word.StartsWith("I", eCaseInsensitive)){
    doesStartWithAVowel = true;
  } else if(word.StartsWith("O", eCaseInsensitive)){
    doesStartWithAVowel = true;
  } else if(word.StartsWith("U", eCaseInsensitive)){
    doesStartWithAVowel = true;
  } else if(word.StartsWith("Y", eCaseInsensitive)){
    doesStartWithAVowel = true;
  }
  return doesStartWithAVowel;
}

String removeOneStringInstance(String fullText, String stringToRemoveOnce) // basically the String.Replace function,  but only for the first occurrence (not all)
{
  int i;
  int finishAt = fullText.IndexOf(stringToRemoveOnce) + stringToRemoveOnce.Length;
  String finalReplacement = "";
  for(i = fullText.IndexOf(stringToRemoveOnce); i < finishAt; i++)
  {
    fullText = fullText.ReplaceCharAt(i, 95);
    finalReplacement = finalReplacement.Append("_");
  }
  fullText = fullText.Replace(finalReplacement, "", eCaseInsensitive);
  return fullText;
}

String[] split(String textToSplit, String separator) // Returns an array of string split by separators !! CAREFUL array[0] is the array's length,  not an item !!
{
  int i;
  String testString = textToSplit.Replace(separator, "", eCaseInsensitive);
  int nbStringItems = textToSplit.Length;
  nbStringItems = nbStringItems - testString.Length;
  
  String returnArray[] = new String[nbStringItems];
  returnArray[0] = String.Format("%d", nbStringItems);
  
  for(i = 1; i < nbStringItems; i++)
  {
    
    if(textToSplit.IndexOf(separator) != -1)
    {
      returnArray[i] = textToSplit.Substring(0, textToSplit.IndexOf(separator));
      textToSplit = removeOneStringInstance(textToSplit, returnArray[i].Append(separator));
    } else
    {
      returnArray[i] = textToSplit;
    }
  }
  
  return returnArray;
}

String cmdStartsWithUSEsynonym(String cmd) // Return on the the 'use synonyms' we chose (if found) or "Null" if not found
{
  Set* USEsynonyms = Set.Create();
  USEsynonyms.Add("use");
  USEsynonyms.Add("put");
  USEsynonyms.Add("insert");
  
  String synonymList[] = USEsynonyms.GetItemsAsArray();
  int i = USEsynonyms.ItemCount -1;
  String foundMatch = "Null";
  
  while(i >= 0 && foundMatch == "Null")
  {
    if(cmd.StartsWith(synonymList[i], eCaseInsensitive))
    {
      foundMatch = synonymList[i];
    } else {
      i--;
    }
  }
  
  return foundMatch;
}

String whichArticle(String listOfElementsMentionned, String newElementName) // retunrs the appropriate article for a list of things to list ('A'/'An', 'A second',  etc.)
{ 
  int counter = 1;
  while(listOfElementsMentionned.IndexOf(newElementName) != -1)
  {
    counter++;
    listOfElementsMentionned = removeOneStringInstance(listOfElementsMentionned, newElementName);
  }
  switch(counter)
  {
    case 0:
      if(startsWithVowel(newElementName))
      {
        return "An";
      } else
      {
        return "A";
      }
      break;
    case 1:
      if(startsWithVowel(newElementName))
      {
        return "An";
      } else
      {
        return "A";
      }
      break;
    case 2:
      return "A second";
      break;
    case 3:
      return "A third";
      break;
    case 4:
      return "A fourth";
      break;
    case 5:
      return "A fifth";
      break;
    default:
      return "Another";
      break;
  }
}


//################# INTERACTION AUTOMATION FUNCTIONS ###############################

//##### AUDIO #####
function musicFirstSetup(AudioClip* newMusic, int thisID)
{
  bgMusic = newMusic.Play();
  bgMusic.Volume = 20;
  playingMusic = thisID;
}

function musicInRoom(AudioClip* newMusic, int thisID)
{
  if(playingMusic != thisID)
  {
    if(bgMusic.IsPlaying)
    {
      bgMusic.Stop();
    }
    bgMusic = newMusic.Play();
    bgMusic.Volume = 20;
    playingMusic = thisID;
  }
}

function playConfirm()
{
  AudioChannel* uiSounds = aConfirm.Play(eAudioPriorityLow, eOnce);
  uiSounds.Volume = 100;
}

function playSelect()
{
  AudioChannel* uiSounds = aSelect.Play(eAudioPriorityLow, eOnce);
  uiSounds.Volume = 100;
}

function playCancel()
{
  AudioChannel* uiSounds = aCancel.Play(eAudioPriorityLow, eOnce);
  uiSounds.Volume = 100;
}

//##### UTILITIES #####

function gameIsOver(String message)
{
  lblGameOver_how.Text = message;
  open_gui(gGameOver);
}

int getIndexOfElementUsed()
{
  return useIndex;
}

elementType getETOfElementUsed()
{
  return useET;
}

int getObjectMidX(Object* Obj) {
  DynamicSprite* tempSprite = DynamicSprite.CreateFromExistingSprite(Obj.Graphic);
  int returnInt = tempSprite.Width / 2;
  tempSprite.Delete();
  
  returnInt = returnInt + Obj.X;
  
  return returnInt;
}

float calculateDistanceFromCharacter(int targetX, int targetY,  Character* who) // Return a float of the distance (in px) between a character and a target
{
  float deltaX = IntToFloat(targetX) - IntToFloat(who.x);
  float deltaY = IntToFloat(targetY) - IntToFloat(who.y);
  return Maths.Sqrt(Maths.RaiseToPower(deltaX, 2.0)+ Maths.RaiseToPower(deltaY, 2.0));  
}

bool isCharacterCloseEnough(int targetX, int targetY, float maxDistance,  Character* who) // Returns a bool describing if a character's distance from a target is lower than the indicated max
{
  float dist = calculateDistanceFromCharacter(targetX, targetY, who);
  return dist < maxDistance;
}

bool isCharacterNearHotspot(Hotspot* HS, float maxDistance,  Character* who) // Is the character close to the passed hotspot
{
  return isCharacterCloseEnough(HS.WalkToX, HS.WalkToY, maxDistance,  who);  
}

bool isCharacterNearObject(Object* Obj, float maxDistance,  Character* who) // Is the character close to the passed object
{
  return isCharacterCloseEnough(getObjectMidX(Obj), Obj.Y, maxDistance,  who);  
}

bool isCharacterNearCharacter(Character* target, float maxDistance,  Character* who)  // Is the character close to the passed character
{
  return isCharacterCloseEnough(target.x, target.y, maxDistance,  who);  
}

bool isThisOpened(Object* Obj)
{
  bool returnBool = false;
  
  switch(Obj.GetProperty("Open_SpriteNumber"))
  {
    case -2:
      returnBool = !Obj.Visible;
      break;
    case -1:
      break;
    default:
      returnBool = (Obj.Visible && Obj.Graphic == Obj.GetProperty("Open_SpriteNumber"));
      break;
  }
  
  return returnBool;
}

String whatIsThis(elementType eT, int index) // return an element's name
{
  switch(eT)
  {
    case roomObjects:
      return object[index].Name;
      break;
    case roomHotspots:
      return hotspot[index].Name;
      break;
    case allCharacters:
      return character[index].Name;
      break;
    case allInventoryItems:
      return inventory[index].Name;
      break;
    default: 
      return "Unknown";
      break;
  }
}

String[] findClosestElement(String elementType_index[], float dist[], int arraysLength) // Returns the closest element from indexed arrays
{
  String closestElementType_index = elementType_index[0];
  float closestDist = dist[0];
  String returnArray[] = new String[2];
  
  int i; 
  for(i = 1; i < arraysLength; i++)
  {
    if(dist[i] < closestDist) 
    {
      closestElementType_index = elementType_index[i];
      closestDist = dist[i];
    }
  }
  
  returnArray[0] = closestElementType_index.Truncate(closestElementType_index.IndexOf("_"));
  closestElementType_index = closestElementType_index.Replace(returnArray[0], "", eCaseInsensitive);
  closestElementType_index = closestElementType_index.Replace("_", "", eCaseInsensitive);
  returnArray[1] = closestElementType_index;
  
  return returnArray;
}

String isInteractionOnElement(String cmd) // returns true if the command has both a 'use synonym' and a 'on' synonym (e.g.: USE razor ON Jonathan // INSERT files IN folder)
{
  Set* OnSynonyms = Set.Create(eSorted);
  OnSynonyms.Add(" in ");
  OnSynonyms.Add(" into ");
  OnSynonyms.Add(" onto ");
  OnSynonyms.Add(" on ");
  OnSynonyms.Add(" over ");
  OnSynonyms.Add(" with ");
  OnSynonyms.Add(" under ");
  OnSynonyms.Add(" to ");
  
  String OnSynonymsArray[] = OnSynonyms.GetItemsAsArray();
  int i = OnSynonyms.ItemCount - 1;
  String foundMatch = "Null";
  
  while(i >= 0 && foundMatch == "Null")
  {
    if(cmd.IndexOf(OnSynonymsArray[i]) != -1)
    {
      foundMatch = OnSynonymsArray[i];
    } else {
      i--;
    }
  }
  
  return foundMatch;
}

//##### SCORING #################################################
function giveScoreOnce(String tag, int scoreToGive)
{
  if(Game.DoOnceOnly(tag)){
    GiveScore(scoreToGive);
  }
}

//##### MEMORY MECHANIC #######################################

function memorize(String thought) {
  while(GetTextHeight(String.Format(". . .%s", thought), eFontNormal, lblCurrentThought.Width) > lblCurrentThought.Height)
  {
    thought = thought.Substring(2, thought.Length - 1);
  }
  lblCurrentThought.Text = thought;
  timeUITransparency = 0.0;
}

String getMemorisedThought()
{
  if(lblCurrentThought.Transparency < 100)
  {
    return lblCurrentThought.Text;
  } else {
    return ". . .I forget";
  }
}

function loseThought()
{
  lblCurrentThought.Text = "";
  lblCurrentThought.Transparency = 100;
}


//##### TIME FUNCTIONS #####

String translateTimeToHHMMAM(int hour, int minutes, String AMPM)
{
  return String.Format("%d:%02d%s", hour, minutes, AMPM);
}

String translateMinutesToHHMMAM(int minutes)
{
  int hours = minutes/60;
  minutes = minutes - (hours * 60);
  String AMPM = "AM";
  if(hours >= 12)
  {
    AMPM = "PM";
    if(hours > 12)
    {
      hours = hours - 12;
    }
  }
  return translateTimeToHHMMAM(hours, minutes, AMPM);
}

int translateTimeToMinutes(String HHMMAM)
{
  int returnMinutes;
  String hour = HHMMAM.Truncate(HHMMAM.IndexOf(":"));
  
  int hour_int = hour.AsInt;
  if(HHMMAM.EndsWith("PM") && hour_int != 12)
  {
    hour_int = hour_int + 12;
  }
  returnMinutes = 60*(hour_int);
  
  String minutes = HHMMAM.Substring(HHMMAM.IndexOf(":") + 1, 2);
  
  returnMinutes = returnMinutes + minutes.AsInt;
  
  return returnMinutes;
}

String whatTimeIsIt(bool showTimeInStatusLine)
{
  int timeInLoops = currentTime;
  String AmPm = "AM";
  
  //remove the days from the calculation (and update currentDay while we're at it
  int loopsPerDay = loopPerSecond * 60 * 60 * 24;
  int day = timeInLoops / loopsPerDay;
  timeInLoops = timeInLoops - (day * 60 * 60 * 24 * loopPerSecond);
  currentDay = day;
  
  //manage hours
  int hour = timeInLoops / (loopPerSecond * 3600);
  timeInLoops = timeInLoops - (hour * 3600 * loopPerSecond);
  
  if(hour >= 12)
  {
    AmPm = "PM";
  }
  if(hour > 12)
  {
    hour = hour - 12;
  }
  
  //manage minutes
  int minutes = timeInLoops / (loopPerSecond * 60);
  
  //memorize?
  if(showTimeInStatusLine)
  {
    memorize(String.Format("%d:%02d%s", hour, minutes, AmPm));
  }
  
  return translateTimeToHHMMAM(hour, minutes, AmPm);
}

int getCurrentHour()
{
  String currentHourS = whatTimeIsIt(false);
  
  currentHourS = currentHourS.Truncate(currentHourS.IndexOf(":"));
  
  return currentHourS.AsInt;
}

int getCurrentMinutes()
{
  String currentMinutesS = whatTimeIsIt(false);
  
  if(currentMinutesS.EndsWith("AM")) {
    currentMinutesS = currentMinutesS.Truncate(currentMinutesS.IndexOf("AM"));
  } else {
    currentMinutesS = currentMinutesS.Truncate(currentMinutesS.IndexOf("PM"));
  }
  currentMinutesS = currentMinutesS.Substring(currentMinutesS.IndexOf(":")+1, 2);
   
  return currentMinutesS.AsInt;
}

String getAMPM()
{
  String currentAMPM = whatTimeIsIt(false);
  if(currentAMPM.EndsWith("AM")){
    return "AM";
  } else {
    return "PM";
  }
}

bool isThisTimeWithinXminOfThisTime(String HHMMAM_test, String HHMMAM_max, int withinThisManyMinutes)
{
  int minutes_test = translateTimeToMinutes(HHMMAM_test);
  int minutes_max = translateTimeToMinutes(HHMMAM_max);
  if(minutes_max - minutes_test <= withinThisManyMinutes && minutes_max - minutes_test > 0)
  {
    return true;
  } else
  {
    return false;
  }
}

bool isThisTimeBeforeThisTime(String HHMMAM_1, String HHMMAM_2)
{
  int minutes_1 = translateTimeToMinutes(HHMMAM_1);
  int minutes_2 = translateTimeToMinutes(HHMMAM_2);
  //debugDisplay(String.Format("First : %d[Second: %d[Before? %d", minutes_1, minutes_2, minutes_1 < minutes_2)); 
  return minutes_1 < minutes_2;
}

bool isItBeforeThisTime(int hour, int minutes, int seconds, bool PM, int day)
{
  if(PM && hour != 12)
  {
    hour = hour + 12;
  }
  int maxLoops = ((((((day * 24) + hour) * 60) + minutes) * 60) + seconds) * loopPerSecond;
  int currentAllTimeLoop = currentTime + ((currentDay * 86400) * loopPerSecond);
  return currentAllTimeLoop <= maxLoops;
}

String addTimeToDescription(String textDescription)
{
  String returnText = String.Format("%s[It is %s", textDescription, whatTimeIsIt(true));
  return returnText;
}

function setCurrentTime(int hour, int minutes, int seconds, bool PM,  int day)
{
  if(PM && (hour != 12))
  {
    hour = hour + 12;
  }
  currentTime = ((hour * 3600) + (minutes * 60) + seconds) * loopPerSecond;
  currentDay = day;
}

function addTime(int hour, int minutes, int seconds, int day)
{
  int loopsToAdd = ((hour * 3600) + (minutes * 60) + seconds) * loopPerSecond;
  currentTime = currentTime + loopsToAdd;
}

function show_wait_GUI(String passtimeVerb)
{
  if(player.HasInventory(iWatch)){
    lblWaitUI.Text = String.Format("It is %s[How long should I wait?", whatTimeIsIt(false));
  } else {
    lblWaitUI.Text = String.Format("How long should I wait?");
  }
  passtimeVerb = passtimeVerb.LowerCase();
  lblWaitUI.Text = lblWaitUI.Text.Replace("wait", passtimeVerb);
  btnConfirmWait.Text = btnConfirmWait.Text.Replace("wait", passtimeVerb);
  String firstLetter = passtimeVerb.Truncate(1);
  firstLetter = firstLetter.UpperCase();
  passtimeVerb = firstLetter.Append(passtimeVerb.Substring(1, passtimeVerb.Length-1));
  btnToggleForUntil.Text = btnToggleForUntil.Text.Replace("wait", passtimeVerb);
  tbWaitAmount.Text = "15";
  open_gui(gWait);
}

function modifyCloudiness(int change)
{
  cloudiness = cloudiness + change;
  if(cloudiness < 0)
  {
    cloudiness = 0;
  } else if (cloudiness > MAX_CLOUDINESS)
  {
    cloudiness = MAX_CLOUDINESS;
  }
}

String getInteriorORExterior()
{
  return interiorORexterior[player.Room];
}

int getPercentPositionBetweenXAndY(int min, int max, int now)
{
  int totalDist = 100 * (max - min);
  int positioning = 100 * (now - min);
  return positioning / totalDist;
}

function manageDarkness()
{
  String theNow = whatTimeIsIt(false);
  String dawn = translateTimeToHHMMAM(4, 46, "AM");
  String fullMorning = translateTimeToHHMMAM(5, 46, "AM");
  String dusk = translateTimeToHHMMAM(7, 12, "PM");
  String fullNight = translateTimeToHHMMAM(8, 12, "PM");
  int divider = 1;
  
  if(getInteriorORExterior() == "interior")
  {
    divider = 2;
  }
  
  int nowMinutes;
  int startChange;
  int endChange;
  
  int maxLight = 100 - (cloudiness / divider);
  int minLight = 100 - (MAX_CLOUDINESS / divider);
 
  if(isThisTimeBeforeThisTime(theNow, dawn) || isThisTimeBeforeThisTime(fullNight, theNow)) // night
  {
    gDark.Transparency = minLight;
  } else if(isThisTimeBeforeThisTime(theNow, dusk) && isThisTimeBeforeThisTime(fullMorning, theNow))//day
  {
    gDark.Transparency = maxLight;
  } else if(isThisTimeBeforeThisTime(theNow, fullMorning) && isThisTimeBeforeThisTime(dawn, theNow))//dawn
  {
    startChange = translateTimeToMinutes(dawn);
    endChange = translateTimeToMinutes(fullMorning);
    nowMinutes = translateTimeToMinutes(theNow);
    gDark.Transparency = maxLight + ((maxLight - minLight) * (1 - getPercentPositionBetweenXAndY(startChange, endChange, nowMinutes)) / 100);
  } else if(isThisTimeBeforeThisTime(theNow, fullMorning) && isThisTimeBeforeThisTime(dawn, theNow))//dusk
  {
    startChange = translateTimeToMinutes(dusk);
    endChange = translateTimeToMinutes(fullNight);
    nowMinutes = translateTimeToMinutes(theNow);
    gDark.Transparency = maxLight + (maxLight - minLight * (getPercentPositionBetweenXAndY(startChange, endChange, nowMinutes) / 100));
  }
}

//##### TRAIN TRAVELS ##################################################################
String cityAsString(city cityName)
{
  switch (cityName)
  {
    case Exeter:
      return "Exeter";
      break;
    case London:
      return "London";
      break;
    case Paris:
      return "Paris";
      break;
    case Munich:
      return "Munich";
      break;
    case Vienna:
      return "Vienna";
      break;
    case Budapest:
      return "Budapest";
      break;
    case Klausenburg:
      return "Klausenburg";
      break;
    case Bistritz:
      return "Bistritz";
      break;
    default:
      return "Null";
      break;
  }
}

function addTrainDeparture(city origin, city destination, int hour_O, int minute_O, String AMPM_O, int hour_D, int minute_D, String AMPM_D)
{
  String timeKey = translateTimeToHHMMAM(hour_O, minute_O, AMPM_O);
  String arrivalTime = translateTimeToHHMMAM(hour_D, minute_D, AMPM_D);
  
  trainTimeTableSorter.Set(String.Format("%09d", translateTimeToMinutes(timeKey)), timeKey);
  
  trainTimetableOrigin.Set(timeKey, cityAsString(origin));
  trainTimetableDestination.Set(timeKey, cityAsString(destination));
  trainTimetableArrivalTimes.Set(timeKey, arrivalTime);
}

function adjustTicketDescription(String departureTimeKey)
{
  String ticketDescription;
  if(isThisTimeBeforeThisTime(whatTimeIsIt(false), departureTimeKey))
  {
    ticketDescription = "TODAY";
  } else {
    ticketDescription = "TOMORROW";
  }
  ticketDescription = ticketDescription.Append("[");
  ticketDescription = ticketDescription.Append(trainTimetableOrigin.Get(departureTimeKey));
  ticketDescription = ticketDescription.Append("[");
  ticketDescription = ticketDescription.Append(departureTimeKey);
  ticketDescription = ticketDescription.Append("[");
  ticketDescription = ticketDescription.Append("[");
  ticketDescription = ticketDescription.Append(trainTimetableDestination.Get(departureTimeKey));
  ticketDescription = ticketDescription.Append("[");
  ticketDescription = ticketDescription.Append(trainTimetableArrivalTimes.Get(departureTimeKey));
  
  lblTrainTicketSchedule.Text = ticketDescription;
  lblTrainTicketSchedule.Text = ticketDescription;
}

String getTrainDepartureTime()
{
  return trainDepartureTime;
}

String getTrainArrivalTime(String departureTime)
{
  return trainTimetableArrivalTimes.Get(departureTime);
}

bool canPlayerBoardTrain(String ticketTime)
{
  return ticketTime == trainInStation;
}

String getTrainInStation()
{
  return trainInStation;
}

function show_trainTicket_GUI(city origin, city destination)
{
  String departureTimeKeys[];
  String tomorrowsTimes[];
  departureTimeKeys = trainTimeTableSorter.GetValuesAsArray();
  Set* tomorrow;
  tomorrow = Set.Create(eSorted);
  int i;
  
  lbTrainDepartures.Clear();
  
  lblTrainTicket_title.Text = String.Format("Train Timetable:[%s to %s", cityAsString(origin), cityAsString(destination));
  
  //debugDisplay(whatTimeIsIt(false));
  
  for(i = 0 ; i < trainTimetableOrigin.ItemCount ; i++)
  {
    if(trainTimetableOrigin.Get(departureTimeKeys[i]) == cityAsString(origin) && trainTimetableDestination.Get(departureTimeKeys[i]) == cityAsString(destination))
    {
      if(isThisTimeBeforeThisTime(whatTimeIsIt(false), departureTimeKeys[i]))
      {
        lbTrainDepartures.AddItem(departureTimeKeys[i]);
      } else {
        tomorrow.Add(departureTimeKeys[i]);
      }
    }    
  }
  
  tomorrowsTimes = tomorrow.GetItemsAsArray();
  for(i = 0 ; i < tomorrow.ItemCount ; i++)
  {
    lbTrainDepartures.AddItem(tomorrowsTimes[i]);
    //debugDisplay(String.Format("Tomorrow : %s", departureTimeKeys[i]));
  }
  
  lbTrainDepartures.SelectedIndex = 0;
  adjustTicketDescription(lbTrainDepartures.Items[lbTrainDepartures.SelectedIndex]);
  open_gui(gTrainTickets);
}

function createTrainTimetables()
{
  trainTimeTableSorter = Dictionary.Create(eSorted);
  trainTimetableOrigin = Dictionary.Create(eNonSorted);
  trainTimetableDestination = Dictionary.Create(eNonSorted);
  trainTimetableArrivalTimes = Dictionary.Create(eNonSorted);
  trainInStation = "Null";
  
  //Exeter to London
  addTrainDeparture(Exeter, London, 7, 45, "AM", 12, 1, "PM");
  addTrainDeparture(Exeter, London, 6, 50, "AM", 1, 20, "PM");
  addTrainDeparture(Exeter, London, 10, 25, "AM", 2, 33, "PM");
  addTrainDeparture(Exeter, London, 10, 35, "AM", 4, 43, "PM");
  addTrainDeparture(Exeter, London, 12, 45, "PM", 5, 00, "PM");
  addTrainDeparture(Exeter, London, 1, 11, "PM", 6, 26, "PM");
  addTrainDeparture(Exeter, London, 2, 10, "PM", 7, 52, "PM");
  addTrainDeparture(Exeter, London, 4, 15, "PM", 8, 16, "PM");
  addTrainDeparture(Exeter, London, 6, 00, "PM", 10, 15, "PM");
  
  trainScheduleCreated = true;
}

function isAnyTrainInStation(bool fadeItIn)
{
  int i = 0;
  String depTimes[];
  
  if(!trainScheduleCreated)
  {
    createTrainTimetables();
  }
  
  depTimes = trainTimetableOrigin.GetKeysAsArray();
  
  if(trainInStation != "Null")//There is a train in station
  {
    if(!trainDepartureAnnounced && isThisTimeWithinXminOfThisTime(whatTimeIsIt(false), trainInStation, 1) && object[10].Visible == true)
    {
      cExeterTrainOfficer.SayBackground("Steer clear of the tracks for the train's departure!");
      trainDepartureAnnounced = true;
    } else if(isThisTimeBeforeThisTime(trainInStation, whatTimeIsIt(false)))//Train should leave
    {
      if(fadeItIn)
      {
        if(Game.Camera.X < 100)
        {
          FadeOut(5);
        }
        object[10].Visible = false;
        if(Game.Camera.X < 100)
        {
          FadeIn(5);
        }
      } else
      {
        object[10].Visible = false;
      }
      trainInStation = "Null";
      trainDepartureAnnounced = false;
    }
  } else
  {
    while(i < trainTimetableOrigin.ItemCount)
    {
      if(isThisTimeWithinXminOfThisTime(whatTimeIsIt(false), depTimes[i], 25) && trainInStation == "Null")
      {
        if(fadeItIn)
        {
          player.FaceObject(object[10], eBlock);
          cExeterTrainOfficer.Say(String.Format("The %s train to London is arriving in station!", depTimes[i]));
          if(Game.Camera.X < 100)
          {
            FadeOut(5);
          }
          object[10].Visible = true;
          CallRoomScript(3);
          if(Game.Camera.X < 100)
          {
            FadeIn(5);
          }
          CallRoomScript(2);
        } else {
          object[10].Visible = true;
        }
        cExeterTrainOfficer.SayBackground("All passengers with tickets are required to board immediately");
        cExeterTrainOfficer.SayBackground("This is the one and only call for boarding");
        trainInStation = depTimes[i];
        i = trainTimetableOrigin.ItemCount;
      } else
      {
        i++;
      }      
    }
  }
}


//##### HAWKINS FILES ##################################################################
//Players need to get the requirements (city,  sector,  age), consult the map (city+sector), get the names, use ledger to get the drawer number,  get file by name, validate the age,  bring it back to Hawkins
String createHawkinsPropertyFile (String clientName, String cityName, String sector, int age)
{
  hawkinsLedgerCity.Set(clientName, cityName);
  hawkinsLedgerSector.Set(clientName, sector);
  hawkinsLedgerPropertyAge.Set(clientName, String.Format("%d", age));
  
  return clientName;
}

function createHawkinsRequestFile (String clientName, String cityName, String sector, int ageMin,  int ageMax,  String clientMessage,  bool addToRequesters)
{  
  if(clientMessage == "Auto")
  {
    clientMessage = String.Format("They want a property in %s's %s sector, aged between %d and %d years old", cityName, sector, ageMin, ageMax);
  }
  
  hawkinsRequestCity.Set(clientName, cityName);
  hawkinsRequestSector.Set(clientName, sector);
  hawkinsRequestPropertyAgeMin.Set(clientName, String.Format("%d", ageMin));
  hawkinsRequestPropertyAgeMax.Set(clientName, String.Format("%d", ageMax));
  hawkinsRequestMessage.Set(clientName, clientMessage);
  
  if(addToRequesters)
  {
    hawkinsRequesters.Add(clientName);
  }
}

String getClientListPerCitySector(String thisCity, String sector)
{
  int i;
  String clientFiles[];
  clientFiles = hawkinsLedgerCity.GetKeysAsArray();
  String returnString = "";
  for(i = 0 ; i < hawkinsLedgerCity.ItemCount ; i++)
  {
    if(hawkinsLedgerCity.Get(clientFiles[i]) == thisCity && hawkinsLedgerSector.Get(clientFiles[i]) == sector)
    {
      if(returnString == "")
      {
        returnString = clientFiles[i];
      } else {
        returnString = returnString.Append(String.Format(" , %s", clientFiles[i]));
      }
    }
  }
  return returnString;
}

String generateReadHawkinsFileString(String clientName)
{
  String propAge = hawkinsLedgerPropertyAge.Get(clientName);
  String returnString = String.Format("Name: %s", clientName);
  returnString = returnString.Append(String.Format("[City: %s", hawkinsLedgerCity.Get(clientName)));
  returnString = returnString.Append(String.Format("[Sector: %s", hawkinsLedgerSector.Get(clientName)));
  returnString = returnString.Append(String.Format("[Construction: %d (%s y.o.)", 1893 - (propAge.AsInt), propAge));
  return returnString;
}

String getPropertyRequestMessage(String clientName)
{
  return hawkinsRequestMessage.Get(clientName);
}

Set* getHawkinsSellerList()
{
  Set* sellerList;
  sellerList = Set.Create(eSorted);
  String clientNames[];
  clientNames = hawkinsLedgerCity.GetKeysAsArray();
  int i;
  for(i = 0 ; i < hawkinsLedgerCity.ItemCount ; i++)
  {
    sellerList.Add(clientNames[i]);
  }
  return sellerList;
}

String getPropertyRequesterName()
{
  String returnName;
  String clientNames[];
  clientNames = hawkinsRequesters.GetItemsAsArray();
  returnName = clientNames[Random(hawkinsRequesters.ItemCount - 1)];
  hawkinsRequesters.Remove(returnName);
  return returnName;
}

String capitalizeName(String theName)
{
  if(theName != "")
  {
    String firstLetter = theName.Truncate(1);
    firstLetter = firstLetter.UpperCase();
    theName = String.Format("%s%s", firstLetter, theName.Substring(1, theName.Length-1));
  }
  return theName;
}

String getProposedSeller()
{
  return proposedSeller;
}

bool validatePropertyProposition(String requesterName, String sellerName)
{
  bool validated = true;
  if(hawkinsLedgerCity.Contains(sellerName))
  {
    String propAge = hawkinsLedgerPropertyAge.Get(sellerName);
    String ageMin = hawkinsRequestPropertyAgeMax.Get(requesterName);
    String ageMax = hawkinsRequestPropertyAgeMin.Get(requesterName);
    if( hawkinsLedgerCity.Get(sellerName) != hawkinsRequestCity.Get(requesterName) ||
        hawkinsLedgerSector.Get(sellerName) != hawkinsRequestSector.Get(requesterName) ||
        propAge.AsInt <= ageMax.AsInt ||
        propAge.AsInt >= ageMin.AsInt)
    {
      validated = false;
    }
    sellerName = capitalizeName(sellerName);
    cHawkins.Say(String.Format("Oh yes, the %s's property!", sellerName));
  } else
  {
    sellerName = capitalizeName(sellerName);
    cHawkins.Say(String.Format("%s? I do not know this name. You made a mistake", sellerName));
    validated = false;
  }
  return validated;
}

function createMultipleHawkinsPropertyFile (String thisCity, String sector, int ageMin, int ageMax,  int nbFiles)
{
  int propAge;
  while(nbFiles > 0)
  {
    propAge = ageMin + Random((ageMax - ageMin - 1));
    createHawkinsPropertyFile("Random", thisCity, sector, propAge);
    nbFiles--;
  }
}

function createAllHawkinsFiles ()
{
  createHawkinsRequestFile("Hopkinson", "Exeter", "City center", 25, 75, "Auto", true);
  createHawkinsPropertyFile("Lyon", "Exeter", "City center", 37);
  createHawkinsPropertyFile("Montague", "Exeter", "City center", 196);
  createHawkinsPropertyFile("Heathcote", "Exeter", "City center", 3);
  
  createHawkinsRequestFile("McMahon", "Exeter", "North", 100, 200, "Auto", true);
  createHawkinsPropertyFile("Guest", "Exeter", "North", 183);
  createHawkinsPropertyFile("Foster", "Exeter", "North", 62);
  createHawkinsPropertyFile("Maxton", "Exeter", "North", 512);
  
  createHawkinsRequestFile("Greene", "Exeter", "West", 5, 25, "Auto", true);
  createHawkinsPropertyFile("Drake", "Exeter", "West", 17);
  createHawkinsPropertyFile("Norman", "Exeter", "West", 102);
  createHawkinsPropertyFile("Bernal", "Exeter", "West", 78);
  
  createHawkinsRequestFile("Peel", "Exeter", "South", 500, 850, "Auto", true);
  createHawkinsPropertyFile("MacKay", "Exeter", "South", 678);
  createHawkinsPropertyFile("Brookes", "Exeter", "South", 18);
  createHawkinsPropertyFile("Robinson", "Exeter", "South", 278);
  
  createHawkinsRequestFile("Atkins", "Exeter", "East", 10, 40, "Auto", true);
  createHawkinsPropertyFile("Keen", "Exeter", "East", 11);
  createHawkinsPropertyFile("Vivian", "Exeter", "East", 89);
  createHawkinsPropertyFile("Silkin", "Exeter", "East", 286);
  
  createHawkinsRequestFile("Mancroft", "London", "City center", 200, 300, "Auto", true);
  createHawkinsPropertyFile("Ridley", "London", "City center", 258);
  createHawkinsPropertyFile("Perry", "London", "City center", 148);
  createHawkinsPropertyFile("Smith", "London", "City center", 56);
  
  createHawkinsRequestFile("Watts", "London", "North", 100, 1000, "Auto", true);
  createHawkinsPropertyFile("Sinclair", "London", "North", 852);
  createHawkinsPropertyFile("Sturgeon", "London", "North", 85);
  createHawkinsPropertyFile("Greenwood", "London", "North", 52);
  
  createHawkinsRequestFile("Ormsby", "London", "West", 20, 50, "Auto", true);
  createHawkinsPropertyFile("Wakefield", "London", "West", 34);
  createHawkinsPropertyFile("Howarth", "London", "West", 9);
  createHawkinsPropertyFile("Dunwoody", "London", "West", 144);
  
  createHawkinsRequestFile("Tyrwhitt", "London", "South", 500, 850, "Auto", true);
  createHawkinsPropertyFile("Paisley", "London", "South", 678);
  createHawkinsPropertyFile("Cryer", "London", "South", 416);
  createHawkinsPropertyFile("Ewing", "London", "South", 287);
  
  createHawkinsRequestFile("Dracula", "London", "East", 500, 750, "This is a special one, recommanded by Robert Parton himself[Very old East London property, let's say over 500 years old", false);
  createHawkinsPropertyFile("Gladstone", "London", "East", 698);
  createHawkinsPropertyFile("Clifton", "London", "East", 149);
  createHawkinsPropertyFile("Jenkins", "London", "East", 410); 
}

function setLedgerReadText(String thisLedgerReadText)
{
  ledgerReadText = thisLedgerReadText;
}

String getLedgerReadText()
{
  return ledgerReadText;
}

String getCarfaxSeller()
{
  String returnString;
  if(carfaxSeller == null)
  {
    returnString = "";
  } else
  {
    returnString = carfaxSeller;
  }
  return returnString;
}

//##### SOLLICITOR EXAM ##########################################################################################
function addExamQuestion(String question, String actualAnswer)
{
  exam_ActualAnswers.Set(question, actualAnswer);
  exam_SubmittedAnswers.Set(question, "");
  
  if(exam_ActualAnswers.ItemCount == 1)
  {
    lblExam_question.Text = question;
  }
}

function createFullExam()
{
  addExamQuestion("When filing a property for sale in a client's file, should one use only the construction date, only the property's age or both?", "Both");
  addExamQuestion("Complete the following list, in order : Introduction, Current sale agreements, ?, Proof of current state, Annexes of previous paperwork", "Proof of ownership");
  addExamQuestion("As a sollicitor, which Inn of Courts are you associated with? A: Grey, B: Lincoln, C: Inner Temple, D: Middle Temple, E: All of them, F: None of them", "F");
  addExamQuestion("The population of Transylvania consists of four distinct nationalities. Which one are you most likely to encounter in the West of the Region?", "Magyars");
  addExamQuestion("Transylvania, Moldavia and Bukovina are located in the midst of which mountainous region?", "Carpathians");
  addExamQuestion("In Magyar folklore, which of these are devil-like creatures? A: Lid√©rc, B: √ñrd√∂g, C: T√°ltos, D: T√ºnd√©rek", "B");
}

bool areAllExamQuestionsAnswered()
{
  String answers[];
  answers = exam_SubmittedAnswers.GetValuesAsArray();
  int i;
  bool allIn = true;
  
  for(i = 0 ; i < exam_SubmittedAnswers.ItemCount ; i++)
  {
    if(answers[i] == "")
    {
      allIn = false;
    }
  }
  
  return allIn;
}

int howManyExamAnswers()
{
  return exam_ActualAnswers.ItemCount;
}

int howManyCorrectExamAnswers()
{
  String questions[];
  questions = exam_SubmittedAnswers.GetKeysAsArray();
  int i;
  int correct = 0;
  
  for(i = 0 ; i < exam_SubmittedAnswers.ItemCount ; i++)
  {
    if(exam_ActualAnswers.Get(questions[i]) == exam_SubmittedAnswers.Get(questions[i]))
    {
      correct++;
    }
  }
  
  return correct;
}

function modifyExamQuestion(bool nextORprev)
{
  String question = lblExam_question.Text;
  String allQuestions[];
  int i = 0;
  
  allQuestions = exam_ActualAnswers.GetKeysAsArray();
  exam_SubmittedAnswers.Set(question, tbExam_Answer.Text);
  
  while(question != allQuestions[i] && i < exam_ActualAnswers.ItemCount)
  {
    i++;
  }
  
  if(i < exam_ActualAnswers.ItemCount)
  {
    if(nextORprev)
    {
      tbExam_Answer.Text = exam_SubmittedAnswers.Get(allQuestions[i+1]);
      lblExam_question.Text = allQuestions[i+1];
    } else
    {
      tbExam_Answer.Text = exam_SubmittedAnswers.Get(allQuestions[i-1]);
      lblExam_question.Text = allQuestions[i-1];
    }
    if(i+1 == exam_ActualAnswers.ItemCount)
    {
      btnExam_next.Visible = false;
    } else
    {
      btnExam_next.Visible = false;
    }
    if(i == 0)
    {
      btnExam_prev.Visible = false;
    } else
    {
      btnExam_prev.Visible = false;
    }
  } else
  {
    debugDisplay("Error in nextExamQuestion");
  }
}

//##### TRAVEL DESTINATIONS ######################################################################################
String zoneAsString(zone thisZone) 
{
  switch(thisZone)
  {
    case JonathanApt:
      return "Jonathan's Apartment";
      break;
    case HawkinsOffices:
      return "Hawkins Esq. Office";
      break;
    case ExeterTrainStation:
      return "Exeter Train Station";
      break;
    case StationCafe:
      return "Station Caf√©";
      break;
    case LondonTrainStation:
      return "London Train Station";
      break;
    case LondonHotel:
      return "Hotel The Hummums";
      break;
    case Purfleet:
      return "Purfleet";
      break;
    case TelegramOffice:
      return "Telegram Office";
      break;
    case BritishMuseum:
      return "British Museum";
      break;
    case PhotographyShop:
      return "Photography shop";
      break;
    case LawSocietyOffices:
      return "Law Society Offices";
      break;
    case StayHere:
      return "Stay here";
      break;
    default:
      return "Null";
      break;
  }
}

zone stringAsZone(String thisZone) 
{
  switch(thisZone)
  {
    case "Jonathan's Apartment":
      return JonathanApt;
      break;
    case "Hawkins Esq. Office":
      return HawkinsOffices;
      break;
    case "Exeter Train Station":
      return ExeterTrainStation;
      break;
    case "Station Caf√©":
      return StationCafe;
      break;
    case "London Train Station":
      return LondonTrainStation;
      break;
    case "Hotel The Hummums":
      return LondonHotel;
      break;
    case "Purfleet":
      return Purfleet;
      break;
    case "Telegram Office":
      return TelegramOffice;
      break;
    case "British Museum":
      return BritishMuseum;
      break;
    case "Photography shop":
      return PhotographyShop;
      break;
    case "Law Society Offices":
      return LawSocietyOffices;
      break;
    case "Stay here":
      return StayHere;
      break;
    default:
      return StayHere;
      break;
  }
}

commerce stringAsCommerce(String thisCommerce)
{
  switch(thisCommerce)
  {
    case "HawkinsEsq":
      return HawkinsEsq;
      break;
    case "TrainStation":
      return TrainStation;
      break;
    case "LawSocietyBuilding":
      return LawSocietyBuilding;
      break;
    case "Museum":
      return Museum;
      break;
    case "Shop":
      return Shop;
      break;
    case "AlwaysOpened":
      return AlwaysOpened;
      break;
    default:
      debugDisplay(String.Format("Commerce not recognized"));
  }
}

String commerceAsString(commerce thisCommerce)
{
  switch(thisCommerce)
  {
    case HawkinsEsq:
      return "HawkinsEsq";
      break;
    case TrainStation:
      return "TrainStation";
      break;
    case LawSocietyBuilding:
      return "LawSocietyBuilding";
      break;
    case Museum:
      return "Museum";
      break;
    case Shop:
      return "Shop";
      break;
    case AlwaysOpened:
      return "AlwaysOpened";
      break;
    default:
      debugDisplay(String.Format("Commerce not recognized"));
  }
}

function setupTravelDestinations()
{
  String thisZone;
  
  thisZone = zoneAsString(JonathanApt);
  roomForEachTravelDestinations.Set(thisZone, "1");
  x_TravelDestinations.Set(thisZone, "6");
  y_TravelDestinations.Set(thisZone, "2");
  city_TravelDestinations.Set(thisZone, "Exeter");
  zone_CommerceType.Set(thisZone, commerceAsString(AlwaysOpened));
  
  thisZone = zoneAsString(HawkinsOffices);
  roomForEachTravelDestinations.Set(thisZone, "2");
  x_TravelDestinations.Set(thisZone, "3");
  y_TravelDestinations.Set(thisZone, "4");
  city_TravelDestinations.Set(thisZone, "Exeter");
  zone_CommerceType.Set(thisZone, commerceAsString(HawkinsEsq));
  
  thisZone = zoneAsString(ExeterTrainStation);
  roomForEachTravelDestinations.Set(thisZone, "3");
  x_TravelDestinations.Set(thisZone, "3");
  y_TravelDestinations.Set(thisZone, "1");
  city_TravelDestinations.Set(thisZone, "Exeter");
  zone_CommerceType.Set(thisZone, commerceAsString(TrainStation));
  
  thisZone = zoneAsString(StationCafe);
  roomForEachTravelDestinations.Set(thisZone, "3");
  x_TravelDestinations.Set(thisZone, "3");
  y_TravelDestinations.Set(thisZone, "1");
  city_TravelDestinations.Set(thisZone, "Exeter");
  zone_CommerceType.Set(thisZone, commerceAsString(TrainStation));
  
  thisZone = zoneAsString(LondonTrainStation);
  roomForEachTravelDestinations.Set(thisZone, "5");
  x_TravelDestinations.Set(thisZone, "6");
  y_TravelDestinations.Set(thisZone, "4");
  city_TravelDestinations.Set(thisZone, "London");
  cabSellMsg_TravelDestinations.Set(thisZone, "The Waterloo Train Station? State of the art transport wherever you wanna go!");
  zone_CommerceType.Set(thisZone, commerceAsString(TrainStation));
  
  thisZone = zoneAsString(LondonHotel);
  roomForEachTravelDestinations.Set(thisZone, "13");
  x_TravelDestinations.Set(thisZone, "6");
  y_TravelDestinations.Set(thisZone, "4");
  city_TravelDestinations.Set(thisZone, "London");
  cabSellMsg_TravelDestinations.Set(thisZone, "Ride to the Hummums in the Covent Garden? Get some shut eye and one of them baths for cheap!");
  zone_CommerceType.Set(thisZone, commerceAsString(AlwaysOpened));
  
  thisZone = zoneAsString(Purfleet);
  roomForEachTravelDestinations.Set(thisZone, "6");
  x_TravelDestinations.Set(thisZone, "11");
  y_TravelDestinations.Set(thisZone, "4");
  city_TravelDestinations.Set(thisZone, "London");
  cabSellMsg_TravelDestinations.Set(thisZone, "Purfleet? 'Tis a quaint little community to the East o'London");
  zone_CommerceType.Set(thisZone, commerceAsString(AlwaysOpened));
  
  thisZone = zoneAsString(TelegramOffice);
  roomForEachTravelDestinations.Set(thisZone, "8");
  x_TravelDestinations.Set(thisZone, "5");
  y_TravelDestinations.Set(thisZone, "3");
  city_TravelDestinations.Set(thisZone, "London");
  cabSellMsg_TravelDestinations.Set(thisZone, "My buddy James' telegram shop? He just clickety-clack that thing!");
  zone_CommerceType.Set(thisZone, commerceAsString(Shop));
  
  thisZone = zoneAsString(BritishMuseum);
  roomForEachTravelDestinations.Set(thisZone, "8");
  x_TravelDestinations.Set(thisZone, "5");
  y_TravelDestinations.Set(thisZone, "3");
  city_TravelDestinations.Set(thisZone, "London");
  cabSellMsg_TravelDestinations.Set(thisZone, "The British Museum? Lots of old neat stuff there");
  zone_CommerceType.Set(thisZone, commerceAsString(Museum));
  
  thisZone = zoneAsString(LawSocietyOffices);
  roomForEachTravelDestinations.Set(thisZone, "10");
  x_TravelDestinations.Set(thisZone, "6");
  y_TravelDestinations.Set(thisZone, "3");
  city_TravelDestinations.Set(thisZone, "London");
  cabSellMsg_TravelDestinations.Set(thisZone, "The Law Society office? You wearing a suit, people in suits like to go there");
  zone_CommerceType.Set(thisZone, commerceAsString(LawSocietyBuilding));
}

int travelDestinationTimeInMinutes(zone origin, zone destination)
{
  String tempString;
  if(destination == StayHere)
  {
    destination = origin;
  }
  
  tempString = x_TravelDestinations.Get(zoneAsString(origin));
  int x_origin = tempString.AsInt;
  
  tempString = y_TravelDestinations.Get(zoneAsString(origin));
  int y_origin = tempString.AsInt;
  
  tempString = x_TravelDestinations.Get(zoneAsString(destination));
  int x_dest = tempString.AsInt;
  
  tempString = y_TravelDestinations.Get(zoneAsString(destination));
  int y_dest = tempString.AsInt;
  
  float x_dist = IntToFloat(x_origin - x_dest);  
  float y_dist = IntToFloat(y_origin - y_dest);
  
  float dist = Maths.Sqrt(Maths.RaiseToPower(x_dist, 2.0) + Maths.RaiseToPower(y_dist, 2.0));
  
  bool inLondon;
  if(city_TravelDestinations.Get(zoneAsString(destination)) == "London")
  {
    inLondon = true;
  } else
  {
    inLondon = false;
  }
  
  if(inLondon)
  {
    return londonTravelDistanceMultiplier * FloatToInt(dist);
  } else
  {
    return exeterTravelDistanceMultiplier * FloatToInt(dist);
  }
}

function adjustTravelDestinations()
{
  String allDestination[];
  String currentCity = city_TravelDestinations.Get(zoneAsString(currentZone));
  
  allDestination = city_TravelDestinations.GetKeysAsArray();
  int i;
  
  for(i = 0 ; i < city_TravelDestinations.ItemCount ; i++)
  {
    if( city_TravelDestinations.Get(allDestination[i]) == currentCity &&
        availableDestinations.Contains(allDestination[i]) &&
        roomForEachTravelDestinations.Get(allDestination[i]) != String.Format("%d", player.Room))
    {
      dTravel.SetOptionState(stringAsZone(allDestination[i]), eOptionOn);
    } else
    {   
      dTravel.SetOptionState(stringAsZone(allDestination[i]), eOptionOff);
    }
  }
  dTravel.SetOptionState(StayHere, eOptionOn);
}

function addTravelDestination(zone thisZone)
{
  if(!availableDestinations.Contains(zoneAsString(thisZone)))
  {
    availableDestinations.Add(zoneAsString(thisZone));
  }
}

function removeTravelDestination(zone thisZone)
{
  if(availableDestinations.Contains(zoneAsString(thisZone)))
  {
    availableDestinations.Remove(zoneAsString(thisZone));
  }
}

bool playerHasTravelDestination(zone thisZone)
{
  return availableDestinations.Contains(zoneAsString(thisZone));
}

zone getCurrentZone()
{ 
  return currentZone;
}

String getCurrentCity()
{
  return city_TravelDestinations.Get(zoneAsString(currentZone));
}

function changeArrival_X_Y(int roomIndex, int newX, int newY)
{
  arrival_x[roomIndex] = newX;
  arrival_y[roomIndex] = newY;
}

function sayListOfThings(String listOfThings[], Dictionary* dictOfThings, int numberOfThings, Character* talker)
{
  int i;
  
  for(i = 0 ; i < numberOfThings ; i++)
  {
      
    if(listOfThings[i] == "" || listOfThings[i] == null || !dictOfThings.Contains(listOfThings[i]))
    {
      debugDisplay(String.Format("Error processing %s in the 'sayListOfThings' function", listOfThings[i]));
    } else
    {
      talker.Say(dictOfThings.Get(listOfThings[i]));
    }
  }
}

function cabTellPropositions() 
{
  sayListOfThings(cabbyPropositions, cabSellMsg_TravelDestinations, 3, cCabby);
}

String getCabPropositionByIndex(int index)
{
  return cabbyPropositions[index];
}

function setThreeLondonCabRides(bool includePurfleet)
{
  String allPossibleDestination[];
  Set* proposedDestinations = Set.Create(eNonSorted);
  allPossibleDestination = city_TravelDestinations.GetKeysAsArray();
  int maxIndex = city_TravelDestinations.ItemCount - 1;
  int randomIndex;
  int numberOfRandomPropositions;
  if(includePurfleet)
  {
    numberOfRandomPropositions = 2;
  } else
  {
    numberOfRandomPropositions = 3;
  }
  
  while (proposedDestinations.ItemCount < numberOfRandomPropositions)
  {
    randomIndex = Random(maxIndex);
    if(city_TravelDestinations.Get(allPossibleDestination[randomIndex]) == "London" &&  // In London
       allPossibleDestination[randomIndex] != zoneAsString(currentZone) &&              // not current zone
       allPossibleDestination[randomIndex] != zoneAsString(Purfleet))                   // Not Purfleet,  see below
    {
      if(proposedDestinations.ItemCount > 0)
      {
        if(!proposedDestinations.Contains(allPossibleDestination[randomIndex]))           // Not already chosen
        {
          proposedDestinations.Add(allPossibleDestination[randomIndex]);
        }
      } else
      {
        proposedDestinations.Add(allPossibleDestination[randomIndex]);
      }
    }
  }
  
  if(includePurfleet)
  {
    proposedDestinations.Add(zoneAsString(Purfleet));
  }
  
  cabbyPropositions = proposedDestinations.GetItemsAsArray();
}



//##### NOTEBOOK ###################################################################################################################
String getNoteDescription(String key) // returns the description associated with the title for taken notes
{
  return notes.Get(key);
}

function takeNote() // adds a note in the notepad
{
  notes.Set(Notable_title, Notable_description);
  lbNoteTitles.AddItem(Notable_title);
  giveScoreOnce(Notable_description, Notable_score);
}

function makeNotable(String title, String description, int score) // overrides the last notable thing
{
  Notable_title = title;
  Notable_description = description;
  Notable_score = score;
}

function notableRead(String title, String description,  int score) // Displays something and make it notable (establish the added score if noted too)
{
  if(player.HasInventory(iNotebook))
  {
    makeNotable(title,  description,  score);
    Display(String.Format("%s*", description));
  } else {
    Display(description);
  }
}

function notableThought(String title, String description,  int score) // both make the player think something and make it notable (establish the added score if noted too)
{
  if(player.HasInventory(iNotebook))
  {
    makeNotable(title,  description,  score);
    player.Think(String.Format("%s*", description));
  } else {
    player.Think(description);
  }
}

function notableWhisper(Character* who, String title, String description,  int score) // both make a character say something and make it notable (establish the added score if noted too)
{
  if(player.HasInventory(iNotebook))
  {
    makeNotable(title,  description,  score);
    who.Say(String.Format("*whispering*[%s*", description));
  } else {
    who.Say(String.Format("*whispering*[%s", description));
  }
}

function notableSay(Character* who, String title, String description,  int score) // both make a character say something and make it notable (establish the added score if noted too)
{
  if(player.HasInventory(iNotebook))
  {
    makeNotable(title,  description,  score);
    who.Say(String.Format("%s*", description));
  } else {
    who.Say(description);
  }
}

function closeNotebookThoughts()
{
  String thoughts[];
  int i;
  if(afterNotebookThoughts.ItemCount > 0)
  {
    thoughts = afterNotebookThoughts.GetItemsAsArray();
    for(i = 0 ; i < afterNotebookThoughts.ItemCount ; i++)
    {
      player.Think(thoughts[i]);
    }
    afterNotebookThoughts.Clear();
  }
}

function hasRead(String noteTitle)
{
  switch(noteTitle)
  {
    case "Mina - tea":
      if(Game.DoOnceOnly("Mina's tea")){
        GiveScore(1);
        if(isItBeforeThisTime(11, 0, 0, false, 1)){
          afterNotebookThoughts.Add("Mina and I have a tea rendezvous at 11 at the Station Caf√©");
        } else
        {
          afterNotebookThoughts.Add("Oh no! I missed my tea rendezvous with Mina!");
        }
        addTravelDestination(StationCafe);
      }
      break;
    default:
      break;
  }
}

//##### INTERACTION FUNCTIONS #####

function sit(elementType eT, int index, Character* who, int sittingView, bool alreadySat) // make the character sit on an appropriately setup element
{
  String redir;
  
  switch(eT)
  {
    case roomObjects:
      if(who == player) {
        redir = object[index].GetTextProperty("sit_Direction");
        if(redir.StartsWith("redir", eCaseInsensitive))
        {
          redir = redir.Replace("redir", "", eCaseInsensitive);
          index = redir.AsInt;
        }
      }
      if(object[index].GetTextProperty("sit_Direction") == "Null")
      {
        who.Think("I cannot sit on this.");        
      } else if(!isCharacterNearObject(object[index], reachDistance, who))
      {
        who.Think(String.Format("I cannot reach the %s from here", object[index].Name.LowerCase()));
      } else
      {
        who.Walk(object[index].X + object[index].GetProperty("sit_deltaX"), object[index].Y + object[index].GetProperty("sit_deltaY"), eBlock, eWalkableAreas);
        who.Move(object[index].X + object[index].GetProperty("sit_deltaX"), object[index].Y + object[index].GetProperty("sit_deltaY"), eBlock, eAnywhere);
        who.LockView(sittingView, eStopMoving);
        if(who == player) {
          cHarkersBeard.LockView(6, eKeepMoving);
        }
        who.SetProperty("sitting", index);
        
        if(!alreadySat)
        {
          switch(object[index].GetTextProperty("sit_Direction"))
          {
            case "down":
              who.Animate(0, 6, eOnce, eNoBlock, eForwards);
              break;
            case "left":
              who.Animate(1, 6, eOnce, eNoBlock, eForwards);
              break;
            case "right":
              who.Animate(2, 6, eOnce, eNoBlock, eForwards);
              break;
            case "up":
              who.Animate(3, 6, eOnce, eNoBlock, eForwards);
              break;
            default:
              break;
          }
          if(who == player)
          {
            switch(object[index].GetTextProperty("sit_Direction"))
            {
              case "down":
                cHarkersBeard.Animate(0, 6, eOnce, eBlock, eForwards);
                break;
              case "left":
                cHarkersBeard.Animate(1, 6, eOnce, eBlock, eForwards);
                break;
              case "right":
                cHarkersBeard.Animate(2, 6, eOnce, eBlock, eForwards);
                break;
              case "down":
                cHarkersBeard.Animate(3, 6, eOnce, eBlock, eForwards);
                break;
              default:
                break;
            }
          }
        } else {
          who.Frame = nbFrameInSittingAnim;
        }
        if(who == player)
        {
          mouse.Mode = eModePointer;
          KeyboardMovement.Mode = eKeyboardMovementModeNone;
        }
      }
      break;
    default:
      break;
  }
}

function playerSitsInClosestChair()
{
  int nbObjectsInRoom = Room.ObjectCount;
  Dictionary* sittableObjects = Dictionary.Create(eNonSorted);
  String sitDirection;
  String redirNb;
  
  //Dictionary* distances = Dictionary.Create(eNonSorted);
  int distance;
  int i;
  
  int closestIndex = -1;
  int closestDistance = 500;
  
  
  for(i = 0 ; i < Room.ObjectCount ; i++)
  {
    sitDirection = object[i].GetTextProperty("sit_Direction");
    if(sitDirection.StartsWith("Redir"))
    {
      redirNb = sitDirection.Replace("redir", "", eCaseInsensitive);
    } else
    {
      redirNb = String.Format("%d", i);
    }
    if(sitDirection != "Null")
    {
      sittableObjects.Set(String.Format("%09d", i), redirNb);
      distance = FloatToInt(calculateDistanceFromCharacter(object[i].X, object[i].Y, player));
      //distances.Set(String.Format("%09f", i), distance);
      if(distance < closestDistance)
      {
        closestDistance = distance;
        closestIndex = i;
      }
    }
  }
  
  if(closestIndex == -1)
  {
    player.FaceDirection(eDirectionRight);
    Wait(15);
    player.FaceDirection(eDirectionLeft);
    Wait(15);
    player.FaceDirection(eDirectionDown);
    player.Say("I don't see anywhere to sit nearby");
  } else if(!isCharacterNearObject(object[closestIndex], 40.0, player))
  {
    player.FaceObject(object[closestIndex], eBlock);
    player.Say(String.Format("I am too far away from the %", object[closestIndex].Name));
  } else
  {
    redirNb = sittableObjects.Get(String.Format("%09d", closestIndex));
    i = redirNb.AsInt;
    sit(roomObjects, i, player, 2, false);
  }
}

function standUp(Character* who,  int walkingView) // the player stands up
{
  if(who.GetProperty("sitting") > -1)
  {
    who.Animate(player.Loop, 6, eOnce, eNoBlock,  eBackwards);
    if(who == player)
    {
      cHarkersBeard.Animate(player.Loop, 6, eOnce, eBlock, eBackwards);
    }
    who.LockView(walkingView, eKeepMoving);
    if(who == player)
    {
      cHarkersBeard.LockView(5, eKeepMoving);
    }
    who.PlaceOnWalkableArea();
    who.SetProperty("sitting", -1);
    if(who == player)
    {
      mouse.Mode = eModeWalkto;
      KeyboardMovement.Mode = eKeyboardMovementModeTapping;
    }
  } else {
    who.Think("I am not sitting");
  }
}

//##### PARSE COMMAND REACTIONS FUNCTIONS #####
bool sitHighjack()
{
  bool returnBool = false;
  if(useIndex != -1)
  {
      
    switch (useET)
    {
      case roomObjects:
        if(object[useIndex].GetTextProperty("sit_Direction") != "Null")
        {
          returnBool = true;
          sit(roomObjects, useIndex, player, 2, false);
          useIndex = -1;
        }
        break;
      case roomHotspots:
        if(hotspot[useIndex].GetTextProperty("sit_Direction") != "Null")
        {
          returnBool = true;
          sit(roomHotspots, useIndex, player, 2, false);
          useIndex = -1;
        }
        break;
      default:
        break;
    }
  }
  return returnBool;
}

function unhandled_event(int what, int type) // called when a runInteraction is called on something without an appropriate event handler
{
  switch(what)
  {
    case 2: // room object
      switch(type)
      {
        case 1: // use/interact with object
          if(!sitHighjack())
          {
            player.Think("I am not sure what to use this for");
          }
          break;
        case 3: // use inventory item on object
          break;
        default:
          break;
      }
      break;
    case 1: // hotspot
      switch(type)
      {
        case 2: // use/interact with hotspot
          if(!sitHighjack())
          {
            player.Think("I am not sure what to use this for");
          }
          break;
        case 3: // use inventory item on hotspot
          break;
        default:
          break;
      }
      break;
    case 3: // character
      switch(type)
      {
        case 1: // use/interact character
          player.Think("I am not sure what to use them for");
          break;
        case 3: // use inventory item on character
          break;
        default:
          break;
      }
      break;
    case 5: // inventory item
      switch(type)
      {
        case 1: // use/interact with inventory item
          player.Think("I am not sure what to use this for");
          break;
        case 3: // use inventory item on inventory item
          break;
        default:
          break;
      }
      break;
    case 4: // nothing
      switch(type)
      {
        case 2: // use/interact with nothing
          player.Think("I am not sure what to use");
          break;
        case 3: // use inventory item on nothing
          break;
        default:
          break;
      }
      break;
    default:
      break;
  }
}

int findRoomObjectIndexByName(String objectName) // returns the object index of an object named
{
  int i = Room.ObjectCount - 1;
  int foundMatch = -1;
  
  while(i >= 0 && foundMatch == -1)
  {
    if(object[i].Name.LowerCase() == objectName.LowerCase())
    {
      foundMatch = i;
    } else {
      i--;
    }
  }
  
  return foundMatch;
}

int findInvItemIndexByName(String itemName)
{
  int nbInventoryItems = Game.InventoryItemCount;//don't forget the index start at one
  int i = 0;
  int returnIndex = -1;
  bool foundit = false;
  while(i < nbInventoryItems && !foundit)
  {
    i++;
    if(inventory[i].Name == itemName) {
      returnIndex = i;
      foundit = true;
    }
  }
  return returnIndex;
}

String[] findElementIndexByName(String cmd) // returns a String array with array[0] being the index and array[1] being the element type,  both as Strings!!!
{
  int i;
  int y;
  String testedStrings[];
  String allPossibleNames;
  String finalIndex;
  String finalElementType;
  bool foundMatch;
  float distanceFromPlayer;
  String tempArray[];
  float tempArrayF[];
  String returnArray[] = new String[2];
  
  int nbObjects = Room.ObjectCount;
  int nbHotpots = 50;
  int nbCharacters = Game.CharacterCount;
  int nbInventoryItems = Game.InventoryItemCount;//don't forget the index start at one
  Dictionary* correspondingRoomElements = Dictionary.Create(eSorted, eCaseInsensitive);
  
  //OBJECTS
  for(i = 0; i < (nbObjects); i++)
  {
    allPossibleNames = object[i].Name.Append(", ");
    if(object[i].GetTextProperty("alternateNames") != "")
    {
      allPossibleNames = allPossibleNames.Append(object[i].GetTextProperty("alternateNames"));
      allPossibleNames = allPossibleNames.Append(", ");
    }
    //debugDisplay(allPossibleNames);
    testedStrings = split(allPossibleNames, ", ");
    int testedStringsLength = testedStrings[0].AsInt;
    y = 1;
    foundMatch = false;
    while(y < testedStringsLength && !foundMatch)
    {
      if(object[i].Name != "" && testedStrings[y] != "" && cmd.IndexOf(testedStrings[y]) != -1)
      {
        if(object[i].Visible || object[i].GetProperty("InteractableWhenInvisible"))
        {
          foundMatch = true;
          distanceFromPlayer = calculateDistanceFromCharacter(getObjectMidX(object[i]), object[i].Y, player);
          correspondingRoomElements.Set(String.Format("%d_%s", i, etToString(roomObjects)), String.Format("%d", FloatToInt(distanceFromPlayer)));
        } else {
          y++;
        }
      } else {
        y++;
      }
    }
  }
  
  //HOTSPOTS
  for(i = 0; i < (nbHotpots); i++)
  {
    allPossibleNames = hotspot[i].Name.Append(", ");
    allPossibleNames = allPossibleNames.Append(hotspot[i].GetTextProperty("alternateNames"));
    testedStrings = split(allPossibleNames, ", ");
    int testedStringsLength = testedStrings[0].AsInt;
    y = 1;
    foundMatch = false;
    while(y < testedStringsLength && !foundMatch)
    {
      if(hotspot[i].Name != "" && cmd.IndexOf(testedStrings[y]) != -1)
      {
        foundMatch = true;
        distanceFromPlayer = calculateDistanceFromCharacter(hotspot[i].WalkToX, hotspot[i].WalkToY, player);
        correspondingRoomElements.Set(String.Format("%d_%s", i, etToString(roomHotspots)), String.Format("%d", FloatToInt(distanceFromPlayer)));
      } else {
        y++;
      }
    }
  }
  
  //CHARACTERS
  for(i = 0; i < (nbCharacters); i++)
  {
    allPossibleNames = character[i].Name.Append(", ");
    allPossibleNames = allPossibleNames.Append(character[i].GetTextProperty("alternateNames"));
    testedStrings = split(allPossibleNames, ", ");
    int testedStringsLength = testedStrings[0].AsInt;
    y = 1;
    foundMatch = false;
    while(y < testedStringsLength && !foundMatch)
    {
      if(character[i].Room == player.Room && character[i].Transparency < 100 && character[i].Name != "" && cmd.IndexOf(testedStrings[y]) != -1)
      {
        foundMatch = true;
        distanceFromPlayer = calculateDistanceFromCharacter(character[i].x, character[i].y,  player);
        correspondingRoomElements.Set(String.Format("%d_%s", i, etToString(allCharacters)), String.Format("%d", FloatToInt(distanceFromPlayer)));
      } else {
        y++;
      }
    }
  }
  
  //INVENTORY ITEMS
  for(i = 1; i <= (nbInventoryItems); i++)//inventory item index start at 1
  {
    allPossibleNames = inventory[i].Name.Append(", ");
    allPossibleNames = allPossibleNames.Append(inventory[i].GetTextProperty("alternateNames"));
    testedStrings = split(allPossibleNames, ", ");
    int testedStringsLength = testedStrings[0].AsInt;
    y = 1;
    foundMatch = false;
    
    while(y < testedStringsLength && !foundMatch)
    {
      if(player.HasInventory(inventory[i]) && inventory[i].Name != "" && cmd.IndexOf(testedStrings[y]) != -1)
      {
        foundMatch = true;
        if(cmd.IndexOf(" my ") != -1)
        {
          distanceFromPlayer = 0.0;
        } else {
          distanceFromPlayer = 400.0;
        }
        correspondingRoomElements.Set(String.Format("%d_%s", i, etToString(allInventoryItems)), String.Format("%d", FloatToInt(distanceFromPlayer)));
      } else {
        y++;
      }
    }
  }
    
  switch(correspondingRoomElements.ItemCount)
  {
    case 0:
      returnArray[0] = "-1";
      returnArray[1] = "Null";
      break;
    case 1:
      tempArray = correspondingRoomElements.GetKeysAsArray();
      finalIndex = tempArray[0].Truncate(tempArray[0].IndexOf("_"));
      finalElementType = tempArray[0].Replace(finalIndex, "", eCaseInsensitive);
      finalElementType = finalElementType.Replace("_", "", eCaseInsensitive);
      returnArray[0] = finalIndex;
      returnArray[1] = finalElementType;
      break;
    default:
      tempArray = correspondingRoomElements.GetValuesAsArray();
      tempArrayF = new float[correspondingRoomElements.ItemCount];
      for(i = 0; i < correspondingRoomElements.ItemCount; i++)
      {
        tempArrayF[i] = tempArray[i].AsFloat;
      }
      tempArray = correspondingRoomElements.GetKeysAsArray();
      returnArray = findClosestElement(tempArray, tempArrayF, correspondingRoomElements.ItemCount);
      break;
  }  
  
  return returnArray;
}

String findVerbInDictionary(String cmd) // finds the verb in the verbDictionary
{
  int i;
  int stringPosition = -1;
  String verbs[] = verbDictionary.GetKeysAsArray();
  Set* foundVerbs = Set.Create(eSorted);
  String returnVerb;
   
  for(i = 0 ; i < verbDictionary.ItemCount ; i++){
    stringPosition = cmd.IndexOf(String.Format("%s ", verbs[i]));
    if(stringPosition != -1) {
      foundVerbs.Add(verbs[i]);
    }
  }
  
  if(foundVerbs.ItemCount == 0) 
  {
    return "Null";
  } else 
  {
    verbs = foundVerbs.GetItemsAsArray();
    returnVerb = verbs[0];
    for(i = 1 ; i < foundVerbs.ItemCount ; i++)
    {
      if(verbs[i].Length > returnVerb.Length)
      {
        returnVerb = verbs[i];
      }
    }
    return verbDictionary.Get(returnVerb);
  }
}

// this function allows 2 inventory items to be merged together (keeps one,  modifies its parameters and removes the other)
function fitInventoryItemsTogether(InventoryItem* keptItem, InventoryItem* fittedItem, String newKeptItemName, int newItemGraphic, bool ReplaceDesc_orAppend, String newItemDescription, int AddedScore)
{
  String oldDescription = keptItem.GetTextProperty("TextDescription");
  String oldName = keptItem.Name;
  
  keptItem.Name = newKeptItemName;
  if(ReplaceDesc_orAppend)
  {
    keptItem.SetTextProperty("TextDescription", newItemDescription);
  } else {
    keptItem.SetTextProperty("TextDescription", oldDescription.Append(String.Format(" %s", newItemDescription)));
  }
  keptItem.Graphic = newItemGraphic;
  player.LoseInventory(fittedItem);
  if(AddedScore > 0)
  {
    giveScoreOnce(String.Format("Fit %s in %s", fittedItem.Name, oldName), AddedScore);
  }
}

//##### ITEMS IN ITEMS #####
Set* getClassifySolutionSet(String parentItemName)
{
  InventoryItem* parentItem = inventory[findInvItemIndexByName(parentItemName)];
  
  switch(parentItem)
  {
    case iLegalPapers:
      return legalPapers_solution;
      break;
    case iSalesDossier:
      return saleDossier_solution;
      break;
    default:
      debugDisplay(String.Format("%s is not handled by getClassifySolutionSet function", parentItemName));
      break;
  }
}

Dictionary* getDictionariesForParentItems(InventoryItem* parentItem, parentItemDict aspect)
{
  switch (parentItem)
  {
    case iLegalPapers:
      if(aspect == subitemDescription)
      {
        return legalPapers_description;
      } else if(aspect == subitemNote)
      {
        return legalPapers_notes;
      } else
      {
        debugDisplay("Unhandled aspect of legal papers from getDictionariesForParentItems");
      }
      break;
    case iFilm:
      if(aspect == subitemDescription)
      {
        return film_description;
      } else if(aspect == subitemNote)
      {
        return film_notes;
      } else
      {
        debugDisplay("Unhandled aspect of film from getDictionariesForParentItems");
      }
      break;
    case iPhotos:
      if(aspect == subitemDescription)
      {
        return photo_description;
      } else if(aspect == subitemNote)
      {
        return photo_notes;
      } else
      {
        debugDisplay("Unhandled aspect of photos from getDictionariesForParentItems");
      }
      break;
    case iSalesDossier:
      if(aspect == subitemDescription)
      {
        return saleDossier_description;
      } else if(aspect == subitemNote)
      {
        return saleDossier_notes;
      } else
      {
        debugDisplay("Unhandled aspect of saleDossier from getDictionariesForParentItems");
      }
      break;
    case iHotelPackages:
      if(aspect == subitemDescription)
      {
        return hotelPackages_description;
      } else if(aspect == subitemNote)
      {
        return hotelPackages_notes;
      } else
      {
        debugDisplay("Unhandled aspect of hotel packages from getDictionariesForParentItems");
      }
      break;
    case iTelegrams:
      if(aspect == subitemDescription)
      {
        return telegram_description;
      } else if(aspect == subitemNote)
      {
        return telegram_notes;
      } else
      {
        debugDisplay("Unhandled aspect of telegram from getDictionariesForParentItems");
      }
      break;        
    case iFood:
      if(aspect == subitemDescription)
      {
        return food_description;
      } else if(aspect == subitemNote)
      {
        return food_notes;
      } else if(aspect == subItemSpoiltime)
      {
        return food_spoilTime;
      } else if(aspect == subItemAlternateName)
      {
        return food_alternateNames;
      } else
      {
        debugDisplay("Unhandled aspect of food from getDictionariesForParentItems");
      }
      break;
    case iBooks:
      if(aspect == subitemDescription)
      {
        return books_description;
      } else if(aspect == subitemNote)
      {
        return books_notes;
      } else
      {
        debugDisplay("Unhandled aspect of books from getDictionariesForParentItems");
      }
      break;
    case iBooksArchives:
      if(aspect == subitemDescription)
      {
        return britishMuseumBooks_comment;
      } else if(aspect == subitemNote)
      {
        return britishMuseumBooks_notes;
      } else
      {
        debugDisplay("Unhandled aspect of british museum books from getDictionariesForParentItems");
      }
      break;  
    default:
      debugDisplay(String.Format("%d is not handled by the getDictionariesForParentItems function", parentItem.Name));
      break;
  }
  
}

bool playerHasSubitem(String subItemName, InventoryItem* parentItem)
{
  Dictionary* thisParentItemDict = getDictionariesForParentItems(parentItem, subitemDescription);
  return thisParentItemDict.Contains(subItemName);
}

bool playerHasAnySubitem(InventoryItem* thisParentItem)
{
  Dictionary* ketSet = getDictionariesForParentItems(thisParentItem, subitemDescription);
  return (ketSet.ItemCount > 0);
}

function changeSubItemNote(InventoryItem* thisParentItem, String thisSubItemName, String newNote)
{
  Dictionary* thisParentItemDict = getDictionariesForParentItems(thisParentItem, subitemNote);
  
  if(playerHasSubitem(thisSubItemName, thisParentItem))
  {
    thisParentItemDict.Set(thisSubItemName, newNote);
  }
}

function changeAllSubItemNoteInParent(InventoryItem* thisParentItem, String newNote)
{
  Dictionary* thisParentItemDict = getDictionariesForParentItems(thisParentItem, subitemNote);
  String subItemNames[];
  subItemNames = thisParentItemDict.GetKeysAsArray();
  int i;
  
  for(i = 0 ; i < thisParentItemDict.ItemCount ; i++)
  {
    changeSubItemNote(thisParentItem, subItemNames[i], newNote);
  }
}

function removeSubitem(InventoryItem* parentItem, String thisSubitemName,  bool showWarningOnError)
{
  Dictionary* mySubitemDescription = getDictionariesForParentItems(parentItem, subitemDescription);
  Dictionary* mySubitemNote = getDictionariesForParentItems(parentItem, subitemNote);
  
  if(mySubitemDescription.Contains(thisSubitemName) && mySubitemNote.Contains(thisSubitemName))
  {
    mySubitemDescription.Remove(thisSubitemName);
    mySubitemNote.Remove(thisSubitemName);
  } else if (showWarningOnError)
  {
    debugDisplay(String.Format("%s is not a subitem of %s", thisSubitemName, parentItem.Name));
  }    
}

function addSubitem(InventoryItem* parentItem, String thisSubitemName, String thisSubitemDescription, String thisSubitemNote)
{
  Dictionary* mySubitemDescription;
  Dictionary* mySubitemNote;
   
  if(parentItem.GetTextProperty("InvContext") == "Classify" || parentItem.GetTextProperty("InvContext") == "Contains")
  {
    mySubitemDescription = getDictionariesForParentItems(parentItem, subitemDescription);
    mySubitemDescription.Set(thisSubitemName, thisSubitemDescription);
    mySubitemNote = getDictionariesForParentItems(parentItem, subitemNote);
    mySubitemNote.Set(thisSubitemName, thisSubitemNote);
    if(!player.HasInventory(parentItem))
    {
      player.AddInventory(parentItem);
    }
  } else
  {
    debugDisplay(String.Format("%d does not have an appropriate invContext parameter", parentItem.Name));
  }  
}

function transfertSubitemFromOneParentToAnother(InventoryItem* originalParentItem, InventoryItem* targetParentItem, String subItemName,  bool showWarningOnError)
{
  Dictionary* mySubitemDescription_origin = getDictionariesForParentItems(originalParentItem, subitemDescription);
  Dictionary* mySubitemNote_origin = getDictionariesForParentItems(originalParentItem, subitemNote);
  Dictionary* mySubitemDescription_target = getDictionariesForParentItems(targetParentItem, subitemDescription);
  Dictionary* mySubitemNote_target = getDictionariesForParentItems(targetParentItem, subitemNote);
  
  if(mySubitemDescription_origin.Contains(subItemName) && mySubitemNote_origin.Contains(subItemName))
  {
    addSubitem(targetParentItem, subItemName, mySubitemDescription_origin.Get(subItemName), mySubitemNote_origin.Get(subItemName));
    removeSubitem(originalParentItem, subItemName, showWarningOnError);
  } else
  {
    if(showWarningOnError)
    {
      debugDisplay(String.Format("%s is not a subitem of %s", subItemName, originalParentItem.Name));
    }
  }
}

function tranfertAllSubitemFromOneParentToAnother(InventoryItem* originalParentItem, InventoryItem* targetParentItem)
{
  Dictionary* mySubitemDescription_origin = getDictionariesForParentItems(originalParentItem, subitemDescription);
  Dictionary* mySubitemNote_origin = getDictionariesForParentItems(originalParentItem, subitemNote);
  Dictionary* mySubitemDescription_target = getDictionariesForParentItems(targetParentItem, subitemDescription);
  Dictionary* mySubitemNote_target = getDictionariesForParentItems(targetParentItem, subitemNote);
  String subitemNames[];
  int originalLength = mySubitemDescription_origin.ItemCount;
  subitemNames = mySubitemDescription_origin.GetKeysAsArray();
  int i;
  for(i = 0 ; i < originalLength ; i++)
  {
    transfertSubitemFromOneParentToAnother(originalParentItem, targetParentItem, subitemNames[i], true);
  }
}

function lbInventory_Selector_adapt(String itemName){
  int i = Game.InventoryItemCount;
  String allContexts = "Classify, Contains";
  bool foundMatch = false;
  
  while(i > 0 && !foundMatch) 
  {
    if(inventory[i].Name == itemName)
    {
      //imgSelectedInv.NormalGraphic = inventory[i].Graphic;
      if(inventory[i].GetProperty("tellsTime"))
      {
        lblDescriptionSelectedItem.Text = String.Format("%s[It is %s, currently.", inventory[i].GetTextProperty("TextDescription"), whatTimeIsIt(true));
      } else {
        lblDescriptionSelectedItem.Text = String.Format("%s", inventory[i].GetTextProperty("TextDescription"));
      }
      
      if(inventory[i].GetTextProperty("invContext") == "Null")
      {
        btnInvContext.Visible = false;
      } else if (allContexts.IndexOf(inventory[i].GetTextProperty("invContext")) != -1)
      {
        btnInvContext.Text = String.Format("> %s", inventory[i].GetTextProperty("invContext"));
        btnInvContext.Visible = true;
      }
      foundMatch = true;
    } else {
      i--;
    }
  }
}

function fillInventoryListBox ()
{
  int i;
  bool firstItem = false;
  String itemDescription;
  lbInventory.Clear();
  
  for(i = Game.InventoryItemCount ; i > 0 ; i--) 
  {
    if(player.HasInventory(inventory[i]))
    {
      lbInventory.AddItem(inventory[i].Name);
      if(firstItem == false) {
        lbInventory_Selector_adapt(inventory[i].Name);
        firstItem = true;
      }
    }
  }
}

int findListBoxIndexbyName(ListBox* thisLB, String itemLookedFor)
{
  int selectedIndex = 0;
  int i = 0;
  bool foundit = false;
  while (i < thisLB.ItemCount && !foundit)
  {
    if(thisLB.Items[i] == itemLookedFor)
    {
      selectedIndex = i;
      foundit = true;
    }
    i++;
  }
  return selectedIndex;
}

function show_inventory_window()
{
  fillInventoryListBox();
  playConfirm();
  open_gui(gInventory);
}

function ValidateFileIt (ListBox* classifiedProposition, Set* classifiedSolution, InventoryItem* thisItem, int classifiedSpriteNumber,  String classifiedItemName, int addScoreAmount)
{
  bool allGood = true;
  int i = 0;
  String orderedSolution[];
  String tempString;
  orderedSolution = classifiedSolution.GetItemsAsArray();
  
  close_gui(gClassify);
  if(classifiedSolution.ItemCount != classifiedProposition.ItemCount)
  {
    player.Think("Hmm. . . That's not right");
    player.Think("Something is missing");
  } else
  {
    while(i < classifiedSolution.ItemCount && allGood)
    {
      if(orderedSolution[i] != classifiedProposition.Items[i]) {
        allGood = false;
      }
      i++;
    }
    
    if(allGood)
    {
      player.Say("Hurray! Perfectly organized");
      thisItem.Graphic = classifiedSpriteNumber;
      giveScoreOnce(thisItem.Name, addScoreAmount);
      thisItem.Name = classifiedItemName;
      tempString = thisItem.GetTextProperty("TextDescription");
      tempString = tempString.Append("[This item is not signed");
      thisItem.SetTextProperty("TextDescription", tempString);
      thisItem.SetTextProperty("invContext", "Null");
      fillInventoryListBox();
      lbInventory.SelectedIndex = findListBoxIndexbyName(lbInventory, thisItem.Name);
      lblDescriptionSelectedItem.Text = inventory[findInvItemIndexByName(lbInventory.Items[lbInventory.SelectedIndex])].GetTextProperty("TextDescription");
    } else {
      player.Think("Hmm. . . That's not right");
    }
  }
  open_gui(gInventory);  
}

Set* breakWrittenContentByPage(String fullMessage, String pageBreakSymbol)
{
    Set* returnSet = Set.Create(eSorted);
    String currentPage;
    int currentPageNumber = 1;
    
    while(fullMessage.IndexOf(pageBreakSymbol) != -1)
    {
      currentPage = fullMessage.Truncate(fullMessage.IndexOf(pageBreakSymbol));
      currentPage = currentPage.Replace(pageBreakSymbol, "", eCaseInsensitive);
      fullMessage = removeOneStringInstance(fullMessage, currentPage.Append(pageBreakSymbol));
      currentPage = String.Format("PAGE %d[%s", currentPageNumber, currentPage);
      returnSet.Add(currentPage);
      
      currentPageNumber++;
    }
    fullMessage = String.Format("PAGE %d[%s", currentPageNumber, fullMessage);
    returnSet.Add(fullMessage);
    
    return returnSet;
}

function readThis(String fullMessage, String pageSeparator)
{
  Set* readContent = breakWrittenContentByPage(fullMessage, pageSeparator);
  String readContentToDisplay[] = readContent.GetItemsAsArray();
  int i;
  for(i = 0 ; i < readContent.ItemCount ; i++)
  {
    Display(readContentToDisplay[i]);
  }
}

//##### TELEGRAMS AND PACKAGES #####
function addHotelPackage(String packageName, String description, String note)
{
  addSubitem(iHotelPackages, packageName, description, note);
  if(player.HasInventory(iHotelPackages))
  {
    player.LoseInventory(iHotelPackages);
  }
}

function getHotelPackages()
{
  if(playerHasAnySubitem(iHotelPackages))
  {
    Display("The hotel clerk gives Jonathan a received package");
    tranfertAllSubitemFromOneParentToAnother(iHotelPackages, iTelegrams);
    if(player.HasInventory(iHotelPackages))
    {
      player.LoseInventory(iHotelPackages);
    }
    if(!player.HasInventory(iTelegrams))
    {
      player.AddInventory(iTelegrams);
    }
    giveScoreOnce("Hotel packages", 1);
  }
}

function setTelegramInclusionByIndex(String name, int msgPartIndex, bool include)
{
  telegramRecipient_messageParts_include.Set(String.Format("%s_%d", name, msgPartIndex), String.Format("%d", include));
}

function createTelegram(String name, String alternateNames, String fullNameAndCity,  String signOff, int msgPartIndex, String msgPart, bool includeByDefault, String answerPart)
{
  if(!telegramRecipient_alternateNames.Contains(name))
  {
    telegramRecipient_alternateNames.Set(name, alternateNames);
    telegramRecipient_recipientDescription.Set(name, fullNameAndCity);
    telegramRecipient_signOff.Set(name, signOff);
  }
  telegramRecipient_messageParts.Set(String.Format("%s_%d", name, msgPartIndex), msgPart);
  telegramRecipient_messageParts_include.Set(String.Format("%s_%d", name, msgPartIndex), String.Format("%d", includeByDefault));
  
  telegramAnswer_messageParts.Set(String.Format("%s_%d", name, msgPartIndex), answerPart);
  telegramAnswer_messageParts_include.Set(String.Format("%s_%d", name, msgPartIndex), String.Format("%d", includeByDefault));
}

function createAllTelegram()
{
  String nameKey;
  String altNames;
  String desc;
  String signOff;
  
  //Mina's telegrams
  nameKey = "Mina";
  altNames = "Mina, Murray, Wilhelmina, fiancee, bethroted";
  desc = "Wilhelmina Murray, in Exeter";
  signOff = "Love";
  createTelegram(nameKey, altNames, desc, signOff, 1, "In London STOP", true, "Have a good time in London STOP"); //base
  createTelegram(nameKey, altNames, desc, signOff, 2, "Back in Exeter tomorrow STOP[Sorry missed caf√© STOP", true, "Duty called STOP I understand STOP"); //If not met Mina
  createTelegram(nameKey, altNames, desc, signOff, 3, "Planned exam STOP", false, "Very exciting STOP[Keep me posted STOP"); //If planned exam at LawSociety
  createTelegram(nameKey, altNames, desc, signOff, 4, "Succeeded exam STOP", false, "How wonderful STOP[Cannot wait to celebrate this with you STOP"); //If succeeded exam at LawSociety
  createTelegram(nameKey, altNames, desc, signOff, 5, "Got major sell assignment STOP[Anticipating major royalties STOP[Need to travel to Transylvania STOP[Only be gone a few weeks STOP", false, "Be careful on your trip STOP[Hope all goes well STOP"); //If gotten assignment
  
  //Hawkins
  nameKey = "Hawkins";
  altNames = "Peter, Hawkins, Boss, Sollicitor";
  desc = "Mr. Peter Hawkins, Esq., in Exeter";
  signOff = "Salutations";
  createTelegram(nameKey, altNames, desc, signOff, 1, "In London STOP", true, "Hope the Hummums is convenient STOP"); //base
  createTelegram(nameKey, altNames, desc, signOff, 2, "Taken all required pictures STOP", false, "You need to go to Count Dracula's castle STOP[Cannot go STOP[gout is acting up STOP[Will send letter for Count to your Hotel by courrier STOP"); //when pictures are taken
  createTelegram(nameKey, altNames, desc, signOff, 3, "Sollicitor exam succeeded STOP[Now full sollicitor STOP[Very greatful for all your support STOP", false, "Congratulation on the exam STOP[I always had every possible confidence in you STOP[You are a young man full of energy and talent in your own way, and of a very faithful disposition STOP"); //succeeded
  createTelegram(nameKey, altNames, desc, signOff, 4, "I accept the assignment STOP[Very grateful for your thrust STOP", false, "Godspeed on the assignment STOP[Major royalties to fund your upcoming wedding STOP"); //aftger assignment
  
  //CarfaxSeller should be created later
}

Dictionary* setupAnswerInclude(Dictionary* usedIncludeDict)
{
  Dictionary* noAnswer = Dictionary.Create(eNonSorted);
  String originalKeys[];
  originalKeys = usedIncludeDict.GetKeysAsArray();
  int i;
  for(i = 0 ; i < usedIncludeDict.ItemCount ; i++)
  {
    noAnswer.Set(originalKeys[i], "0");
  }
  
  switch(usedIncludeDict)
  {
    case telegramRecipient_messageParts_include:
      return telegramAnswer_messageParts_include;
      break;
    default:
      return noAnswer;
      break;
  }
}

String buildTelegramToSend(String recipient, Dictionary* messages, Dictionary* inclusions)
{
  String partsToConcatenate = "";
  String msgKey[];
  Dictionary* msgAnswers = setupAnswerInclude(inclusions);
  msgKey = messages.GetKeysAsArray();
  int i;
  
  for(i = 0 ; i < messages.ItemCount ; i++)
  {
    if(msgKey[i].StartsWith(recipient) && inclusions.Get(msgKey[i]) == "1")
    {
      if(partsToConcatenate == "")
      {
        partsToConcatenate = messages.Get(msgKey[i]);
      } else
      {
        partsToConcatenate = partsToConcatenate.Append("[");
        partsToConcatenate = partsToConcatenate.Append(messages.Get(msgKey[i]));
      }
      inclusions.Set(msgKey[i], "0"); // include msgPart only once
      msgAnswers.Set(msgKey[i], "1"); // setup the answer
    }
  }
  
  if(partsToConcatenate != "")
  {
    partsToConcatenate = partsToConcatenate.Append("[");
    partsToConcatenate = partsToConcatenate.Append(String.Format("%s STOP", telegramRecipient_signOff.Get(recipient)));
  }  
  return partsToConcatenate;
}

function createCarfaxSeller()
{
  carfaxSeller = createHawkinsPropertyFile("Wintringham", "London", "East", 764);
  
  String nameKey = "Wintringham";
  String altNames = "Wintringham, Carfax, Seller";
  String desc = "Mr. Edward Wintringham, in Norwich";
  String signOff = "Regards";
  createTelegram(nameKey, altNames, desc, signOff, 1, "Interested in Carfax property in Purfleet STOP[Please confirm condition and file availability STOP", true, "Carfax is up for sale as is STOP[Made detailed sale dossier available for you at Law Society reception"); //base
  createTelegram(nameKey, altNames, desc, signOff, 2, "Acquired sale dossier STOP[Will present property to our client STOP", false, "Noted STOP[Will wait further news from you"); //after gotten dossier  
}

function addTimedEventInXMinutes(int minutes, String whatHappens)
{
  int theseMinutes = translateTimeToMinutes(whatTimeIsIt(false)) + (currentDay * 24 * 60);
  theseMinutes = theseMinutes + minutes;
  
  timedEvents.Set(String.Format("%05d_%s", theseMinutes, whatHappens), whatHappens);
}

function removeTimedEvent(String timedEventKey)
{
  if(timedEvents.Contains(timedEventKey))
  {
    timedEvents.Remove(timedEventKey);
  } else
  {
    debugDisplay(String.Format("%s is not in the timedEvent dict"));
  }
}

bool playerHasTimedEventByWhatHappens(String whatHappens)
{
  String theseValues[];
  theseValues = timedEvents.GetValuesAsArray();
  int i = 0;
  bool returnBool = false;
  
  while(i < timedEvents.ItemCount && !returnBool)
  {
    if(theseValues[i] == whatHappens)
    {
      returnBool = true;
    } else
    {
      i++;
    }
  }
  
  return returnBool;
}

function removeTimedEventByWhatHappens(String whatHappens)
{
  String theseKeys[];
  String theseValues[];
  theseValues = timedEvents.GetValuesAsArray();
  theseKeys = timedEvents.GetKeysAsArray();
  int i;
  
  for(i = 0 ; i < timedEvents.ItemCount ; i++)
  {
    if(theseValues[i] == whatHappens)
    {
      removeTimedEvent(theseKeys[i]);
    }
  }
}

bool getGottaSleep()
{
  return gottaSleep;
}

function hasSlept()
{
  removeTimedEventByWhatHappens("Sleep complaint");
  removeTimedEventByWhatHappens("Forced sleep");
  addTimedEventInXMinutes((17 * 60), "Sleep complaint");
  gottaSleep = false;
}

function hasEaten()
{
  removeTimedEventByWhatHappens("Hungry complaint");
  addTimedEventInXMinutes((7 * 60), "Hungry complaint");
  lastMealTime = translateTimeToMinutes(whatTimeIsIt(false)) + (currentDay * 24 * 60);
}

function setBasicTimedEvents()
{
  addTimedEventInXMinutes((7 * 60), "Hungry complaint"); // hungry in 7 hours
  addTimedEventInXMinutes((17 * 60), "Sleep complaint"); // sleepy in 17 hours
  addTimedEventInXMinutes((30), "Beard growth"); // by 1%
  gottaSleep = false;
}

Dictionary* cutByStops(String msg)
{
  Dictionary* listOfSentences = Dictionary.Create(eSorted);
  msg = msg.Replace("[", "", eCaseInsensitive);
  String workingString;
  int i = 0;
  
  while(msg.IndexOf("STOP") != -1)
  {
    workingString = msg.Truncate(msg.IndexOf("STOP") + 4);
    msg = removeOneStringInstance(msg, workingString);
    if(msg.StartsWith(" "))
    {
      msg = removeOneStringInstance(msg, " ");
    }
    listOfSentences.Set(String.Format("%09d", i), workingString);
    i++;
  }
  listOfSentences.Set(String.Format("%09d", i), msg);
  
  return listOfSentences;
}

function sendTelegram(String recipientName)
{
  String sendThis = buildTelegramToSend(recipientName, telegramRecipient_messageParts, telegramRecipient_messageParts_include);
  Dictionary* thingsToSay_d;
  String thingsToSay_s[];
  int i;
  
  if(sendThis == "")
  {
    player.Say("Scratch that, I already sent them all I needed");
  } else
  {
    thingsToSay_d = cutByStops(sendThis);
    thingsToSay_s = thingsToSay_d.GetValuesAsArray();
    for(i = 0 ; i < thingsToSay_d.ItemCount ; i++)
    {
      player.Say(thingsToSay_s[i]);
    }
    if(Game.DoOnceOnly("Ask name and address"))
    {
      cTelegramOperator.Say("And finally: Your name and 'lieu' of residence?");
      if(player.HasInventory(iDiploma))
      {
        player.Say("Jonathan Harker, Esq.");
      } else
      {
        player.Say("Jonathan Harker");
      }
      player.Say("I reside at the Hotel the Hummums while in London");
    }
    cTelegramOperator.Say("Noted, Mr. Harker. I will send this in a minute");
    cTelegramOperator.Say("If and when an answer comes, I will send it to your hotel by messenger");
    addTimedEventInXMinutes(60, String.Format("Telegram answer from %s", recipientName));
  }
}

String findTelegramRecipientByName(String givenName)
{
  String possibleName[];
  possibleName = telegramRecipient_alternateNames.GetKeysAsArray();
  int i = 0;
  String returnName = "Null";
  String listOfAlternates;
  
  while(i < telegramRecipient_alternateNames.ItemCount)
  {
    listOfAlternates = telegramRecipient_alternateNames.Get(possibleName[i]);
    if(listOfAlternates.IndexOf(givenName) != -1)
    {
      returnName = possibleName[i];
      i = telegramRecipient_alternateNames.ItemCount;
    } else {
      i++;
    }
  }
  
  return returnName;
}

function handleTelegramRecipient(String textInput)
{
  String actualRecipient = "Null";
  String workingString = "";
  while(actualRecipient == "Null" && textInput != workingString)
  {
    if(textInput.IndexOf(" ") != -1)
    {
      workingString = workingString.Truncate(workingString.IndexOf(" "));
      workingString = workingString.Replace(" ", "", eCaseInsensitive);
      textInput = textInput.Replace(workingString, "");
    } else
    {
      workingString = textInput;
    }
    actualRecipient = findTelegramRecipientByName(workingString);
  }
  if(actualRecipient == "Null")
  {
    player.Say(String.Format("%s?", textInput));
    cTelegramOperator.Say("That sounded more like a question than an answer!");
    cTelegramOperator.Say("Do you think I'll find this name with an interrogation point in my directory?");
    cTelegramOperator.Say("Ha ha ha!");
    cTelegramOperator.Say("I'm just being silly");
    cTelegramOperator.Say("But that name is not in my directory");
    dTelegram.Start();
  } else
  {
    player.Say(telegramRecipient_recipientDescription.Get(actualRecipient));
    cTelegramOperator.Say("And what is the message?");
    sendTelegram(actualRecipient);
  }
}

//##### PERMITTED ENTRANCE #####
function setOpeningAndClosingTimeForACommerce(commerce thisCommerce, String thisOpeningTime, String thisClosingTime, bool rebuteWhenClosed)
{
  String rebute = "false";
  if(rebuteWhenClosed)
  {
    rebute = "true";
  }
  
  commerce_openingTime.Set(commerceAsString(thisCommerce), thisOpeningTime);
  commerce_closingTime.Set(commerceAsString(thisCommerce), thisClosingTime);
  commerce_rebuteWhenClosed.Set(commerceAsString(thisCommerce), rebute);
}

function setOpeningAndClosingTimes()
{
  setOpeningAndClosingTimeForACommerce(Museum, translateTimeToHHMMAM(10, 0, "AM"), translateTimeToHHMMAM(5, 0, "PM"), true);
  setOpeningAndClosingTimeForACommerce(HawkinsEsq, translateTimeToHHMMAM(8, 0, "AM"), translateTimeToHHMMAM(4, 30, "PM"), true);
  setOpeningAndClosingTimeForACommerce(LawSocietyBuilding, translateTimeToHHMMAM(10, 0, "AM"), translateTimeToHHMMAM(4, 30, "PM"), true);
  setOpeningAndClosingTimeForACommerce(Shop, translateTimeToHHMMAM(9, 0, "AM"), translateTimeToHHMMAM(6, 0, "PM"), true);
  setOpeningAndClosingTimeForACommerce(TrainStation, translateTimeToHHMMAM(6, 0, "AM"), translateTimeToHHMMAM(11, 0, "PM"), false);
  setOpeningAndClosingTimeForACommerce(AlwaysOpened, translateTimeToHHMMAM(0, 00, "AM"), translateTimeToHHMMAM(11, 59, "PM"), false);
}

commerce getCommerceType(zone targetZone)
{
  return stringAsCommerce(zone_CommerceType.Get(zoneAsString(targetZone)));
}

function setCurrentZone(zone thisZone)
{
  currentZone = thisZone;
  currentCommerceType = getCommerceType(currentZone);
}

String isThisPlaceOpened(commerce commerceType)
{
  String thisTime = whatTimeIsIt(false);
  String minTime = commerce_openingTime.Get(commerceAsString(commerceType));
  String maxTime = commerce_closingTime.Get(commerceAsString(commerceType));
  int openedFor;
  String giveOpeningTimes = String.Format("Closed! The sign says it is opened from %s to %s", minTime, maxTime);
  
  if(commerceType == AlwaysOpened)
  {
    return "opened";
  } else if(isThisTimeBeforeThisTime(thisTime, minTime)) //not opened yet
  {
    return giveOpeningTimes;
  } else if (isThisTimeBeforeThisTime(maxTime, thisTime)) //alreadyclosed
  {
    return giveOpeningTimes;
  } else if (isThisTimeWithinXminOfThisTime(thisTime, maxTime, 30))
  {
    openedFor = translateTimeToMinutes(maxTime) - translateTimeToMinutes(thisTime);
    return String.Format("%d", openedFor);
  } else
  {
    return "opened";
  }
}

bool isThisPlaceOpened_bool(commerce commerceType)
{
  String isIt = isThisPlaceOpened(commerceType);
  return !isIt.StartsWith("Close");
}

zone manageEntranceToCommerce(zone destination)
{
  commerce commerceType = getCommerceType(destination);
  String state = isThisPlaceOpened(commerceType);
  bool rebute = (state.StartsWith("Close") && commerce_rebuteWhenClosed.Get(commerceAsString(commerceType)) == "true");
  
  commerce commerceType2 = getCommerceType(currentZone);
  String state2 = isThisPlaceOpened(commerceType2);
  bool rebute2 = (state2.StartsWith("Close") && commerce_rebuteWhenClosed.Get(commerceAsString(commerceType2)) == "true");
  
  if (!rebute)
  {
    return destination;
  } else if (rebute && !rebute2)
  {
    return currentZone;
  } else
  {
    if (city_TravelDestinations.Get(zoneAsString(currentZone)) == "Exeter")
    {
      return JonathanApt;
    } else
    {
      return LondonTrainStation;
    }
  }
}

zone getWantedDestination()
{
  return wantedDestination;
}

zone getRealDestination()
{
  return realDestination;
}

function setTravellingBool(bool targetbool)
{
  travelling = targetbool;
}

bool getTravellingBool()
{
  return travelling;
}

function travel_movePlayer(zone destination,  bool addTravelTime)
{
  CharacterDirection arrivalDirection;
  String roomDestination;
  int futureRoom;
  int minutesOfTravel;
  
  wantedDestination = destination;
  travelling = true;
  
  realDestination = manageEntranceToCommerce(destination);
  
  if(wantedDestination != realDestination)
  {
    player.ChangeRoom(12, 156, 142, eDirectionDown);
  } else
  {
    roomDestination = roomForEachTravelDestinations.Get(zoneAsString(realDestination));
    futureRoom = roomDestination.AsInt;
    
    if(addTravelTime)
    {
      minutesOfTravel = travelDestinationTimeInMinutes(getCurrentZone(), getWantedDestination());
      addTime(0, minutesOfTravel, 0, 0);
    }
    loseThought();
  
    player.ChangeRoom(futureRoom, arrival_x[futureRoom], arrival_y[futureRoom], faceDirection[futureRoom]);
    cHarkersBeard.ChangeRoom(futureRoom, arrival_x[futureRoom], arrival_y[futureRoom], faceDirection[futureRoom]);
    addTravelDestination(wantedDestination);
    setCurrentZone(realDestination);
    travelling = false;
  }
}

function travel(zone destination)
{
  if(destination != StayHere)
  {
    travel_movePlayer(destination,  true);
  } else {
    player.Walk(arrival_x[player.Room], arrival_y[player.Room], eBlock, eAnywhere);
    player.FaceDirection(faceDirection[player.Room]);
  }
}

//##### FOOD #######
function addFood(String foodName, String alternateNames, String textDescription)
{
  if(!food_description.Contains(foodName))
  {
    int spoilTime = translateTimeToMinutes(whatTimeIsIt(false)) + (6*60) + (currentDay * 24 * 60);
    String spoilTimeAsString = String.Format("%d", spoilTime);
    addSubitem(iFood, foodName, textDescription, "This food is still good");
    food_alternateNames.Set(foodName, String.Format("%s,%s", foodName, alternateNames));
    food_spoilTime.Set(foodName, spoilTimeAsString);
  } else
  {
    player.Say(String.Format("I already have %s, I better eat mine instead, before it spoils", foodName));
  }
}

bool isFoodSpoiled(String foodName)
{
  int currentMinutes = translateTimeToMinutes(whatTimeIsIt(false)) + (currentDay * 24 * 60);
  String foodSpoilTime_asString = food_spoilTime.Get(foodName);
  int foodSpoilTime = foodSpoilTime_asString.AsInt;
  return (currentMinutes > foodSpoilTime);
}

function updateFoodFreshness()
{
  String foodNames[];
  foodNames = food_spoilTime.GetKeysAsArray();
  int i;
  
  for(i = 0 ; i < food_spoilTime.ItemCount ; i++)
  {
    if(isFoodSpoiled(foodNames[i]))
    {
      food_notes.Set(foodNames[i], "This food is spoiled. I can throw it out in any caf√©'s bin");
    } 
  }
}

function cleanAllSpoiledFood()
{
  String foodNames[];
  foodNames = food_spoilTime.GetKeysAsArray();
  int i;
  for(i = 0 ; i < food_spoilTime.ItemCount ; i++)
  {
    if(isFoodSpoiled(foodNames[i]))
    {
      switch(Random(3))
      {
        case 0:
          player.Say(String.Format("Away with the spoiled %s", foodNames[i]));
          break;
        case 1:
          player.Say(String.Format("Spoiled %s is discarded", foodNames[i]));
          break;
        case 2:
          player.Say(String.Format("No need for a spoiled %s", foodNames[i]));
          break;
        default:
          player.Say(String.Format("Spoiled %s are smelly", foodNames[i]));
          break;
      }
      removeSubitem(iFood, foodNames[i], false);
    } 
  }
}

bool playerHasSpoiledFood()
{
  bool returnBool = false;
  String foodNames[];
  foodNames = food_spoilTime.GetKeysAsArray();
  int i = 0;
  while(i < food_spoilTime.ItemCount)
  {
    if(isFoodSpoiled(foodNames[i]))
    {
      i = food_spoilTime.ItemCount;
      returnBool = true;
    } else
    {
      i++;
    }
  }
  return returnBool;
}


bool isPlayerHungry()
{
  int nowInMinutes = translateTimeToMinutes(whatTimeIsIt(false)) + (currentDay * 24 * 60);
  return ((lastMealTime + (4 * 60)) < nowInMinutes);
}

String findFoodByName(String cmd)
{
  String returnName = "Null";
  String altNames;
  String foodList[];
  String foodKey[];
  String alternateName[];
  int i = 0;
  int y = 1;

  foodList = food_alternateNames.GetValuesAsArray();
  foodKey = food_alternateNames.GetKeysAsArray();
  while(i < food_alternateNames.ItemCount)
  {
    alternateName = split(foodList[i], ", ");
    while(y < alternateName[0].AsInt) // [0] is the length
    {
      if(cmd.IndexOf(alternateName[y]) != -1)
      {
        returnName = foodKey[i];
        y = alternateName[0].AsInt;
        i = food_alternateNames.ItemCount;
      } else
      {
        y++;
      }
    }
    i++;
  }
  return returnName;
}

function eatFood(String foodName)
{
  foodName = findFoodByName(foodName);
  if(foodName == "Null")
  {
    player.Say("I do not have this food");
  } else
  {
    if(isPlayerHungry())
    {
      player.Say(String.Format("I am hungry for a %s", foodName));
      if(isFoodSpoiled(foodName))
      {
        player.Say("Blo. . . H. . .! Ew!");
        player.Say("That food is spoiled");
        removeSubitem(iFood, foodName, false);
        GiveScore(-1);
      } else
      {
        player.Say("Delicious!");
        removeSubitem(iFood, foodName, false);
        hasEaten();
      }
    } else
    {
      player.Say("I ate not that long ago");
    }
  }
}

//####### PICTURES ######
int getNbNegative()
{
  return nbNegatives;
}

int getNbMissingNegatives()
{
  return MAXNEGATIVE - nbNegatives;
}

function setNumberOfNegative(int targetNbNegative)
{
  String nbNegativesMsg = "I have ### negative@ left";
  
  if(targetNbNegative < 0)
  {
    nbNegatives = 0;
  } else if (targetNbNegative > MAXNEGATIVE)
  {
    nbNegatives = MAXNEGATIVE;
  } else
  {
    nbNegatives = targetNbNegative;
  }
  
  switch(nbNegatives)
  {
    case 0:
      nbNegativesMsg = nbNegativesMsg.Replace("###", "no", eCaseInsensitive);
      nbNegativesMsg = nbNegativesMsg.Replace("@", "s", eCaseInsensitive);
      break;
    case 1:
      nbNegativesMsg = nbNegativesMsg.Replace("###", "1", eCaseInsensitive);
      nbNegativesMsg = nbNegativesMsg.Replace("@", "", eCaseInsensitive);
      break;
    default:
      nbNegativesMsg = nbNegativesMsg.Replace("###", String.Format("%d", nbNegatives), eCaseInsensitive);
      nbNegativesMsg = nbNegativesMsg.Replace("@", "s", eCaseInsensitive);
      break;
  }
  iCamera.SetTextProperty("TextDescription", String.Format("This is the office's photo camera. State of the art technology![[%s", nbNegativesMsg));
  
  if(!playerHasTravelDestination(PhotographyShop) && nbNegatives < 4)
  {
    gameIsOver("Jonathan likes photos too much");
  }
}

function resetNbNegativesToMax()
{
  setNumberOfNegative(MAXNEGATIVE);
}

bool playerHasAllCarfaxPictures() // test me
{
  bool allPhotos = true;
  bool hasThisPhoto;
  String currentSubject;
  InventoryItem* photoItem = iPhotos;
  InventoryItem* filmItem = iFilm;
  
  currentSubject = "Carfax's Kitchen";
  hasThisPhoto = playerHasSubitem(currentSubject, photoItem) || playerHasSubitem(currentSubject, filmItem);
  allPhotos = allPhotos && hasThisPhoto;
  
  currentSubject = "Carfax's Living";
  hasThisPhoto = playerHasSubitem(currentSubject, photoItem) || playerHasSubitem(currentSubject, filmItem);
  allPhotos = allPhotos && hasThisPhoto;
  
  currentSubject = "Carfax's Dining";
  hasThisPhoto = playerHasSubitem(currentSubject, photoItem) || playerHasSubitem(currentSubject, filmItem);
  allPhotos = allPhotos && hasThisPhoto;
 
  currentSubject = "Carfax's Bedroom";
  hasThisPhoto = playerHasSubitem(currentSubject, photoItem) || playerHasSubitem(currentSubject, filmItem);
  allPhotos = allPhotos && hasThisPhoto;
  
  if(allPhotos)
  {
    if(Game.DoOnceOnly("taken all 4 photos"))
    {
      setTelegramInclusionByIndex("Hawkins", 2, true);
      
    }
  }
  
  return allPhotos;
}

function triggerTimedEvent(String timedEventKey, String whatHappens)
{
  String CarfaxSellerTelegramAnswer = String.Format("Telegram answer from %s", getCarfaxSeller());
  
  removeTimedEvent(timedEventKey);
  switch(whatHappens)
  {
    case "Beard growth":
      cHarkersBeard.Transparency = cHarkersBeard.Transparency - 1;
      addTimedEventInXMinutes((30), "Beard growth");
      break;
    case "Hungry complaint":
      player.Say("I have not had a bite in a while, I am quite hungry");
      GiveScore(-1);
      addTimedEventInXMinutes((60), "Hungry complaint");
      break;
    case "Sleep complaint":
      player.Say("*yawn*");
      player.Say("Oh my, I have not slept in quite a while");
      if(getCurrentCity() == "Exeter")
      {
        player.Say("Better get home to take a nap");       
      } else
      {
        player.Say("Better head to the hotel to take a nap");
      }
      addTimedEventInXMinutes(60, "Forced sleep");
      break;
    case "Forced sleep":
      player.Say("*yawn*");
      player.Say("Ok, I have to go get some sleep");
      if(getCurrentCity() == "Exeter")
      {
        if(player.Room == 1)
        {
          player.Walk(61, 172, eBlock, eWalkableAreas);
          FadeOut(5);
          hasSlept();
          player.FaceDirection(eDirectionRight);
          FadeIn(5);
          player.Say("Ah, I feel refreshed");
        } else
        {
          travel(JonathanApt);
        }
      } else
      {
        travel(LondonHotel);
        hasSlept();
      }
      GiveScore(-1);
      break;
    case "Max time for photos & telegram":
      player.Say(String.Format("Oh no. . . It is %s", whatTimeIsIt(true)));
      if(playerHasAllCarfaxPictures())
      {
        player.Say("I had to send a telegram to Mr. Hawkins before his train left");
        gameIsOver("Jonathan failed his assignment");
      }
      break;
    case "Telegram answer from Mina":
      addHotelPackage(String.Format("Mina - %s", whatTimeIsIt(false)), buildTelegramToSend("Mina", telegramAnswer_messageParts, telegramAnswer_messageParts_include), String.Format("Telegram send by %s - received at %s", telegramRecipient_recipientDescription.Get("Mina"), whatTimeIsIt(false)));
      break;
    case "Telegram answer from Hawkins":
      addHotelPackage(String.Format("Hawkins - %s", whatTimeIsIt(false)), buildTelegramToSend("Hawkins", telegramAnswer_messageParts, telegramAnswer_messageParts_include), String.Format("Telegram send by %s - received at %s", telegramRecipient_recipientDescription.Get("Hawkins"), whatTimeIsIt(false)));
      addTimedEventInXMinutes(3 * 60, "Hawkins' Letter");
      break;
    case CarfaxSellerTelegramAnswer:
      addHotelPackage(String.Format("%s - %s", carfaxSeller, whatTimeIsIt(false)), buildTelegramToSend(carfaxSeller, telegramAnswer_messageParts, telegramAnswer_messageParts_include), String.Format("Telegram send by %s - received at %s", telegramRecipient_recipientDescription.Get(carfaxSeller), whatTimeIsIt(false)));
      break;
    case "Hawkins' Letter":
      addHotelPackage("Instructions", "This letter, signed by Count Dracula, describes the suggested itinerary from London to Transylvania", "Suggested route: London, Southamptons, Paris, Munich, Vienna, Budapest, Klausenburg, Bistritz");
      addHotelPackage("Munich's contracts", "Mr. Hawkins planned to stop a few days in Munich and negotiate some dealings with different Londonian firms", "Stops: Old Pinakothek Museum, Munich Opera House, Municipal Dead House");
      addHotelPackage("To Dracula", "Mr. Hawkins's letter to the Count, explaining that I will handled his purchase", "It reads: 'I must regret that an attack of gout, from which malady I am a constant sufferer, forbids absolutely any travelling on my part for some time to come; but I am happy to say I can send a sufficient substitute, one in whom I have every possible confidence. He is a young man, full of energy and talent in his own way, and of a very faithful disposition. He is discreet and silent, and has grown into manhood in my service. He shall be ready to attend on you when you will during his stay, and shall take your instructions in all matters.'");
      break;
  }
}

int extractTimeFromTimedEventKey(String theKey)
{
  String returnString = theKey.Truncate(theKey.IndexOf("_"));
  returnString = returnString.Replace("_", "", eCaseInsensitive);
  return returnString.AsInt;
}

function isThereAnExpiredTimedEvent()
{
  testingExpiration = true;
  if(!handlingTriggeredEvent)
  {
    int thisTime = translateTimeToMinutes(whatTimeIsIt(false)) + (currentDay * 24 * 60);
    String timedEventList[];
    timedEventList = timedEvents.GetKeysAsArray();
    int i = 0;
    
    while (i < timedEvents.ItemCount)
    {
      if(thisTime > extractTimeFromTimedEventKey(timedEventList[i]))
      {
        triggerTimedEvent(timedEventList[i], timedEvents.Get(timedEventList[i]));
        i = timedEvents.ItemCount;
      } else
      {
        i++;
      }
    }
  }
  testingExpiration = false;
}

function takeAPicture(String subject, String pictureDescription, int score)
{
  if(!player.HasInventory(iCamera))
  {
    player.Say("I need a camera to take pictures");
  } else if(nbNegatives < 1)
  {
    player.Say("I am out of film. . .");
  } else
  {
    setNumberOfNegative(nbNegatives - 1);
    addSubitem(iFilm, subject, pictureDescription, "This picture must be developed by a professional before I can use it");
    Display("Click!");
    player.Say(String.Format("I took a picture of the %s", subject));
    if(Game.DoOnceOnly("Talk about developped photos"))
    {
      player.Say("Of course it must be developed by a professional before I can use it");
    }
    
    if(score != 0)
    {
      giveScoreOnce(String.Format("Picture of %s", subject), score);
    }
    
    if(playerHasAllCarfaxPictures())
    {
      if(Game.DoOnceOnly("All Carfax's pictures"))
      {
        player.Say("Splendid, I have all four pictures of this property for the file");
        player.Say("Time to head back to London");
        player.Say("I must send a telegram to Mr. Hawkins as soon as possible");
        addTravelDestination(TelegramOffice);
      }
    }
  }
}

//####### INTERACTIONS #######



function findElementContaining(String keyword) // makes a list of found things reacting to the 'find' keyword
{
  int i;
  bool intro = false;
  bool invIntro = false;
  String nameAndAKA;
  String article = "";
  String allElementsMentionned = "";
  
  //OBJECTS IN THE ROOM
  for(i = 0; i < Room.ObjectCount; i++) {
    nameAndAKA = object[i].Name;
    if(object[i].GetTextProperty("alternateNames") != "")
    {
      nameAndAKA = nameAndAKA.Append(", ");
      nameAndAKA = nameAndAKA.Append(object[i].GetTextProperty("alternateNames"));
    }
    if(nameAndAKA.IndexOf(keyword) != -1) {
      if(!intro)
      {
        player.Say("Looking around, I can spot. . .");
        intro = true;
      }
      player.FaceObject(object[i], eBlock);
      article = whichArticle(allElementsMentionned, object[i].Name);
      player.Say(String.Format("%s %s over there.", article,  object[i].Name));
      allElementsMentionned = allElementsMentionned.Append(String.Format("%s ", object[i].Name));
    }
  }
  //HOTSPOTS IN THE ROOM
  for(i = 0; i < 50; i++) {
    nameAndAKA = hotspot[i].Name;
    if(hotspot[i].GetTextProperty("alternateNames") != "")
    {
      nameAndAKA = nameAndAKA.Append(", ");
      nameAndAKA = nameAndAKA.Append(hotspot[i].GetTextProperty("alternateNames"));
    }
    if(nameAndAKA.IndexOf(keyword) != -1) {
      if(!intro)
      {
        player.Say("Looking around, I can spot. . .");
        intro = true;
      }
      player.FaceLocation(hotspot[i].WalkToX, hotspot[i].WalkToY, eBlock);
      article = whichArticle(allElementsMentionned, hotspot[i].Name);
      player.Say(String.Format("%s %s over there.", article,  hotspot[i].Name));
      allElementsMentionned = allElementsMentionned.Append(String.Format("%s ", hotspot[i].Name));
    }
  }
  //CHARACTERS IN THE ROOM
  for(i = 0; i < Game.CharacterCount; i++) {
    nameAndAKA = character[i].Name;
    if(character[i].GetTextProperty("alternateNames") != "")
    {
      nameAndAKA = nameAndAKA.Append(", ");
      nameAndAKA = nameAndAKA.Append(character[i].GetTextProperty("alternateNames"));
    }
    if(nameAndAKA.IndexOf(keyword) != -1 && player.Room == character[i].Room) {
      if(!intro)
      {
        player.Say("Looking around, I can spot. . .");
        intro = true;
      }
      player.FaceCharacter(character[i]);
      player.Say(String.Format("%s over there.", character[i].Name));
    }
  }
  //OWNED INVENTORY ITEMS
  for(i = 1; i <= Game.InventoryItemCount; i++) {
    nameAndAKA = inventory[i].Name;
    if(inventory[i].GetTextProperty("alternateNames") != "")
    {
      nameAndAKA = nameAndAKA.Append(", ");
      nameAndAKA = nameAndAKA.Append(inventory[i].GetTextProperty("alternateNames"));
    }
    if(nameAndAKA.IndexOf(keyword) != -1 && player.HasInventory(inventory[i])) {
      if(!invIntro)
      {
        if(intro)
        {
          player.Say("Also. . .");
        }
        player.Say("In my inventory, I can spot. . .");
        invIntro = true;
        intro = true;
      }
      player.FaceDirection(eDirectionDown);
      article = whichArticle(allElementsMentionned, inventory[i].Name);
      player.Say(String.Format("%s %s.", article, inventory[i].Name));
      allElementsMentionned = allElementsMentionned.Append(String.Format("%s ", inventory[i].Name));
    }
  }
}

function useInteraction(String cmd) // either 'interact' or 'UseInv' version of runInteraction is used
{
  String OnSynonym = isInteractionOnElement(cmd);
  String useSynonym = cmdStartsWithUSEsynonym(cmd);
  
  String cmdUsed;
  String cmdOn;
  
  String indexElementUsed[] = new String[2];
  elementType eTUsed;
  int indexUsed;
  bool canUse = true;
  
  String indexElementOn[] = new String[2];
  elementType eTOn;
  int indexOn;
  
  elementType eTTemp;
  int indexTemp;
    
  if(OnSynonym == "Null") // there is only one verb (use) and a target
  {
      cmd = removeOneStringInstance(cmd, useSynonym.Append(" "));
      indexElementUsed = findElementIndexByName(cmd);
      
      if(indexElementUsed[1] == "Null")
      {
        player.Think("I am not sure what to use");
      } else {
        eTUsed = stringToET(indexElementUsed[1]);
        indexUsed = indexElementUsed[0].AsInt;
        // to handled generic unhandled exception later
        useET = eTUsed;
        useIndex = indexUsed;
        
        switch(eTUsed)
        {
          case roomObjects:
            if(isCharacterNearObject(object[indexUsed], reachDistance, player))
            {
              object[indexUsed].RunInteraction(eModeInteract);
            } else {
              player.Think(String.Format("I need to get closer to the %s to use it", object[indexUsed].Name.LowerCase()));
            }
            break;
          case roomHotspots:
            if(isCharacterNearHotspot(hotspot[indexUsed], reachDistance, player))
            {
              hotspot[indexUsed].RunInteraction(eModeInteract);
            } else {
              player.Think(String.Format("I need to get closer to the %s to use it", hotspot[indexUsed].Name.LowerCase()));
            }
            break;
          case allInventoryItems:
            if(player.HasInventory(inventory[indexUsed]))
            {
              inventory[indexUsed].RunInteraction(eModeInteract);
            } else {
              player.Think("I am not sure what you want me to use");
            }
            break;
          default:
            player.Think("I am not sure what you want me to use");
            break;
        }
      } 
  } else // The player wants to use something on/with something
  {
    cmd = removeOneStringInstance(cmd, useSynonym.Append(" "));
    cmdUsed = cmd.Truncate(cmd.IndexOf(OnSynonym));
    cmd = removeOneStringInstance(cmd, cmdUsed);
    cmdOn = removeOneStringInstance(cmd, OnSynonym);
    
    indexElementUsed = findElementIndexByName(cmdUsed);
    indexElementOn = findElementIndexByName(cmdOn);
    
    if(indexElementOn[1] == "Null" || indexElementUsed[1] == "Null")
    {
      player.Think("I am not sure what you want me to do");
    } else {
      eTUsed = stringToET(indexElementUsed[1]);
      indexUsed = indexElementUsed[0].AsInt;
      eTOn = stringToET(indexElementOn[1]);
      indexOn = indexElementOn[0].AsInt;
      
      if(eTOn == allInventoryItems && eTUsed != allInventoryItems) // if the 2nd is an item but not the first,  invert them
      {
        indexTemp = indexOn;
        eTTemp = eTOn;
        indexOn = indexUsed;
        eTOn = eTUsed;
        indexUsed = indexTemp;
        eTUsed = eTTemp;
      }
      if(eTUsed == allCharacters && eTOn != allCharacters) // if the 1st is a character but not the second,  invert them
      {
        indexTemp = indexOn;
        eTTemp = eTOn;
        indexOn = indexUsed;
        eTOn = eTUsed;
        indexUsed = indexTemp;
        eTUsed = eTTemp;
      }
      
      if(eTUsed == allInventoryItems)
      {
        if(!player.HasInventory(inventory[indexUsed]))
        {
          canUse = false;
        }
      } else if (eTUsed == allCharacters)
      {
        if(character[indexUsed].Room != player.Room)
        {
          canUse = false;
        }
      }
          
          
      if(canUse)
      {
        activeElementToUse_ElementType = etToString(eTUsed);
        activeElementToUse_Index = indexUsed;

        switch(eTOn)
        {
          case roomObjects:
            if(isCharacterNearObject(object[indexOn], reachDistance, player))
            {
              object[indexOn].RunInteraction(eModeUseinv);
            } else {
              player.Think(String.Format("I need to get closer to the %s to use my %s on it", object[indexOn].Name.LowerCase(), inventory[indexUsed].Name.LowerCase()));
            }              
            break;
          case roomHotspots:
            if(isCharacterNearHotspot(hotspot[indexOn], reachDistance, player))
            {
              hotspot[indexOn].RunInteraction(eModeUseinv);
            } else {
              player.Think(String.Format("I need to get closer to the %s to use my %s on it", hotspot[indexOn].Name.LowerCase(), inventory[indexUsed].Name.LowerCase()));
            }
            break;
          case allCharacters:
            if(character[indexOn].Room == player.Room && isCharacterNearCharacter(character[indexOn], reachDistance, player))
            {
              character[indexOn].RunInteraction(eModeUseinv);
            } else {
              player.Think(String.Format("I need to get closer to %s to use my %s on them", hotspot[indexOn].Name.LowerCase(), inventory[indexUsed].Name.LowerCase()));
            }
            break;
          case allInventoryItems:
            if(player.HasInventory(inventory[indexOn]))
            {
              inventory[indexOn].RunInteraction(eModeUseinv);
            } else {
              player.Think("I am not sure what you want me to use");
            }
            break;
          default:
            break;
        }
      } else {
        player.Think("I am not sure what you want me to use");
      }
    }
  }
}

int getNbOfDayPerMonth(int monthNumber)
{
  switch(monthNumber)
  {
    case 2:
      return 28;
      break;
    case 4:
      return 30;
      break;
    case 6:
      return 30;
      break;
    case 9:
      return 30;
      break;
    case 11:
      return 30;
      break;
    default:
      return 31;
      break;
  }
}

String getMonthName(int monthIndex)
{
  switch(monthIndex)
  {
    case 1:
      return "January";
      break;
    case 2:
      return "February";
      break;
    case 3:
      return "March";
      break;
    case 4:
      return "April";
      break;
    case 5:
      return "May";
      break;
    case 6:
      return "June";
      break;
    case 7:
      return "July";
      break;
    case 8:
      return "August";
      break;
    case 9:
      return "September";
      break;
    case 10:
      return "October";
      break;
    case 11:
      return "November";
      break;
    case 12:
      return "December";
      break;
  }
}

String getCurrentDate(bool written, bool withYear, int addedDays)
{
  int dayNb = currentDay + (FIRSTDAY_DAY - 1) + addedDays;
  int month = FIRSTDAY_MONTH;
  int year = FIRSTDAY_YEAR;
  String returnString;
  
  while(dayNb > getNbOfDayPerMonth(month))
  {
    dayNb = dayNb - getNbOfDayPerMonth(month);
    month++;
    if(month > 12)
    {
      month = 1;
      year++;
    }
  }
  
  if(written)
  {
    returnString = String.Format("%d %s", dayNb, getMonthName(month));
  } else
  {
    returnString = String.Format("%s %d", getMonthName(month), dayNb);
    if(returnString.EndsWith("1"))
    {
      returnString = returnString.Append("st");
    } else if (returnString.EndsWith("2"))
    {
      returnString = returnString.Append("nd");
    } else if (returnString.EndsWith("3"))
    {
      returnString = returnString.Append("rd");
    } else
    {
      returnString = returnString.Append("th");
    }
  }
  
  if(withYear)
  {
    returnString = returnString.Append(String.Format(" %d", year));
  }
  
  return returnString;
}

// called on every game cycle, except when the game is blocked
function repeatedly_execute()
{
  currentTime = currentTime + currentTimeIncrementPerLoop;
  
  //removed this since the 'whatTimeIsIt' function does it automatically
  /*if(currentTime > (loopPerSecond*86400)) {//86 400 = 24 * 60 * 60,  i.e. seconds per day
    currentTime = currentTime - (loopPerSecond*86400);
    currentDay++;
    Display(String.Format("It is now %s", getCurrentDate(false, false, 0)));
  }*/
  
  if(timeUITransparency < 200.0)
  {
    timeUITransparency = timeUITransparency + timeUIFadeSpeed;
    lblCurrentThought.Transparency = FloatToInt(timeUITransparency/2.0, eRoundDown);
    if(lblNoteDescriptionHighlight.Transparency < 100)
    {
      lblNoteDescriptionHighlight.Transparency = lblNoteDescriptionHighlight.Transparency + 1;
    }
  }
  
  isThereAnExpiredTimedEvent();
}

// called on every game cycle, even when the game is blocked
function repeatedly_execute_always()
{
  if(cHarkersBeard.Transparency < 100 && cHarker.GetProperty("sitting") == -1) // in REAlways,  becase we want it to continue even when a 'eBlock' animation is running
  {
    cHarkersBeard.FaceDirection(cHarker.Loop);
  }
  
  if(adjustForDarkness)
  {
    manageDarkness();
  }
}

function hide_wait_gui()
{
  close_gui(gWait);
  lblWaitUI.Text = "It is 8:00AM[How long should I wait ?";
  btnToggleForUntil.Text = "Wait for";
  btnConfirmWait.Text= "Confirm wait";
  btnToggleMinHrs.Text = "Minutes";
}

// called when a key is pressed
function on_key_press(eKeyCode keycode, int mod)
{
  // check for Escape first, so it can be used on GUIs that pause the game
  if (keycode == eKeyEscape)
  {
    if (gRestart.Visible)
    {
      // Escape will cancel a restart
      close_gui(gRestart);
    }
    else if (gPanel.Visible)
    {
      // Escape will turn the panel off
      close_gui(gPanel);
    }
    else if (gSaveGame.Visible)
    {
      // Escape will close the save game dialog
      close_gui(gSaveGame);
    }
    else if (gRestoreGame.Visible)
    {
      // Escape will close the restore game dialog
      close_gui(gRestoreGame);
    }
    else if (gInventory.Visible)
    {
      // Escape will close the restore game dialog
      close_gui(gInventory);
    }
    else if (gExitGame.Visible)
    {
      // Escape will cancel exiting the game
      close_gui(gExitGame);
    }
    else if (gParser.Visible) {
      // Escape will cancel the text parser
      close_gui(gParser);
    }
    else if (gWait.Visible) {
      // Escape will close the GUI
      hide_wait_gui();
    }
    else if (gClassify.Visible) {
      // Escape will close the GUI
      close_gui(gClassify);
      show_inventory_window();
    }
    else if (gNotebook.Visible) {
      // Escape will close the GUI
      close_gui(gNotebook);
      closeNotebookThoughts();
    }
    else if (gBook.Visible) {
      // Escape will close the GUI
      close_gui(gBook);
      closeNotebookThoughts();
    }
    else
    {
      // Escape will turn the panel on
      open_gui(gPanel);
    }
  }
  else if (keycode == eKeyF4)
  {
    if(lblCurrentThought.Transparency < 100)
    {
      if(gParser.Visible) {
        tbParser.Text = tbParser.Text.Append(lblCurrentThought.Text);
      } else if (gSimpleTextbox.Visible) {
        tbSimpleTextbox.Text = tbSimpleTextbox.Text.Append(lblCurrentThought.Text);
      }
    }
  }
  else if (IsGamePaused() || !IsInterfaceEnabled())
  {
    // game paused, so don't react to any keypresses
    keycode = 0;
  }
  else if (keycode == eKeyQ && (mod & eKeyModCtrl))
  {
    // Ctrl-Q will quit the game
    open_gui(gExitGame);
  }
  else if (keycode == eKeyF5)
  {
    // F5 will prompt to save a game
    show_save_game_dialog();
  }
  else if (keycode == eKeyF7)
  {
    // F7 will prompt to save a game
    show_restore_game_dialog();
  }
  else if (keycode == eKeyF9)
  {
    // F9 will prompt to restart the game
    open_gui(gRestart);
  }
  else if (keycode == eKeyF12)
  {
    // F12 will save a screenshot to the save game folder
    SaveScreenShot("screenshot.pcx");
  }
  else if (keycode >= 65 && keycode <= 90)
  {
    open_gui(gParser);
    //debugDisplay(String.Format("%d", keycode));
    tbParser.Text = keycodeToString(keycode);
  }
  else if (keycode == eKeyF3)
  {
    open_gui(gParser);
    //debugDisplay(keycodeToString(keycode));
    tbParser.Text = lastCMD;
  }
  else if (keycode == eKeyTab)
  {
    // Tab opens the inventory
    show_inventory_window();
  }
  else if (mod & eKeyModCtrl)
  {
    if (keycode == eKeyS)
    {
      // Ctrl-S will give the player all defined inventory items
      Debug(0, 0);
    }
    else if (keycode == eKeyV)
    {
      // Ctrl-V will show game engine version and build date
      Debug(1, 0);
    }
    else if (keycode == eKeyA)
    {
      // Ctrl-A will show walkable areas
      Debug(2, 3);
    }
    else if (keycode == eKeyX)
    {
      // Ctrl-X will let the player teleport to any room
      Debug(3, 0);
    }
  }
}

float distanceBetweenClickedAreas(int clickedX, int clickedY)
{
  int deltaXsquared = (player.DestinationX - clickedX) * (player.DestinationX - clickedX);
  int deltaYsquared = (player.DestinationY - clickedY) * (player.DestinationY - clickedY);
//debugDisplay(String.Format("%f", Maths.Sqrt(IntToFloat(deltaXsquared) + IntToFloat(deltaYsquared))));
  return Maths.Sqrt(IntToFloat(deltaXsquared) + IntToFloat(deltaYsquared));
}

// called when a mouse button is clicked
function on_mouse_click(MouseButton button)
{
  // called when a mouse button is clicked. button is either LEFT or RIGHT
  if (IsGamePaused())
  {
    
    // game is paused, so do nothing (i.e. don't process mouse clicks)
  }
  else if (button == eMouseLeft)
  {
    int destX = mouse.x + Game.Camera.X;
    int destY = mouse.y + Game.Camera.Y;
    
    if(player.Moving && player.WalkSpeedX > WALK_SPEED && (distanceBetweenClickedAreas(destX, destY) < 10.0) && BtnMultClickSpeed.Text == "3-Click Blink")
    {
      SkipUntilCharacterStops(player.ID);
    } else
    {
      player.SetWalkSpeed(WALK_SPEED, WALK_SPEED);
        
      if(player.GetProperty("sitting") == -1)
      {
        if(player.Moving && (distanceBetweenClickedAreas(destX, destY) < 10.0))
        {
          player.StopMoving();
          player.SetWalkSpeed(WALK_SPEED + 5, WALK_SPEED + 5);
        }      
        player.Walk(mouse.x + Game.Camera.X, mouse.y + Game.Camera.Y, eNoBlock, eWalkableAreas);
      } else {
        standUp(player, 1);
        player.Walk(destX, destY, eNoBlock, eWalkableAreas);
      }
    }
  }
}

// triggered when the Inventory button from the gQuickInventory is clicked
function btnIconInv_Click(GUIControl *control, MouseButton button)
{
  show_inventory_window();
}

//START OF CONTROL PANEL FUNCTIONS
function btnSave_OnClick(GUIControl *control, MouseButton button)
{
  close_owning_gui(control);
  playConfirm();
  show_save_game_dialog();
}

function btnAbout_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  Display("%s[AGS %s", Game.Name, System.Version);
}

function btnQuit_OnClick(GUIControl *control, MouseButton button)
{
  close_owning_gui(control);
  playSelect();
  open_gui(gExitGame);
}

function btnLoad_OnClick(GUIControl *control, MouseButton button)
{
  close_owning_gui(control);
  playConfirm();
  show_restore_game_dialog();
}

function sldAudio_OnChange(GUIControl *control)
{
  System.Volume = sldAudio.Value;
}

function btnDefault_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  set_default_options();
}

function sldSpeed_OnChange(GUIControl *control)
{
  SetGameSpeed(sldSpeed.Value);
}

function btnRestart_OnClick(GUIControl *control, MouseButton button)
{
  playConfirm();
  close_owning_gui(control);
  open_gui(gRestart);
}

function btnRestartYes_OnClick(GUIControl *control, MouseButton button)
{
  playConfirm();
  RestartGame();
}

int find_save_slot(String name)
{
  bool slots[] = new bool[999];
  int i = 0;

  while (i < lstSaveGamesList.ItemCount)
  {
    if (lstSaveGamesList.Items[i] == name)
    {
      // found existing save with matching name
      return lstSaveGamesList.SaveGameSlots[i];
    }

    // remember which slots are already taken
    slots[lstSaveGamesList.SaveGameSlots[i]] = true;
    i ++;
  }

  // find first free save slot, starting with slot 1
  i = 1;

  while (i < 999)
  {
    if (!slots[i])
    {
      return i;
    }

    i ++;
  }

  // no free slots found
  return -1;
}

function btnSaveGame_OnClick(GUIControl *control, MouseButton button)
{
  int gameSlotToSaveInto = find_save_slot(txtNewSaveName.Text);
  playSelect();
  if (gameSlotToSaveInto < 0)
  {
    Display("No more free save slots!");
  }
  else
  {
    SaveGameSlot(gameSlotToSaveInto, txtNewSaveName.Text);
    close_owning_gui(control);
  }
}

function btnRestoreGame_OnClick(GUIControl *control, MouseButton button)
{
  close_gui(gPanel);
  playSelect();
  if (lstRestoreGamesList.SelectedIndex >= 0)
  {
    RestoreGameSlot(lstRestoreGamesList.SaveGameSlots[lstRestoreGamesList.SelectedIndex]);
  }
  
  close_owning_gui(control);
  
}

function lstSaveGamesList_OnSelectionCh(GUIControl *control)
{
  playSelect();
  txtNewSaveName.Text = lstSaveGamesList.Items[lstSaveGamesList.SelectedIndex];
}

function txtNewSaveName_OnActivate(GUIControl *control)
{
  // pressing Return in the text box simulates clicking the save button
  btnSaveGame_OnClick(control, eMouseLeft);
}

function btnDeleteSave_OnClick(GUIControl *control, MouseButton button)
{
  if (lstSaveGamesList.SelectedIndex >= 0)
  {
    playConfirm();
    DeleteSaveSlot(lstSaveGamesList.SaveGameSlots[lstSaveGamesList.SelectedIndex]);
    lstSaveGamesList.FillSaveGameList();
  }
}

function btnConfirmedQuit_OnClick(GUIControl *control, MouseButton button)
{
  playConfirm();
  QuitGame(0);
}

function lbInventory_OnSelectionChanged(GUIControl *control)
{
  String itemName = lbInventory.Items[lbInventory.SelectedIndex];
  playSelect();
  lbInventory_Selector_adapt(itemName);
}

function btnToggleHints_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  if(showHints)
  {
    lblOverHotspot.Visible = false;
    lblOverHotspot.Text = "";
    btnToggleHints.Text = "Hints hidden";
    showHints = false;
  } else {
    lblOverHotspot.Text = "@OVERHOTSPOT@";
    lblOverHotspot.Visible = true;
    btnToggleHints.Text = "Hints shown";
    showHints = true;
  }
}

function tbParser_OnActivate(GUIControl *control) // function that calls the room function 'on call' with index '1' (to start the text parsing)
{
  //PRESS ENTER
  playSelect();
  if(gParser.Visible) {
    String cmd = tbParser.Text;
    lastCMD = cmd;
    //debugDisplay(String.Format("lastCMD = %s", lastCMD));
    CallRoomScript (1);
  }
}

function lbVerbs_OnSelectionChanged(GUIControl *control)
{
  playSelect();
  lblHelpVerbDesc.Text = verbDescriptionDictionary.Get(lbVerbs.Items[lbVerbs.SelectedIndex]);
}

function btnHelpPanel_OnClick(GUIControl *control, MouseButton button)
{
  playConfirm();
  open_gui(gHelp);
  close_gui(gPanel);
}

function btnHelpResume_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  close_gui(gHelp);
  open_gui(gPanel);
}

function btnConfirmCancel_OnClick(GUIControl *control, MouseButton button)
{
  playCancel();
  close_gui(gConfirm);
}

function btnDelete_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  open_gui(gConfirm);
}

function btnLoadAtStart_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  show_restore_game_dialog();
}

function btnToggleHintsTitleMenu_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  if(showHints)
  {
    lblOverHotspot.Visible = false;
    lblOverHotspot.Text = "";
    btnToggleHints.Text = "Hints hidden";
    btnToggleHintsTitleMenu.Text = "Hints hidden";
    showHints = false;
  } else {
    lblOverHotspot.Text = "@OVERHOTSPOT@";
    lblOverHotspot.Visible = true;
    btnToggleHints.Text = "Hints shown";
    btnToggleHintsTitleMenu.Text = "Hints shown";
    showHints = true;
  }
}

//##### SCRIPTED CUTSCENES #####
function setStoryBeat(storyBeat newStoryBeat)
{
  CurrentStoryBeat = newStoryBeat;
}

storyBeat getStoryBeat()
{
  return CurrentStoryBeat;
}

function btnNewGame_OnClick(GUIControl *control, MouseButton button)
{
  playConfirm();
  FadeOut(10);
  gDark.Transparency = 15;
  close_gui(gStartHelp);
  Wait(20);
  gQuickInventory.Visible = true;
  gStatusline.Visible = true;
  player.ChangeRoom(1);
  Wait(10);
  
}

//##### IN-GAME INTERACTIONS ######

function cHarker_UseInv()
{
  int shavingGlassObjectIndex = findRoomObjectIndexByName("shaving glass");
  
  //debugDisplay(String.Format("%s[%d", activeElementToUse_ElementType, activeElementToUse_Index));
  
  if(activeElementToUse_ElementType == "allInventoryItems" && activeElementToUse_Index == 3)//razor
  {
    if(cHarkersBeard.Transparency == 100)
    {
      player.Think("I do not need to shave");
    } else if(shavingGlassObjectIndex == -1)
    {
      player.Think("I cannot shave here");
    } else if(!object[shavingGlassObjectIndex].Visible && player.HasInventory(iMirror))
    {
      player.Think("I need to install my shaving glass first");
      player.FaceObject(object[shavingGlassObjectIndex]);
      player.Think("There seems to be an appropriate surface over there");
    } else if(object[shavingGlassObjectIndex].Visible && !isCharacterNearObject(object[shavingGlassObjectIndex], reachDistance, player))
    {
      player.FaceObject(object[shavingGlassObjectIndex]);
      player.Think(String.Format("I need to get closer to the %s", object[shavingGlassObjectIndex].Name));
    } else
    {
      player.Walk(object[shavingGlassObjectIndex].X + 18, object[shavingGlassObjectIndex].Y + 14, eBlock, eWalkableAreas);
      player.FaceDirection(eDirectionLeft);
      cHarkersBeard.Transparency = 100;
      player.Think("Ah, prefectly smooth");
      giveScoreOnce("perfect shave", 1);
    }
  }
}

function iLegalPapers_UseInv()
{
  //Rendu ici
}

function iFolder_UseInv()
{
  //do nothing
}

bool isThisSigned(InventoryItem* thisParentItem)
{
  Dictionary* theseNotes = getDictionariesForParentItems(thisParentItem, subitemNote);
  String signedMsg = "I signed those documents as the sollicitor representative";
  
  if(playerHasSubitem("Signatures", thisParentItem))
  {
    return (theseNotes.Get("Signatures") == signedMsg);
  } else
  {
    return false;
  }
}

function signDocument(String wholeCMD)
{
  wholeCMD = wholeCMD.Replace("Sign ", "", eCaseInsensitive);
  String documentFinder[];
  InventoryItem* thisParentItem;
  Dictionary* theseNotes;
  String signedMsg = "I signed those documents as the sollicitor representative";
  String tempString;
  
  documentFinder = findElementIndexByName(wholeCMD);
  if(documentFinder[1] != etToString(allInventoryItems))
  {
    player.Say("I don't know what to sign");
  } else 
  {
    thisParentItem = inventory[documentFinder[0].AsInt];
    if(!playerHasSubitem("Signatures", thisParentItem))
    {
      player.Say(String.Format("There is nothing in my %s", thisParentItem.Name.LowerCase()));
    } else {
      theseNotes = getDictionariesForParentItems(thisParentItem, subitemNote);
      if(theseNotes.Get("Signatures") == signedMsg)
      {
        player.Say(String.Format("I already signed the %s", thisParentItem.Name.LowerCase()));
      } else {
        if(thisParentItem.GetTextProperty("invContext") == "Classify")
        {
          player.Say("They need to be complete and classified, first");
        } else
        {
          if(player.HasInventory(iPenInk))
          {
            Display(String.Format("Jonathan signs the %s", thisParentItem.Name.LowerCase()));
            theseNotes.Set("Signatures", signedMsg);
            tempString = thisParentItem.GetTextProperty("TextDescription");
            tempString = tempString.Replace("This item is not signed", signedMsg);
            thisParentItem.SetTextProperty("TextDescription", tempString);
            giveScoreOnce(String.Format("signed the %s", thisParentItem.Name), 1);
          } else
          {
            player.Say("I need a pen and ink to sign this document");            
          }          
        }
      }
    }
  }
}

function iLedger_Interact()
{
  readThis(iLedger.GetTextProperty("ReadDisplay"), "¬∂");
}

function confirmSimpleTextbox()
{
  String textInput = tbSimpleTextbox.Text;
  
  close_gui(gSimpleTextbox);
  
  switch(lblSimpleTextbox.Text)
  {
    case "Seller's name":
      proposedSeller = textInput;
      CallRoomScript(3);
      break;
    case "Telegram recipient":
      handleTelegramRecipient(textInput);
      break;
    default:
      break;
  }
}

function tbSimpleTextbox_OnActivate(GUIControl *control)
{
  confirmSimpleTextbox();
}

String getBookPage(String noteContent, String breakageCharacter, String reunitingCharacter,  Label* thisLbl, Label* pageNumberLbl, int thePage, Button* btnBack, Button* btnNext)
{
  Dictionary* eachPage = Dictionary.Create(eSorted);
  Dictionary* eachWord = Dictionary.Create(eSorted);
  String eachWord_strings[];
  String eachPage_strings[];
  String workingString = noteContent;
  String currentWord;
  bool fullLbl = false;
  int i = 0;
  btnBack.Visible = false;
  btnNext.Visible = false;
  
  //debugDisplay(String.Format("noteContent : %s", noteContent));
  
  if(GetTextHeight(noteContent, eFontNormal, thisLbl.Width) <= thisLbl.Height)
  {
    pageNumberLbl.Text = "";
    return noteContent;
  } else
  {
    eachWord.Clear();
    //Separate into words
    while(workingString.IndexOf(breakageCharacter) != -1)
    {
      currentWord = workingString.Truncate(workingString.IndexOf(breakageCharacter));
      eachWord.Set(String.Format("%05d", i), currentWord.Replace(breakageCharacter, "", eCaseInsensitive));
      i++;
      workingString = removeOneStringInstance(workingString, currentWord);
      
      if(workingString.StartsWith(breakageCharacter)){
        workingString = removeOneStringInstance(workingString, breakageCharacter);
      }
    }
    eachWord.Set(String.Format("%05d", i), workingString);
    
    eachWord_strings = eachWord.GetValuesAsArray();
    
    //Add words until lbl is full
    workingString = "";
    for(i = 0 ; i < eachWord.ItemCount ; i++)
    {
      if(GetTextHeight(String.Format("%s %s", workingString, eachWord_strings[i]), eFontNormal, thisLbl.Width) > thisLbl.Height)
      {
        eachPage.Set(String.Format("%05d", i), workingString);
        workingString = eachWord_strings[i];
      } else
      {
        workingString = workingString.Append(reunitingCharacter);
        workingString = workingString.Append(eachWord_strings[i]);
      }
    }
    eachPage.Set(String.Format("%05d", i), workingString);
    
    //find correct page content
    eachPage_strings = eachPage.GetValuesAsArray();
    if(thePage > eachPage.ItemCount)
    {
      workingString = "";
    } else 
    {
      workingString = eachPage_strings[thePage - 1];
      if(workingString.StartsWith(reunitingCharacter))
      {
        workingString = removeOneStringInstance(workingString, reunitingCharacter);
      }
    }
    
    //page number
    pageNumberLbl.Text = String.Format("Page %d/%d", thePage, eachPage.ItemCount);
    
    //show arrows
    if(thePage > 1)
    {
      btnBack.Visible = true;
    } else
    {
      btnBack.Visible = false;
    }
    
    if(eachPage.ItemCount > thePage)
    {
      btnNext.Visible = true;
    } else
    {
      btnNext.Visible = false;
    }
    
    return workingString;
  }
}

function updateNotebook()
{
  lbNoteTitles.Clear();
  String notesToAdd[] = notes.GetKeysAsArray();
  int i;
  
  for(i = 0 ; i < notes.ItemCount ; i++)
  {
    lbNoteTitles.AddItem(notesToAdd[i]);
  }
  
  lbNoteTitles.SelectedIndex = 0;
  lblNoteDescription.Text = getBookPage(notes.Get(lbNoteTitles.Items[lbNoteTitles.SelectedIndex]), " ", " ", lblNoteDescription, lblNote_pgNb, 1, btnNotebook_prev, btnNotebook_next);
  btnDeleteNote.Enabled = (notes.ItemCount > 1); // must have at least 2 entries to remove one.  
}

function btnConfirmYes_OnClick(GUIControl *control, MouseButton button)
{
  playConfirm();
  if(gNotebook.Visible) // delete note
  {
    String noteTitle = lbNoteTitles.Items[lbNoteTitles.SelectedIndex];
    notes.Remove(noteTitle);
    lbNoteTitles.RemoveItem(lbNoteTitles.SelectedIndex);
    lbNoteTitles.SelectedIndex = 0;
    noteTitle = lbNoteTitles.Items[lbNoteTitles.SelectedIndex];
    lblNoteDescription.Text = getBookPage(notes.Get(noteTitle), " ", " ", lblNoteDescription, lblNote_pgNb, 1, btnNotebook_prev, btnNotebook_next);
    hasRead(noteTitle);
    btnDeleteNote.Enabled = (lbNoteTitles.ItemCount > 1); // must have at least 2 entries to remove one.
  }
  close_gui(gConfirm);
}

function btnNoteBook_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  updateNotebook();
  open_gui(gNotebook);
}

function btnResume_notebook_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  close_gui(gNotebook);
  closeNotebookThoughts();
}

int parseCurrentPage(Label* thisLabel)
{
  String workString = thisLabel.Text;
  workString = workString.Substring(workString.IndexOf(" "), workString.Length - workString.IndexOf("/"));
  
  return workString.AsInt;
}

int parseLastPage(Label* thisLabel)
{
  String workString = thisLabel.Text;
  workString = workString.Substring(workString.IndexOf("/") + 1, workString.Length - workString.IndexOf("/") + 1);
  return workString.AsInt;
}

function btnNotebook_next_OnClick(GUIControl *control, MouseButton button)
{
  int targetPage = parseCurrentPage(lblNote_pgNb) + 1;
  String selectedNoteTitle = lbNoteTitles.Items[lbNoteTitles.SelectedIndex];
  lblNoteDescription.Text = getBookPage(notes.Get(selectedNoteTitle), " ", " ", lblNoteDescription, lblNote_pgNb, targetPage, btnNotebook_prev, btnNotebook_next);
}

function btnNotebook_prev_OnClick(GUIControl *control, MouseButton button)
{
  int targetPage = parseCurrentPage(lblNote_pgNb) - 1;
  String selectedNoteTitle = lbNoteTitles.Items[lbNoteTitles.SelectedIndex];
  lblNoteDescription.Text = getBookPage(notes.Get(selectedNoteTitle), " ", " ", lblNoteDescription, lblNote_pgNb, targetPage, btnNotebook_prev, btnNotebook_next);
}

function lbNoteTitles_OnSelectionChanged(GUIControl *control)
{
  String noteTitle = lbNoteTitles.Items[lbNoteTitles.SelectedIndex];
  lblNoteDescription.Text = getBookPage(notes.Get(noteTitle), " ", " ", lblNoteDescription, lblNote_pgNb, 1, btnNotebook_prev, btnNotebook_next);
  hasRead(noteTitle);
}

function writeBookPages(String bookText, int leftPageNumber, String separator, String reunitor)
{
  LblBook_left.Text = getBookPage(bookText, separator, reunitor, LblBook_left, lblBook_pgNbLeft, leftPageNumber, btnBookPrev, btnBookNext);
  if(parseLastPage(lblBook_pgNbLeft) > leftPageNumber)
  {
    LblBook_right.Text = getBookPage(bookText, separator, reunitor, LblBook_right, lblBook_pgNbRight, leftPageNumber + 1, btnBookPrev, btnBookNext);
  } else
  {
    LblBook_right.Text = "";
    lblBook_pgNbRight.Text = "";
    btnBookNext.Visible = false;
  }
  
  if(leftPageNumber == 1)
  {
    btnBookPrev.Visible = false;
  } else
  {
    btnBookPrev.Visible = true;
  }
  if(parseLastPage(lblBook_pgNbLeft) == leftPageNumber + 1 || parseLastPage(lblBook_pgNbLeft) == leftPageNumber)
  {
    btnBookNext.Visible = false;
  } else
  {
    btnBookNext.Visible = true;
  }
}

function createBook(String bookTitle, String bookText, String separatorChar, String reunitorChar)
{
  books_description.Set(bookTitle, bookText);
  books_reunitor.Set(bookTitle, reunitorChar);
  books_separator.Set(bookTitle, separatorChar);
}

function createProcedureBook()
{
  String title = "Procedures";
  String content = "BOOK OF PROCEDURES.[HAWKINS, ESQ.[";
  content = content.Append("##########[SECTION 1: Client files for property sales.[When a client is selling a property, it is required to (1) pinpoint the property on a map for easy access, these pins allow a quick survey of available properties by city sectors and neighborhoods. The pins are tagged with the client's last name. (2) Create a client file, including the name, city, sector and property age (including year and current age). These files are organized alphabetically in file drawers.[");
  content = content.Append("##########[SECTION 2: Document classification[When arranging a dossier, the documents (if available, as simpler documents only have three sections, counting the introdcution and the signatures, the other document being obviously filed in between those) must follow the following logic: (1) Introduction (including a title page), (2) Current sale agreements (conditions), (3) Proof of ownership (Deed), (4) Proof of current state, including survey maps and pictures of a list of four specific rooms (no more, no less): Bedroom, dining room, kitchen, and living room, (5) Annexes of previous paperwork, including work done, hired staff, previous sales paperwork and similar items, and (6) Signatures, which must be filled for the document to be valid. Each section should be arranged by date first, then alphabetically[");
  content = content.Append("##########[SECTION 3: Under British law, we work as sollicitors, not barristers. BArristers are associated under one of four Inn of Courts, whereas sollicitors are working in private practices. Most of a sollicitor's work is to provide legal advice and coordinate legal paperwork. Barristers' work more often involve high courts pleading.");
  createBook(title, content, " ", " ");
}

function createCredits()
{
  String title = "GAME CREDITS";
  String content = "GAME DIRECTION[Danny Godin¬∂[";
  content = content.Append("DEVELOPERS[Mathieu Gaudreau[Justin Marques¬∂[");
  content = content.Append("SPECIAL THANKS[Jonathan Lessard¬∂[");
  content = content.Append(String.Format("GAME ENGINE[Adventure Game Studio %s¬∂[", System.Version));
  content = content.Append("TrueType font display uses ALFont by Javier Gonzalez and the Freetype project. Distributed under the terms of the FreeType project license.¬∂[");
  content = content.Append("Copyright notice for Josefin, font by Santiago Orozco (link: https://www.fontspace.com/josefin-sans-font-f44035)¬∂[");
  content = content.Append("Copyright notice for Gothica, font by Wojciech Kalinowski (https://www.dafont.com/gothica-2.font)¬∂[");
  content = content.Append("OGG player is alogg by Javier Gonzalez, using the Ogg Vorbis decoder, which is available from http://www.xiph.org/ Copyright (c) 2002, Xiph.org Foundation¬∂[MP3 player is almp3, by Javier Gonzalez and the FreeAmp team. It uses the mpg123 MP3 decoder, and is distributed under the terms of the GNU Lesser General Public License version 2.1.¬∂[TITLES : 8BIT11 and 8BIT12, by FabienC@RustedMusicStudio (https://rustedstudio.itch.io/free-music-10-spooky-8bit-tracks)¬∂[LostInTought, by ansimuz (https://ansimuz.itch.io/mystery-music-collection-pack-2)¬∂[Sound effects (Cancel 1, Confirm 1, Select 1) by @JDWasabi (https://jdwasabi.itch.io/8-bit-16-bit-sound-effects-pack)¬∂");
  content = content.Append("A GAME PROJECT ASSOCIATED WITH 'GAME AS RESEARCH'[Founded by Canada's Social Sciences and Humanities Research Council[(c) 2023[");
  createBook(title, content, "¬∂", "[");
}

function triggerCutscene(cutsceneIndex index)
{
  
  if(!skipAllCutscene)
  {
    switch(index)
    {
      case beginQuest:
        lastMealTime = translateTimeToMinutes(translateTimeToHHMMAM(8, 0, "AM")) + (currentDay * 24 * 60);
        adjustForDarkness = true;
        createAllTelegram();
        createFullExam();
        createProcedureBook();
        musicInRoom(ALostInThought, 2);
        setBasicTimedEvents();
        object[10].Visible = false; // open bedroom door;
        player.Transparency = 50;
        cHarkersBeard.Transparency = 90;
        Wait(10);
        player.Transparency = 0;
        cHarkersBeard.Transparency = 85;
        player.Walk(54, 170, eBlock, eAnywhere);
        player.FaceDirection(eDirectionLeft, eBlock);
        Wait(5);
        object[10].Visible = true; // close bedroom door;
        Wait(5);
        player.FaceDirection(eDirectionRight, eBlock);
        player.Say("What a night. . .");
        player.Say("I must have worked on those contracts until 3 AM");
        player.Say("I hope Mr. Hawkins will be happy with them");
        player.Say("I guess I should hurry if I want to make it to work before 10 AM");
        player.PlaceOnWalkableArea();
        player.FaceDirection(eDirectionDown);
        break;
      case getToWork:
        cHawkins.Say("Ah! Harker!");
        cHarker.FaceCharacter(cHawkins);
        if(isItBeforeThisTime(10, 00, 00, false, 1))
        {
          cHawkins.Say("Good you are on time!");
          giveScoreOnce("atWorkOnSchedule", 1);
        } else {
          cHawkins.Say("%s![You are late, young man");
          giveScoreOnce("atWorkOnSchedule", -1);
        }
        if(cHarkersBeard.Transparency == 100)
        {
          giveScoreOnce("shavedHarker", 1);
        } else {
          cHawkins.Say("I would appreciate a clean shaven clerk");
          cHawkins.Say("You are not presentable");
          giveScoreOnce("shavedHarker", -1);
          cHawkins.Say("Anyway.");
        }
        cHawkins.Say("I trust you brought back the contracts from last night");
        cHawkins.Say("Come to my office");
        cHawkins.Walk(object[43].X, object[43].Y, eBlock, eWalkableAreas);
        sit(roomObjects, 43, cHawkins, 4, false);
        break;
      case arriveInLondon:
        player.Say(String.Format(whatTimeIsIt(true)));
        player.Say("Right on time");
        player.Say("I have Mr. Hawkins' reservation at the hotel in Covent Garden, the Hummums");
        addTravelDestination(LondonHotel);
        player.Say(String.Format("I need to find my way to Purfleet too, to that %s property", proposedSeller));
        setStoryBeat(HarkerinLondon);
        break;
      case arriveInPurfleet:
        createCarfaxSeller(); 
        hotspot[1].SetTextProperty("TextDescription", String.Format("This is a 'For Sale' sign. It says to contact a certain %s, I could send them a telegram. . .", carfaxSeller));
        cHorse1.Say("NEIGH!");
        Wait(40);
        cCabby.Say("Oh my. . .");
        break;     
      default:
        debugDisplay(String.Format("Cutscene %d is supposed to start but it is not handled by the 'triggerCutscene' function", index));
        break;
    }
  }
  else
  {
    switch(index) // things to do if the cutscene is skipped
    {
      case beginQuest:
        setStoryBeat(startYourDay);
        setCurrentZone(JonathanApt);
        setupTravelDestinations();
        
        lastMealTime = translateTimeToMinutes(translateTimeToHHMMAM(8, 0, "AM")) + (currentDay * 24 * 60);
        musicInRoom(ALostInThought, 2);
        setBasicTimedEvents();
        addTravelDestination(HawkinsOffices);
        player.x = 158;
        player.y = 169;
        cHarkersBeard.x = player.x;
        cHarkersBeard.y = player.y;
        player.Transparency = 0;
        cHarkersBeard.Transparency = 85;        
        break;
      default:
        break;
    }
  }
}

function setProposedArchiveBook(int optionNb)
{
  proposedArchiveBooks[optionNb] = true;
}

bool getProposedArchiveBook(int optionNb)
{
  return proposedArchiveBooks[optionNb];
}

String findBookTextFromTitle(String bookTitle)
{
  if(books_description.Contains(bookTitle))
  {
    return books_description.Get(bookTitle);
  } else
  {
    debugDisplay(String.Format("%s is not in the book list", bookTitle));
  }
}

function show_book_gui(String bookTitle)
{
  String separator = books_separator.Get(bookTitle);
  String reunitor = books_reunitor.Get(bookTitle);
  writeBookPages(findBookTextFromTitle(bookTitle), 1, separator, reunitor);
  lblBookTitle.Text = bookTitle;
  open_gui(gBook);
}

function btnLedgerPrev_OnClick(GUIControl *control, MouseButton button)
{
  String bookTitle = lblBookTitle.Text;
  String separator = books_separator.Get(bookTitle);
  String reunitor = books_reunitor.Get(bookTitle);
  
  int leftPageNumber = parseCurrentPage(lblBook_pgNbLeft);
  if(leftPageNumber - 2 < 1)
  {
    writeBookPages(findBookTextFromTitle(bookTitle), 1, separator, reunitor);
  } else
  {
    writeBookPages(findBookTextFromTitle(bookTitle), leftPageNumber - 2, separator, reunitor);
  }
}

function btnLedgerNext_OnClick(GUIControl *control, MouseButton button)
{
  String bookTitle = lblBookTitle.Text;
  String separator = books_separator.Get(bookTitle);
  String reunitor = books_reunitor.Get(bookTitle);
  
  int rightPageNumber = parseCurrentPage(lblBook_pgNbRight);
  writeBookPages(findBookTextFromTitle(bookTitle), rightPageNumber + 1, separator,  reunitor);
}

function highlightWord(String word, GUIControl *originalTextLabel, GUIControl *highlighterLbl, int startX,  int startY)
{
  highlighterLbl.Transparency = 100;
  highlighterLbl.Visible = true;
  highlighterLbl.ZOrder = originalTextLabel.ZOrder + 1;
  if(startX == 0)
  {
    highlighterLbl.X = startX + originalTextLabel.X;// + originalTextLabel.OwningGUI.X;
  } else {
    highlighterLbl.X = startX + originalTextLabel.X + GetTextWidth(" ", eFontNormal);
  }
  highlighterLbl.Y = startY + originalTextLabel.Y;// + originalTextLabel.OwningGUI.Y;
  highlighterLbl.AsLabel.Text = word;
  highlighterLbl.Width = GetTextWidth(word, eFontNormal) * 2;
  highlighterLbl.Height = GetTextHeight(word, eFontNormal, highlighterLbl.Width);
  highlighterLbl.Transparency = 0;
  memorize(word);
}

String findThatWord(GUIControl* labelName, Label* highlightLbl, int clickX, int clickY)
{
  Dictionary* eachWord = Dictionary.Create(eSorted);
  int counter = 0;
  
  String FullText = labelName.AsLabel.Text;
  int lblWidth = labelName.AsLabel.Width;
  
  int spaceIndex = 1000;
  int alineaIndex = 1000;
  int nextCut = 1000;
  String nextCutChar = "";
  
  String thatString = FullText;
  String returnWord;
  
  while(FullText.IndexOf(" ") != -1 || FullText.IndexOf("[") != -1)
  {
    nextCut = 1000;
    nextCutChar = "";
    
    spaceIndex = FullText.IndexOf(" ");
    if(spaceIndex == -1) {
      spaceIndex = 1000;
    } else if (spaceIndex < nextCut) {
      nextCut = spaceIndex;
      nextCutChar = " ";
    }
    alineaIndex = FullText.IndexOf("[");
    if(alineaIndex == -1) {
      alineaIndex = 1000;
    } else if (alineaIndex < nextCut) {
      nextCut = alineaIndex;
      nextCutChar = "[";
    }     
    
    thatString = FullText.Truncate(nextCut);
    thatString = thatString.Replace(" ", "", eCaseInsensitive);
    thatString = thatString.Replace("[", "", eCaseInsensitive);
    eachWord.Set(String.Format("%05d", counter), thatString);
    FullText = removeOneStringInstance(FullText, thatString.Append(nextCutChar));
    counter++;
  }
  eachWord.Set(String.Format("%05d", counter), FullText);
  
  String eachWordArray[] = eachWord.GetValuesAsArray();
  
  thatString = eachWordArray[0];
  int startX = 0;
  int endX = GetTextWidth(thatString, eFontNormal);
  int startY = 0;
  int endY = GetTextHeight(thatString, eFontNormal, lblWidth);
  int newY = GetTextHeight(thatString, eFontNormal, lblWidth);
  int i = 0;
  
  while((i < eachWord.ItemCount - 1) &&
        ((clickX < startX ||
         clickX > endX) ||
        (clickY < startY ||
         clickY > endY)))
  {
    i++;
    thatString = thatString.Append(" ");
    thatString = thatString.Append(eachWordArray[i]);
    newY = GetTextHeight(thatString, eFontNormal, lblWidth);
    if(newY != endY)
    {
      startX = 0;
      endX = GetTextWidth(eachWordArray[i], eFontNormal);
      startY = endY;
      endY = newY;
    } else {
      startX = endX;
      endX = endX + GetTextWidth(eachWordArray[i], eFontNormal) + GetTextWidth(" ", eFontNormal);
    }    
  }
  
  if(i < eachWord.ItemCount) {
    returnWord = eachWordArray[i];
    if(labelName == lblNoteDescription)
    {
      highlightWord(eachWordArray[i], labelName, highlightLbl, startX, startY);
    }
  } else {
    returnWord = "";
  }
  
  return returnWord;
}

function clickALabel(GUI* thisParentGUI, Label* clickedLabel, Label* highlightLabel)
{
  playSelect();
  int clickX = mouse.x - thisParentGUI.X - clickedLabel.X;
  int clickY = mouse.y - thisParentGUI.Y - clickedLabel.Y;
  
  if(mouse.x > thisParentGUI.X + clickedLabel.X && 
     mouse.x < thisParentGUI.X + clickedLabel.X + clickedLabel.Width &&
     mouse.y > thisParentGUI.Y + clickedLabel.Y &&
     mouse.y < thisParentGUI.Y + clickedLabel.Y + clickedLabel.Height)
  {
    findThatWord(clickedLabel, highlightLabel, clickX, clickY);
  }
  
  /*playSelect();
  int clickX = mouse.x - gNotebook.X - lblNoteDescription.X;
  int clickY = mouse.y - gNotebook.Y - lblNoteDescription.Y;
  
  if(mouse.x > gNotebook.X + lblNoteDescription.X && 
     mouse.x < gNotebook.X + lblNoteDescription.X + lblNoteDescription.Width &&
     mouse.y > gNotebook.Y + lblNoteDescription.Y &&
     mouse.y < gNotebook.Y + lblNoteDescription.Y + lblNoteDescription.Height)
  {
    findThatWord(lblNoteDescription, clickX, clickY);
    //Display(String.Format("Clicked on the text at (%d, %d)", clickX, clickY));
  }*/
}

function btnNoteDescription_OnClick(GUIControl *control, MouseButton button)
{
  clickALabel(gNotebook, lblNoteDescription, lblNoteDescriptionHighlight);
}

function btnSimpeTextboxNotebook_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  open_gui(gNotebook);
}

int whatHourAfterThisPeriod(int nb, String timeType, int currentH, int currentM)
{
  switch(timeType) {
    case "Hours":
      currentH = currentH + nb;
      break;
    case "Minutes":
      currentM = currentM + nb;
      while(currentM >= 60)
      {
        currentM = currentM - 60;
        currentH++;
      }
      break;
    default:
      break;
  }
  while(currentH >= 24)
  {
    currentH = currentH - 24;
  }
  return currentH;
}

int minutesUntilTime(int targetH, String targetAMPM)
{
  int currentH = getCurrentHour();
  int currentM = getCurrentMinutes();
  String currentAMPM = getAMPM();
  
  if(targetAMPM == "PM" && targetH != 12) 
  {
    targetH = targetH + 12;
  }
  
  if(currentAMPM == "PM" && currentH != 12) 
  {
    currentH = currentH + 12;
  }
  
  if(targetH <= currentH)
  {
    targetH = targetH + 24;
  }
  
  targetH = targetH * 60;
  
  currentH = currentH * 60;
  currentH = currentH + currentM;
  
  return targetH - currentH;
}

function btnToggleForUntil_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  String currentBtnText = btnToggleForUntil.Text;
  int showHour = getCurrentHour();
  int showMinutes = getCurrentMinutes();
  String showAMPM = getAMPM();
  int textBoxContent;
  
  if(currentBtnText.EndsWith("for", eCaseInsensitive)) {
    btnToggleForUntil.Text = btnToggleForUntil.Text.Replace("for", "until", eCaseInsensitive);
    btnToggleMinHrs.Text = showAMPM;
  } else {
    btnToggleForUntil.Text = btnToggleForUntil.Text.Replace("until", "for", eCaseInsensitive);
    btnToggleMinHrs.Text = "Minutes";
  }
}

function btnToggleMinHrs_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  String ForUntilBtnText = btnToggleForUntil.Text;
  String MinHrBtnText = btnToggleMinHrs.Text;
  
  if(ForUntilBtnText.EndsWith("for", eCaseInsensitive)) {
    if(MinHrBtnText == "Minutes")
    {
      btnToggleMinHrs.Text = "Hours";
    } else  {
      btnToggleMinHrs.Text = "Minutes";
    }
  } else {
    if(MinHrBtnText == "AM")
    {
      btnToggleMinHrs.Text = "PM";
    } else  {
      btnToggleMinHrs.Text = "AM";
    }
  }
    
}

function applyWait(bool doTheFade)
{
  String ForUntilBtnText = btnToggleForUntil.Text;
  String MinHrBtnText = btnToggleMinHrs.Text;
  int minutesToAdd;
  bool sleeping = false;
  
  if(ForUntilBtnText.EndsWith("for"))
  {
    minutesToAdd = tbWaitAmount.Text.AsInt;
    if(MinHrBtnText == "Hours")
    {
      minutesToAdd = minutesToAdd * 60;
    }    
  } else {
    minutesToAdd = minutesUntilTime(tbWaitAmount.Text.AsInt, btnToggleMinHrs.Text);
  }
  
  if(minutesToAdd > 0 && lblWaitUI.Text.IndexOf("sleep") != -1)
  {
    sleeping = true;
  }
  
  hide_wait_gui();
  
  if(doTheFade)
  {
    FadeOut(3);
    addTime(0, minutesToAdd, 0, 0);
    Wait(40);
    FadeIn(3);
    player.Say(String.Format("Well, it is %s, now", whatTimeIsIt(true)));
  } else
  {
    addTime(0, minutesToAdd, 0, 0);
    Display("Time passes");
    Display(String.Format("It is now %s", whatTimeIsIt(false)));
  }
  
  if(sleeping)
  {
    hasSlept();
  }
}

function btnConfirmWait_OnClick(GUIControl *control, MouseButton button)
{
  playConfirm();
  applyWait(Room.GetProperty("FadeForWait"));
}

function btnCancelWait_OnClick(GUIControl *control, MouseButton button)
{
  playCancel();
  hide_wait_gui();
}

function btnClassifyBackToInventory_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  close_gui(gClassify);
  show_inventory_window();
}

function lbClassifiable_OnSelectionChanged(GUIControl *control)
{
  playSelect();
  String parentItemName = lblClassifyTitle.Text;
  InventoryItem* parentItem = inventory[findInvItemIndexByName(parentItemName)];
  
  Dictionary* thisParentItemDictionary_desc = getDictionariesForParentItems(parentItem, subitemDescription);
  Dictionary* thisParentItemDictionary_note = getDictionariesForParentItems(parentItem, subitemNote);
  String descDisplayed = thisParentItemDictionary_desc.Get(lbClassifiable.Items[lbClassifiable.SelectedIndex]);
  descDisplayed = descDisplayed.Append("[");
  descDisplayed = descDisplayed.Append(thisParentItemDictionary_note.Get(lbClassifiable.Items[lbClassifiable.SelectedIndex]));
  
  lblClassifyDescription.Text = descDisplayed;
}

function updateDictionaryOrder(Dictionary* thisDict, ListBox* thisLB)
{
  Dictionary* tempDict = Dictionary.Create(eNonSorted);
  String thisDictKeys[];
  int i;
  thisDictKeys = thisDict.GetKeysAsArray();
  
  for(i = 0 ; i < thisDict.ItemCount ; i++)
  {
    tempDict.Set(thisDictKeys[i], thisDict.Get(thisDictKeys[i]));
  }
  
  thisDict.Clear();
  
  for(i = 0 ; i < thisLB.ItemCount ; i++)
  {
    thisDict.Set(thisLB.Items[i], tempDict.Get(thisLB.Items[i]));
  }
}

function changeListBoxOrder(ListBox* thisLB, bool UP, int currentIndex)
{
   String itemName;
   int indexMove = 1;
   if(UP)
   {
     indexMove = -1;     
   }
   
   if(UP && currentIndex > 0 || !UP && currentIndex < thisLB.ItemCount - 1) {
     itemName = thisLB.Items[currentIndex];
     thisLB.RemoveItem(currentIndex);
     thisLB.InsertItemAt(currentIndex + indexMove, itemName);
     thisLB.SelectedIndex = currentIndex + indexMove;
   }
}

function updateClassifyListOrder(bool UP)
{
  String parentItemName = lblClassifyTitle.Text;
  InventoryItem* parentItem = inventory[findInvItemIndexByName(parentItemName)];
  Dictionary* thisParentItemDictionary_desc = getDictionariesForParentItems(parentItem, subitemDescription);
  Dictionary* thisParentItemDictionary_notes = getDictionariesForParentItems(parentItem, subitemNote);
  
  int currentSelection = lbClassifiable.SelectedIndex;
  changeListBoxOrder(lbClassifiable, UP, currentSelection);
  
  updateDictionaryOrder(thisParentItemDictionary_desc, lbClassifiable);
  updateDictionaryOrder(thisParentItemDictionary_notes, lbClassifiable);
}

function btnClassifyUP_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  updateClassifyListOrder(true);
}

function btnClassifyDOWN_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  updateClassifyListOrder(false); 
}

function btnClassifyFILEIT_OnClick(GUIControl *control, MouseButton button)
{
  playConfirm();
  String parentItemName = lblClassifyTitle.Text;
  Set* solution = getClassifySolutionSet(parentItemName);
  InventoryItem* parentItem = inventory[findInvItemIndexByName(parentItemName)];
  ValidateFileIt(lbClassifiable, solution, parentItem, 124, parentItem.GetTextProperty("invContext_classifiedName"), 2);
}

function show_simpleTextBox(String thisTitle)
{
  lblSimpleTextbox.Text = thisTitle;
  tbSimpleTextbox.Text = "";
  if(getMemorisedThought() != ". . .I forget")
  {
    lblF4Help.Text = "Press F4 to insert memorized thought";
  } else
  {
    lblF4Help.Text = "";
  }
  open_gui(gSimpleTextbox);
}

function btnSimpleTBConfirm_OnClick(GUIControl *control, MouseButton button)
{
  playConfirm();
  confirmSimpleTextbox();
}

function btnStartGame_OnClick(GUIControl *control, MouseButton button)
{
  playConfirm();
  FadeOut(6);
  close_gui(gSplash);
  createCredits();
  Wait(10);
  open_gui(gStartHelp);
  FadeIn(6);
}

function btnGameOver_quit_OnClick(GUIControl *control, MouseButton button)
{
  playConfirm();
  close_gui(gGameOver);
  open_gui(gExitGame);
}

function btnGameOver_restart_OnClick(GUIControl *control, MouseButton button)
{
  playConfirm();
  close_gui(gGameOver);
  open_gui(gRestart);
}

function btnGameOver_restore_OnClick(GUIControl *control, MouseButton button)
{
  playConfirm();
  close_gui(gGameOver);
  show_restore_game_dialog();
}

function lbTrainDepartures_OnSelectionChanged(GUIControl *control)
{
  playSelect();
  adjustTicketDescription(lbTrainDepartures.Items[lbTrainDepartures.SelectedIndex]);
}

function btnTrainTicketCancel_OnClick(GUIControl *control, MouseButton button)
{
  playCancel();
  close_gui(gTrainTickets);
}

function btnBuyTicket_OnClick(GUIControl *control, MouseButton button)
{
  playConfirm();
  String destination = lblTrainTicket_title.Text.Substring(lblTrainTicket_title.Text.IndexOf(" to ") + 4, lblTrainTicket_title.Text.Length - (lblTrainTicket_title.Text.IndexOf(" to ") + 4));
  String time = lbTrainDepartures.Items[lbTrainDepartures.SelectedIndex];
  close_gui(gTrainTickets);
  player.Say(String.Format("A ticket to %s on the %s train, please", destination, time));
  iTicketLondon.SetTextProperty("TextDescription", String.Format("My %s ticket to London", time));
  trainDepartureTime = time;
  player.AddInventory(iTicketLondon);  
}

function btnSubitem_inventory_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  close_gui(gSubitems);
  show_inventory_window();
}

function hasSeenSubitem(InventoryItem* thisParentItem, String subitemName)
{
  switch(thisParentItem)
  {
    case iTelegrams:
      if(lblSubitemDescription.Text.IndexOf("You need to go to Count Dracula's castle") != -1)
      {
        if(Game.DoOnceOnly("THE assignment"))
        {
          Display("Jonathan : Oh my! The sale is mine. . .");
          //gDark.Transparency = gDark.Transparency - 15;
          modifyCloudiness(15);
          setTelegramInclusionByIndex("Mina", 5, true);
          setTelegramInclusionByIndex("Hawkins", 4, true);
          dLawSocietyReceptionist.SetOptionState(2,eOptionOn);
          seenDraculaLetter = true;
        }
      } else if(lblSubitemDescription.Text.IndexOf("stop a few days in Munich") != -1)
      {
        //for next game maybe? :)
      }
      break;
    default:
      break;
  }
}

function showSubitemDescription(InventoryItem* thisParentItem, String subitemName,  int page)
{
  Dictionary* thisParentItemDictionary_desc = getDictionariesForParentItems(thisParentItem, subitemDescription);
  Dictionary* thisParentItemDictionary_note = getDictionariesForParentItems(thisParentItem, subitemNote);
  String descDisplayed = thisParentItemDictionary_desc.Get(subitemName);
  descDisplayed = descDisplayed.Append("[");
  descDisplayed = descDisplayed.Append(thisParentItemDictionary_note.Get(subitemName));
  
  lblSubitemDescription.Text = getBookPage(descDisplayed, " ", " ", lblSubitemDescription, lblSubitem_pageNb, page, btnSubitemDescription_prev, btnSubitemDescription_next);
  hasSeenSubitem(thisParentItem, subitemName);
}

function changeSubitemDescriptionPage(bool prevORnext)
{
  String parentItemName = lblSubitem_titles.Text;
  InventoryItem* thisParentItem = inventory[findInvItemIndexByName(parentItemName)];
  String subitemName = lbSubtiems.Items[lbSubtiems.SelectedIndex];
  int displayedPage = parseCurrentPage(lblSubitem_pageNb);
  if(prevORnext)
  {
    displayedPage--;
  } else
  {
    displayedPage++;
  }
  showSubitemDescription(thisParentItem, subitemName, displayedPage);
}

function fillSubItemLB(ListBox* lbToFill, Label* lblThisSubitemDescription,  InventoryItem* thisParentItem)
{
  int i;
  String descDisplay;
  Dictionary* Dict_desc = getDictionariesForParentItems(thisParentItem, subitemDescription);
  String dictKeys[] = Dict_desc.GetKeysAsArray();
  
  lbToFill.Clear();
  for(i = 0 ; i < Dict_desc.ItemCount ; i++) {
    lbToFill.AddItem(dictKeys[i]);
  }
  lbToFill.SelectedIndex = 0;
  
  showSubitemDescription(thisParentItem, lbToFill.Items[lbToFill.SelectedIndex], 1);
}

function lbSubtiems_OnSelectionChanged(GUIControl *control)
{
  playSelect();
  String parentItemName = lblSubitem_titles.Text;
  InventoryItem* parentItem = inventory[findInvItemIndexByName(parentItemName)];
  showSubitemDescription(parentItem, lbSubtiems.Items[lbSubtiems.SelectedIndex], 1);  
}

bool globalHighjackIndexElementVerb(String stringIndex, String stringElement, String verb)
{
  bool skipRoomInteraction = false;
  int index = stringIndex.AsInt;
  elementType eT = stringToET(stringElement);
  
  if(eT == allInventoryItems && index == 35 && (verb == "read" || verb == "look"))//Diary
  {
    show_book_gui("Diary");
    skipRoomInteraction = true;
  } else if(eT == allInventoryItems && index == 34 && (verb == "read" || verb == "look"))//Procedures
  {
    show_book_gui("Procedures");
    skipRoomInteraction = true;
  }
  
  return skipRoomInteraction;
}

function openSubinventoryGUI(String parentItemName)
{
  InventoryItem* parentItem = inventory[findInvItemIndexByName(parentItemName)];
  Dictionary* subitemDescDict_desc = getDictionariesForParentItems(parentItem, subitemDescription);
  Dictionary* subitemDescDict_note = getDictionariesForParentItems(parentItem, subitemNote);
  String invContext = parentItem.GetTextProperty("InvContext");
  
  switch(invContext)
  {
    case "Classify":
      fillSubItemLB(lbClassifiable, lblClassifyDescription,  parentItem);
      lblClassifyTitle.Text = lblClassifyTitle.Text.Replace("items", parentItemName, eCaseInsensitive);
      open_gui(gClassify);
      break;
    case "Contains":
      fillSubItemLB(lbSubtiems, lblSubitemDescription,  parentItem);
      lblSubitem_titles.Text = lblSubitem_titles.Text.Replace("items", parentItemName, eCaseInsensitive);
      open_gui(gSubitems);
      break;
    default:
      debugDisplay(String.Format("Unhandled invContext type : %s", invContext));
      break;
  }
}

function btnInvContext_OnClick(GUIControl *control, MouseButton button)
{
  playSelect();
  String parentItemName = lbInventory.Items[lbInventory.SelectedIndex];
  close_gui(gInventory);
  openSubinventoryGUI(parentItemName);
}

bool interact(String indexElementVerbHandled[]) // reacts appropriately based on the index,  element and verb passed (reactions detailed in this function's switch)
{
  int index = indexElementVerbHandled[0].AsInt;
  elementType eT = stringToET(indexElementVerbHandled[1]);
  String verb = indexElementVerbHandled[2];
  String lookDescription;
  int alternateSpriteNumber;
  int walkableAreaNumber;
  bool handledInteraction = true;
  
  Set* readContent;
  String readContentToDisplay[];
  int i;
  
  switch (verb)
  {
    case "look":
      switch (eT)
      {
        case roomObjects:
          if(object[index].Visible || object[index].GetProperty("InteractableWhenInvisible"))
          {
            lookDescription = object[index].GetTextProperty("TextDescription");
            if(object[index].GetProperty("tellsTime"))
            {
              lookDescription = addTimeToDescription(lookDescription);
            }
            player.FaceObject(object[index], eBlock);
            player.Say(lookDescription);
          } else {
            player.Say("I'm not sure what I'm looking at. . .");
          }
          break;
        case roomHotspots:
          lookDescription = hotspot[index].GetTextProperty("TextDescription");
          if(hotspot[index].GetProperty("tellsTime"))
            {
              lookDescription = addTimeToDescription(lookDescription);
            }
          player.FaceLocation(hotspot[index].WalkToX, hotspot[index].WalkToY, eBlock);
          player.Say(lookDescription);
          break;
        case allCharacters:
          if(character[index].Transparency < 100){
            lookDescription = character[index].GetTextProperty("TextDescription");
            player.FaceCharacter(character[index], eBlock);
            player.Say(lookDescription);
          } else {
            player.Say("I'm not sure what I'm looking at. . .");
          }
          break;
        case allInventoryItems:
          lookDescription = inventory[index].GetTextProperty("TextDescription");
          player.FaceDirection(eDirectionDown, eBlock);
          if(inventory[index].GetProperty("tellsTime"))
            {
              lookDescription = addTimeToDescription(lookDescription);
            }
          player.Say(lookDescription);
          break;
        default:
          player.Say("I'm not sure what I'm looking at. . .");
          break;
      }
      break;
    case "open":
      switch(eT)
      {
        case roomObjects:
          alternateSpriteNumber = object[index].GetProperty("Open_SpriteNumber");
          walkableAreaNumber = object[index].GetProperty("WalkableArea_opened");
          if(alternateSpriteNumber == -1)
          {
            player.Think("I cannot open this");
          } else if(isCharacterNearObject(object[index], reachDistance,  player))
          {
            if(alternateSpriteNumber == -2) {
              if(!object[index].Visible)
              {
                player.Think("It is already opened");
              } else {
                object[index].Visible = false;
              }
            } else if(object[index].Graphic == alternateSpriteNumber)
            {
              if(object[index].Visible)
              {
                player.Think("It is already opened");
              } else {
                object[index].Visible = true;
              }
            } else {
              object[index].Graphic = alternateSpriteNumber;
            }
            if(walkableAreaNumber != -1)
            {
              RestoreWalkableArea(walkableAreaNumber);
            }
          } else {
            player.Think("I can't reach from here");
          }
          break;
        case allInventoryItems:
          alternateSpriteNumber = inventory[index].GetProperty("Open_SpriteNumber");
          if(alternateSpriteNumber == -1)
          {
            player.Think("I cannot open this");
          } else if(inventory[index].Graphic == alternateSpriteNumber) 
          {
            player.Think("It is already opened");
          } else {
            inventory[index].Graphic = alternateSpriteNumber;
          }
          break;
        default:
          player.Think("I cannot open this");
          break;
      }
      break;
    case "close":
      switch(eT)
      {
        case roomObjects:
          alternateSpriteNumber = object[index].GetProperty("Close_SpriteNumber");
          walkableAreaNumber = object[index].GetProperty("WalkableArea_opened");
          if(alternateSpriteNumber == -1)
          {
            player.Think("I cannot close this");
          } else if(isCharacterNearObject(object[index], reachDistance,  player))
          {
            if(alternateSpriteNumber == -2) 
            {
              if(!object[index].Visible)
              {
                player.Think("It is already closed");
              } else {
                object[index].Visible = false;
              }
            } else if(object[index].Graphic == alternateSpriteNumber)
            {
              if(object[index].Visible)
              {
                player.Think("It is already closed");
              } else {
                object[index].Visible = false;
              }
            } else {
              object[index].Graphic = alternateSpriteNumber;
            }
            if(walkableAreaNumber != -1)
            {
              RemoveWalkableArea(walkableAreaNumber);
            } 
          } else {
            player.Think("I can't reach from here");
          }
          break;
        case allInventoryItems:
          alternateSpriteNumber = inventory[index].GetProperty("Close_SpriteNumber");
          if(alternateSpriteNumber == -1)
          {
            player.Think("I cannot close this");
          } else if(inventory[index].Graphic == alternateSpriteNumber) 
          {
            player.Think("It is already closed");
          } else {
            inventory[index].Graphic = alternateSpriteNumber;
          }
          break;
        default:
          player.Think("I cannot close this");
          break;
      }
      break;
    case "approach":
      if(!showHints){
        player.Think("I can walk there on my own");
      } else {
        switch(eT)
        {
          case roomObjects:
            player.Walk(object[index].X, object[index].Y, eNoBlock, eWalkableAreas);
            break;
          case roomHotspots:
            player.Walk(hotspot[index].WalkToX, hotspot[index].WalkToY, eNoBlock, eWalkableAreas);
            break;
          case allCharacters:
            player.Walk(character[index].x, character[index].y, eNoBlock, eWalkableAreas);
            break;
          default:
            player.Think("I am not not where to go");
            break;
        }
      }
      break;
    case "sit":
      sit(eT, index, player, 2,  false);
      break;
    case "take":
      if(eT == roomObjects)
      {
        if(object[index].GetProperty("takable") != -1)
        {
          if(isCharacterNearObject(object[index], reachDistance, player))
          {
            player.Think("This can be useful");
            player.AddInventory(inventory[object[index].GetProperty("takable")]);
            object[index].Visible = false;
            giveScoreOnce(inventory[object[index].GetProperty("takable")].Name, 1);
          } else {
            player.Think("I need to go a little closer");
          }
        } else {
          player.Think("I would rather leave this where it is");
        }
      }
      break;
    case "talk":
      switch (eT)
      {
        case allCharacters:
          if(character[index].Room != player.Room)
          {
            player.Think("I am not sure whom to speak to");
          } else
          {
            if (character[index].GetProperty("dialogIndex") == -1)
            {
              player.FaceCharacter(character[index], eBlock);
              player.Think("I do not know what I should say.");
            } else 
            {
              if (character[index].GetProperty("dialogMaxDistance") > -1 && !isCharacterNearCharacter(character[index], IntToFloat(character[index].GetProperty("dialogMaxDistance")), player))
              {
                player.FaceCharacter(character[index], eBlock);
                player.Think(String.Format("I need to get closer to %s", character[index].Name));
              } else 
              {
                if (character[index].GetProperty("dialogWhileSitting") != -1 && (player.GetProperty("sitting") != character[index].GetProperty("dialogWhileSitting")))
                {
                  player.FaceCharacter(character[index], eBlock);
                  player.Think(String.Format("Politeness dictates that I should sit in the %s before speaking to %s", object[character[index].GetProperty("dialogWhileSitting")].Name.LowerCase(), character[index].Name));
                } else
                {
                  if(player.GetProperty("sitting") == -1)
                  {
                    player.Walk(character[index].x, character[index].y + 15, eBlock, eWalkableAreas);
                    player.FaceDirection(eDirectionUp);
                  }
                  dialog[character[index].GetProperty("dialogIndex")].Start();
                }
              }
            }
          }
          break;
        default:
          player.Think("I am not sure whom to speak to");
          break;
      }
      break;
    case "read":
      if(eT == allInventoryItems && inventory[index].GetTextProperty("ReadDisplay") != "Null")
      {
        readThis(inventory[index].GetTextProperty("ReadDisplay"), "¬∂");
      } else {
        player.Think("I cannot read this");
      }
      break;
    case "organize":
      if(eT != allInventoryItems || inventory[index].GetTextProperty("invContext") != "Classify")
      {
        player.Think("I cannot classify this");
      } else{
        switch(inventory[index].Name)
        {
          case "Legal papers":
            openSubinventoryGUI("Legal papers");
            break;
          default:
            debugDisplay(String.Format("%s is not a defined fileFamily", inventory[index].Name));
            break;
        }
      }
      break;
    case "photograph":
      switch(eT)
      {
        case roomObjects:
          takeAPicture(object[index].Name, object[index].GetTextProperty("TextDescription"), 0);
          break;
        case roomHotspots:
          takeAPicture(hotspot[index].Name, hotspot[index].GetTextProperty("TextDescription"), 0);
          break;
        case allCharacters:
          takeAPicture(character[index].Name, character[index].GetTextProperty("TextDescription"), 0);
          break;
        case allInventoryItems:
          takeAPicture(inventory[index].Name, object[index].GetTextProperty("TextDescription"), 0);
          break;
        default:
          player.Think("I am not sure what to photograph");
          break;
      }
      break;
    default:
      handledInteraction = false;
      break;
  }
  return handledInteraction;
}

String[] roomSpecificParse(String cmd) // function that is called by the room to handle the parsing of the command
{
  String elementName;
  String indexElement[] = new String[2];
  String indexElementVerbHandled[] = new String[4];
  int i;
  indexElementVerbHandled[0] = "Null";
  indexElementVerbHandled[1] = "Null";
  indexElementVerbHandled[2] = "Skip";
  indexElementVerbHandled[3] = "true";
  
  if(cmd.IndexOf("spot ") != -1) {                                                                                         // SPOT KEYWORD
    cmd = cmd.Replace("spot ", "", eCaseInsensitive);
    cmd = cmd.Replace("all ", "", eCaseInsensitive);
    cmd = cmd.Replace("any ", "", eCaseInsensitive);
    findElementContaining(cmd);
  } else if(cmd.LowerCase() == "stand" || cmd.IndexOf("stand ") != -1) {                                                    // STAND KEYWORD
    standUp(player, 1);
  } else if(cmd.LowerCase() == "sit" || cmd.LowerCase() == "sit ") {                                                                                     // SIT KEYWORD (by itself)
    playerSitsInClosestChair();
  } else if(cmdStartsWithUSEsynonym(cmd) != "Null") {                                                                       // USE KEYWORDS
    useInteraction(cmd);
  } else if(cmd.StartsWith("wait", eCaseInsensitive)) {                                                                     // WAIT KEYWORDS
    show_wait_GUI("wait");    
  } else if(cmd.StartsWith("smoke", eCaseInsensitive) || (cmd.StartsWith("light") && cmd.IndexOf("cigar") != -1)) {                                                                     // SMOKE KEYWORDS
    if(player.HasInventory(iCigars))
    {
      if(player.HasInventory(iMatches))
      {
        player.Think("I can take a few minutes for a cigar");
        FadeOut(5);
        if(player.GetProperty("sitting") == 4 && player.Room == 1) // sitting in sofa
        {
          giveScoreOnce("smoke confortably", 1);
        }
        addTime(0, 5+Random(10), 0, 0);
        FadeIn(5);
        player.Think("Ah, that was satisfying");
      } else{
        player.Think("I need matches to light the cigar");
      }
    } else
    {
      player.Think("I have some cigars at home. . .");
    }
  } else if(cmd.StartsWith("shave", eCaseInsensitive)) {                                                                    // SHAVE KEYWORD
    if(player.HasInventory(iRazor))
    {
      useInteraction("use razor on myself");
    } else {
      player.Think("I need to find my razor to shave");
    }
  } else if (cmd.StartsWith("Note ", eCaseInsensitive) || cmd.LowerCase() == "note" || cmd.LowerCase() == "take note") {    // NOTE KEYWORD
    takeNote();
  } else if (cmd.IndexOf("look ") != -1 && cmd.IndexOf(" room") != -1)
  {
    player.Think(Room.GetTextProperty("TextDescription"));
  } else if (cmd.IndexOf("What time is it") != -1)
  {
    if(player.HasInventory(iWatch))
    {
      player.Think(String.Format("It is %s", whatTimeIsIt(true)));
    } else {
      player.Think("I do not have my watch. . . I do not know what time it is. . .");
    }
  } else if (cmd.StartsWith("Eat") || cmd.StartsWith("Consume"))
  {
    cmd.Replace("Eat ", "", eCaseInsensitive);
    cmd.Replace("Consume ", "", eCaseInsensitive);
    eatFood(cmd);
  } else if (cmd.StartsWith("Sign "))
  { 
    signDocument(cmd);
  } else if ((cmd.StartsWith("Put") || cmd.StartsWith("Insert") || cmd.StartsWith("Move")) &&                                 //MOVE PHOTOS TO DOSSIER
             (cmd.IndexOf("Carfax") != -1 || cmd.IndexOf("Photo") != -1 || cmd.IndexOf("Picture") != -1) &&
             (cmd.IndexOf("Sale") != -1 || cmd.IndexOf("Dossier") != -1 || cmd.IndexOf("Contract") != -1))
  {
    if(player.HasInventory(iSalesDossier))
    {
      if(cmd.IndexOf("Dining") != -1)
      {
        if(playerHasSubitem("Carfax's Dining", iPhotos))
        {
          transfertSubitemFromOneParentToAnother(iPhotos, iSalesDossier, "Carfax's Dining", true);
          player.Say("I put the dining room picture in the sales dossier");
        } else
        {
          player.Say("I do not have a picture of the dining room");
        }
      } else if(cmd.IndexOf("Living") != -1)
      {
        if(playerHasSubitem("Carfax's Living", iPhotos))
        {
          transfertSubitemFromOneParentToAnother(iPhotos, iSalesDossier, "Carfax's Living", true);
          player.Say("I put the living room picture in the sales dossier");
        } else
        {
          player.Say("I do not have a picture of the living room");
        }
      } else if(cmd.IndexOf("Kitchen") != -1)
      {
        if(playerHasSubitem("Carfax's Kitchen", iPhotos))
        {
          transfertSubitemFromOneParentToAnother(iPhotos, iSalesDossier, "Carfax's Kitchen", true);
          player.Say("I put the kitchen picture in the sales dossier");
        } else
        {
          player.Say("I do not have a picture of the kitchen");
        }
      } else if(cmd.IndexOf("Bedroom") != -1)
      {
        if(playerHasSubitem("Carfax's Bedroom", iPhotos))
        {
          transfertSubitemFromOneParentToAnother(iPhotos, iSalesDossier, "Carfax's Bedroom", true);
          player.Say("I put the bedroom picture in the sales dossier");
        } else
        {
          player.Say("I do not have a picture of the bedroom");
        }
      } else
      {
        player.Say("I do not think this goes in the sales dossier");
      }
    } else
    {
      player.Say("I am not sure what to do");
    }
  } else if (cmd.StartsWith("debug") && debugTools) 
  {                                                                                                         //DEBUG
              if(cmd.IndexOf("Purfleet") != -1){//GO TO PURFLEET
                player.ChangeRoom(6, 116, 187);
                setCurrentZone(Purfleet);
                player.AddInventory(iNotebook);
                player.AddInventory(iCamera);
                btnNoteBook.Visible = true;
                proposedSeller = "A";
              } else if (cmd.IndexOf("LS") != -1)//GO TO LAW SOCIETY
              {
                player.ChangeRoom(10, arrival_x[10], arrival_y[10], eDirectionUp);
                setCurrentZone(LawSocietyOffices);
                addTravelDestination(LondonHotel);
                player.AddInventory(iNotebook);
                player.AddInventory(iCamera);
                player.AddInventory(iPenInk);
                addSubitem(iFilm, "Selfie", "This is a selfie", "It was fun");
                btnNoteBook.Visible = true;
                proposedSeller = "A";
              } else if (cmd.IndexOf("Waterloo") != -1)//GO TO WATERLOO
              {
                player.ChangeRoom(5, arrival_x[5], arrival_y[5]);
                setCurrentZone(LondonTrainStation);
                addTravelDestination(LondonHotel);
                  
                player.AddInventory(iNotebook);
                player.AddInventory(iKnife);
                player.AddInventory(iCamera);
                player.AddInventory(iPenInk);
                setTelegramInclusionByIndex("Mina", 2, true);//tell her of departure over telegram
                btnNoteBook.Visible = true;
                proposedSeller = "A";
              } else if (cmd.IndexOf("photos") != -1)//GO TO PHOTOS
              {
                player.ChangeRoom(10, arrival_x[10], arrival_y[10], eDirectionUp);
                setCurrentZone(LawSocietyOffices);
                addTravelDestination(LondonHotel);
                player.AddInventory(iNotebook);
                player.AddInventory(iCamera);
                player.AddInventory(iPenInk);
                btnNoteBook.Visible = true;
                proposedSeller = "A";
                addSubitem(iFilm, "Carfax's Kitchen",  "", "");
                addSubitem(iFilm, "Carfax's Dining",  "", "");
                addSubitem(iFilm, "Carfax's Living",  "", "");
                addSubitem(iFilm, "Carfax's Bedroom",  "", "");
                playerHasAllCarfaxPictures();
                addTravelDestination(LawSocietyOffices);
              } else if (cmd.IndexOf("BritishM") != -1)//GO TO BRITISH MUSEUM
              {
                player.ChangeRoom(9, arrival_x[9], arrival_y[9]);
                setCurrentZone(BritishMuseum);
                addTravelDestination(BritishMuseum);
                addTravelDestination(LondonTrainStation);
                addTravelDestination(LondonHotel);
                player.AddInventory(iNotebook);
                player.AddInventory(iCamera);
                player.AddInventory(iPenInk);
                btnNoteBook.Visible = true;
                proposedSeller = "A";
              } else if (cmd.IndexOf("Telegram") != -1)//GO TO TELEGRAM SHOP
              {
                player.ChangeRoom(8, arrival_x[8], arrival_y[8]);
                setCurrentZone(TelegramOffice);
                addTravelDestination(LondonTrainStation);
                addTravelDestination(LondonHotel);
                player.AddInventory(iNotebook);
                player.AddInventory(iCamera);
                player.AddInventory(iPenInk);
                setTelegramInclusionByIndex("Hawkins", 2, true);
                setTelegramInclusionByIndex("Hawkins", 3, true);
                setTelegramInclusionByIndex("Hawkins", 4, true);
                btnNoteBook.Visible = true;
                if(isThisTimeBeforeThisTime(whatTimeIsIt(false), translateTimeToHHMMAM(9, 1, "AM")))
                {
                  addTime(0, translateTimeToMinutes(translateTimeToHHMMAM(9, 1, "AM")) - translateTimeToMinutes(whatTimeIsIt(false)), 0, 0);
                }
                takeAPicture("Selfie", "This is a picture of myself", 0);
                proposedSeller = "A";
              } else if(cmd.IndexOf("skipToDracula"))
              {
                if(player.Room != 2)
                {
                  debugDisplay("This only works in room 2 (Hawkins' Office)");
                } else
                {
                  createHawkinsPropertyFile("A", "London", "East", 698);
                  CallRoomScript(5);
                }                
              } else if (cmd.IndexOf("packyourthings") != -1)
              {
                CurrentStoryBeat = packYourThings;
                debugDisplay("Story beat set to packYourThings");
              } else if (cmd.IndexOf("getnotebook") != -1)
              {
                player.AddInventory(iNotebook);
                btnNoteBook.Visible = true;
                notableSay(player, "Long string", "DEBUT This is a very long string of text, This is a very long string of text. This is a very long string of text, This is a very long string of text. This is a very long string of text, This is a very long string of text. This is a very long string of text, This is a very long string of text. This is a very long string of text, This is a very long string of text. This is a very long string of text, This is a very long string of text. FIN boo", 0); 
              }
              for(i = 0 ; i < Game.InventoryItemCount ; i++)
              {
                if(cmd.IndexOf(inventory[i].Name) != -1 && !player.HasInventory(inventory[i]))
                {
                  player.AddInventory(inventory[i]);
                } 
              } 
              if(cmd.IndexOf("HawkinsKit") != -1) {
                player.AddInventory(iLegalPapers);
                player.AddInventory(iNotebook);
                player.ChangeRoom(2);
              }
  } else
  {
    indexElement = findElementIndexByName(cmd);
    indexElementVerbHandled[0] = indexElement[0];
    indexElementVerbHandled[1] = indexElement[1];
    if(indexElement[1] != "Null") {
      indexElementVerbHandled[2] = findVerbInDictionary(cmd);
    } else {
      indexElementVerbHandled[2] = "Null";
    }
  }
  
  if(globalHighjackIndexElementVerb(indexElementVerbHandled[0], indexElementVerbHandled[1], indexElementVerbHandled[2]))
  {
    indexElementVerbHandled[2] = "Skip";
  }
  
  return indexElementVerbHandled;
}

function btnCloseLedger_OnClick(GUIControl *control, MouseButton button)
{
  close_gui(gBook);
}

function btnCloseExam_OnClick(GUIControl *control, MouseButton button)
{
  exam_SubmittedAnswers.Set(lblExam_question.Text, tbExam_Answer.Text);
  close_gui(gExam);
}

function btnExam_prev_OnClick(GUIControl *control, MouseButton button)
{
  modifyExamQuestion(false);
}

function btnExam_next_OnClick(GUIControl *control, MouseButton button)
{
  modifyExamQuestion(true);
}

function btnCredits_OnClick(GUIControl *control, MouseButton button)
{
  show_book_gui("GAME CREDITS");
}

function BtnMultClickSpeed_OnClick(GUIControl *control, MouseButton button)
{
  if(BtnMultClickSpeed.Text == "3-Click Blink")
  {
    BtnMultClickSpeed.Text = "2-Click Run";
  } else
  {
    BtnMultClickSpeed.Text = "3-Click Blink";
  }
}

function btnSubitemDescription_prev_OnClick(GUIControl *control, MouseButton button)
{
  changeSubitemDescriptionPage(true);
}

function btnSubitemDescription_next_OnClick(GUIControl *control, MouseButton button)
{
  changeSubitemDescriptionPage(false);
}
